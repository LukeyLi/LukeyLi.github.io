<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>java的各种锁 | LukeyLi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Lukeyli,Lukeyli's Blog" />
  
  <meta name="description" content="Java按照是否对资源加锁分为乐观锁和悲观锁，不是真实的锁，而是一种设计思想。 悲观锁悲观锁的思想是，它总认为最坏的情况可能会出现，它认为数据可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 资源 或者 数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。悲">
<meta name="keywords" content="悲观锁,多线程,乐观锁">
<meta property="og:type" content="article">
<meta property="og:title" content="java的各种锁">
<meta property="og:url" content="https://lukeyli.github.io/2020/02/03/java的各种锁/index.html">
<meta property="og:site_name" content="LukeyLi&#39;s Blog">
<meta property="og:description" content="Java按照是否对资源加锁分为乐观锁和悲观锁，不是真实的锁，而是一种设计思想。 悲观锁悲观锁的思想是，它总认为最坏的情况可能会出现，它认为数据可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 资源 或者 数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。悲">
<meta property="og:image" content="https://lukeyli.github.io/2020/02/03/java的各种锁/转账.jpg">
<meta property="og:image" content="https://lukeyli.github.io/2020/02/03/java的各种锁/并发.jpg">
<meta property="og:updated_time" content="2020-02-19T14:46:44.337Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java的各种锁">
<meta name="twitter:description" content="Java按照是否对资源加锁分为乐观锁和悲观锁，不是真实的锁，而是一种设计思想。 悲观锁悲观锁的思想是，它总认为最坏的情况可能会出现，它认为数据可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 资源 或者 数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。悲">
<meta name="twitter:image" content="https://lukeyli.github.io/2020/02/03/java的各种锁/转账.jpg">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  


</head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">LukeyLi&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/home">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        LukeyLi&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个不断进步的程序猿的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="MinHow" target="_blank" href="/home">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="https://github.com/LukeyLi">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=f0dLS01PTkZNSj8ODlEcEBI">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-java的各种锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      java的各种锁
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/java/">java</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-02-03
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>Java按照是否对资源加锁分为乐观锁和悲观锁，不是真实的锁，而是一种设计思想。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁的思想是，它总认为最坏的情况可能会出现，它认为数据可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 资源 或者 数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。</p>
<p>Java中的 Synchronized 和 ReentrantLock 等独占锁（排他锁）也是一种悲观锁思想的实现，因为Synchronzied 和 ReetrantLocal不管是否持有资源，它都会尝试去加锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁的思想与 悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案一般来说有两种：版本号机制 和 CAS实现。乐观锁多适用于多读的应用类型，以提高吞吐量。</p>
<p>Java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的，</p>
<h4 id="悲观锁的使用场景"><a href="#悲观锁的使用场景" class="headerlink" title="悲观锁的使用场景"></a>悲观锁的使用场景</h4><p>悲观锁不仅会对写操作加锁还会对读操作加锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from student where name = &quot;a&quot; for update</div></pre></td></tr></table></figure></p>
<p>这条sql语句从Student表中选取name = “a”的记录并对其加锁，那么其他写操作在这个事务提交之前都不会对这条数据进行操作，起到了独占和排他的作用。</p>
<p>悲观锁因为对读写都加锁，所以它的性能比较低。对于现在互联网提倡(高性能、高可用、高并发)来说，悲观锁的实现用的越来越少，但是一般多读的情况下还是需要使用悲观锁的，因为虽然加锁的性能比较低，但是也组织了像乐观锁一样，遇到写不一致的情况下一直重试的时间。</p>
<h4 id="乐观锁的使用场景"><a href="#乐观锁的使用场景" class="headerlink" title="乐观锁的使用场景"></a>乐观锁的使用场景</h4><p>相对悲观锁而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。</p>
<p>乐观锁的适用场景，典型的比如成本系统，柜员要对一笔金额做修改，为了保证数据的准确性和实效性，使用悲观锁锁住某个数据后，再遇到其他需要修改数据的操作，那么此操作就无法完成金额的修改，对产品来说是灾难性的一刻，使用乐观锁的版本号机制就能够解决这个问题。</p>
<h4 id="乐观锁的实现方式"><a href="#乐观锁的实现方式" class="headerlink" title="乐观锁的实现方式"></a>乐观锁的实现方式</h4><p>乐观锁一般有两种实现方式：采用版本号机制 和 CAS（Compare-and-Swap，即比较并替换）算法实现。</p>
<h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>版本号机制是在数据表中加上一个 version 字段来实现的，表示数据被修改的次数，当执行写操作并且写入成功后，version = version + 1，当线程A要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>以账户存入取出为例子理解这个过程：<br><img src="//lukeyli.github.io/2020/02/03/java的各种锁/转账.jpg" alt=""></p>
<ul>
<li>账户表数据表有两个字段分别是金额和version, 金额的属性是能实时变化，而version 表示的是金额每次发生变化的版本，一般的策略是，当金额发生改变时，version 采用递增的策略每次都在上一个版本号的基础上 + 1。假如这个人的存款有100元钱</li>
<li>开启事务一：当户主执行存200元钱写入操作，先读账户表还有多少钱，此时为100元，可以执行写操作，并把数据库中的钱更新为 300 元，提交事务。账户表的钱由100 -&gt; 300,version的版本号由 0 -&gt; 1。</li>
<li>开启事务二：后面户主做了发型，消费了100元，需要先执行读请求，查看金库中的钱还有300元，此时的版本号是1，然后从账户消费掉，提交事务。账户表的钱由300 -&gt; 200，此时版本由 1 -&gt; 2。</li>
</ul>
<p><strong> 上面两种情况是最乐观的情况，上面的两个事务都是顺序执行的，也就是事务一和事务二互不干扰，那么事务要并行执行会如何呢？ </strong></p>
<ul>
<li>事务一开启，户主先执行读操作，读取100元金额和版本号0，执行写操作，将存款更新为300<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">begin</div><div class="line">update 表 set 金额 = 300,version = version + 1 where 金额 = 100 and version = 0</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时金额改为 120，版本号为1，事务还没有提交<br>事务二开启，户主先执行读操作，读取100元金额和版本号0，执行写操作，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">begin </div><div class="line">update 表 set 金额 = 0,version = version + 1 where 金额 = 100 and version = 0</div></pre></td></tr></table></figure></p>
<p>此时金额改为 0，版本号变为 1，事务未提交</p>
<p>现在提交事务一，金额为300，版本变更为1。事务二的更新建立再版本0上，将会重新读取操作。</p>
<h5 id="CAS场景"><a href="#CAS场景" class="headerlink" title="CAS场景"></a>CAS场景</h5><p>经典并发问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public class Counter &#123;</div><div class="line"></div><div class="line">    int count = 0;</div><div class="line"></div><div class="line">    public int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCount(int count) &#123;</div><div class="line">        this.count = count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void add()&#123;</div><div class="line">        count += 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void dec()&#123;</div><div class="line">        count -= 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Consumer extends Thread&#123;</div><div class="line"></div><div class="line">    Counter counter;</div><div class="line"></div><div class="line">    public Consumer(Counter counter)&#123;</div><div class="line">        this.counter = counter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for(int j = 0;j &lt; Test.LOOP;j++)&#123;</div><div class="line">            counter.dec();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Producer extends Thread&#123;</div><div class="line"></div><div class="line">    Counter counter;</div><div class="line"></div><div class="line">    public Producer(Counter counter)&#123;</div><div class="line">        this.counter = counter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for(int i = 0;i &lt; Test.LOOP;++i)&#123;</div><div class="line">            counter.add();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">    final static int LOOP = 1000;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line"></div><div class="line">        Counter counter = new Counter();</div><div class="line">        Producer producer = new Producer(counter);</div><div class="line">        Consumer consumer = new Consumer(counter);</div><div class="line"></div><div class="line">        producer.start();</div><div class="line">        consumer.start();</div><div class="line"></div><div class="line">        producer.join();</div><div class="line">        consumer.join();</div><div class="line"></div><div class="line">        System.out.println(counter.getCount());</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果不都为0，出现了并发数据不一致的问题，原因是count -= 1 和 count+= 1 执行步骤分为三步:</p>
<ul>
<li>从内存中读取count的值，把他放入寄存器中</li>
<li>执行 + 1 或者 -1 的操作</li>
<li>执行完成的结果再复制到内存中<br><img src="//lukeyli.github.io/2020/02/03/java的各种锁/并发.jpg" alt=""><br>如图线程A,线程B同时读取count的值，两边都+1，结果会是1，与实际预期2不符合。<br>保证原子性，必须加锁，使用Synchronzied 或者 ReentrantLock，它们是悲观锁的实现。<h5 id="CAS定义"><a href="#CAS定义" class="headerlink" title="CAS定义"></a>CAS定义</h5>CAS 即 compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization</li>
</ul>
<p>CAS中涉及的三个要素<br>1.需要读写的内存值V<br>2.进行比较的值A<br>3.拟写入的新值B<br>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h4 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>ABA 问题说的是，如果一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？可以是由 A -&gt; B -&gt; A 的这种情况，但是 AtomicInteger 却不会这么认为，它只相信它看到的，它看到的是什么就是什么。</p>
<p>JDK 1.5 以后的 AtomicStampedReference类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>也可以采用CAS的一个变种DCAS来解决这个问题。DCAS，是对于每一个V增加一个引用的表示修改次数的标记符。对于每个V，如果引用修改了一次，这个计数器就加1。然后再这个变量需要update的时候，就同时检查变量的值和计数器的值。</p>
<h5 id="循环开销大"><a href="#循环开销大" class="headerlink" title="循环开销大"></a>循环开销大</h5><p>乐观锁在进行写操作的时候会判断是否能够写入成功，如果写入不成功将触发等待 -&gt; 重试机制，这种情况是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期获取不到锁的情况，另外，自旋循环对于性能开销比较大。</p>
<h4 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h4><p>简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用 Synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</li>
</ul>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>同一时刻只能有一个线程获取到锁。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？<br>通常有两种处理方式：<br>1.没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁<br>2.把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</p>
<h5 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class SpinLock &#123;</div><div class="line">    private AtomicBoolean available = new AtomicBoolean(false);</div><div class="line">    public void lock() &#123;</div><div class="line">        // 循环检测尝试获取锁</div><div class="line">        while (!tryLock()) &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;再次尝试获取锁&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;获取到锁&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean tryLock()&#123;</div><div class="line">        // 尝试获取锁，成功返回true，失败返回false</div><div class="line">        return available.compareAndSet(false,true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unLock() &#123;</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;解锁&quot;);</div><div class="line">        if (!available.compareAndSet(true, false)) &#123;</div><div class="line">            throw new RuntimeException(&quot;释放锁失败&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。 </li>
<li>这个例子的自旋锁无法保证多线程竞争的公平性，即无法满足等待时间最长的线程优先获取锁，会造成某些线程一直都未获取到锁造成线程饥饿。<br>类似<br>解决线程饥饿，将采取排队的方式解决该问题。排队自旋锁，如TicketLock，MCSLock，CLHLock。</li>
</ul>
<h5 id="TicketLock"><a href="#TicketLock" class="headerlink" title="TicketLock"></a>TicketLock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class TicketLock&#123;</div><div class="line">    // 服务号</div><div class="line">    private AtomicInteger serviceNum = new AtomicInteger();</div><div class="line">    // 排队号</div><div class="line">    private AtomicInteger ticketNum = new AtomicInteger();</div><div class="line"></div><div class="line">    //获取锁。如果成功，返回当前线程的排队号</div><div class="line">    public int lock() &#123;</div><div class="line">        // 首先原子性地获得一个排队号</div><div class="line">        int myTicketNum = ticketNum.getAndIncrement();</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 加入排队,排队号:&quot; + myTicketNum + &quot;距离就餐号码：&quot; + serviceNum.get());</div><div class="line">        while (myTicketNum != serviceNum.get()) &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;在排队，号码为：&quot; + myTicketNum + &quot;等待号码：&quot; + serviceNum.get());</div><div class="line">        &#125;</div><div class="line">        return myTicketNum;</div><div class="line">    &#125;</div><div class="line">    //释放锁,传入当前</div><div class="line">    public void unlock(int myTicket) &#123;</div><div class="line">        // 只有当前线程拥有者才能释放锁</div><div class="line">        serviceNum.compareAndSet(myTicket, myTicket + 1);</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;已消费完,下个就餐号码：&quot; + serviceNum.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面获取自己的号码，可以对号码进行更改，这样会造成紊乱，锁不能及时释放。需要一个确保每个人按照自己的号码排队办业务的角色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TicketLock2 implements Lock &#123;</div><div class="line">    // 服务号</div><div class="line">    private AtomicInteger serviceNum = new AtomicInteger();</div><div class="line">    // 排队号</div><div class="line">    private AtomicInteger ticketNum = new AtomicInteger();</div><div class="line"></div><div class="line">    private ThreadLocal&lt;Integer&gt; ticketLocal = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    //获取锁。如果成功，返回当前线程的排队号</div><div class="line">    @Override</div><div class="line">    public void lock() &#123;</div><div class="line">        // 首先原子性地获得一个排队号</div><div class="line">        int myTicketNum = ticketNum.getAndIncrement();</div><div class="line">        ticketLocal.set(myTicketNum);</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;加入排队,排队号:&quot; + myTicketNum + &quot;距离就餐号码：&quot; + serviceNum.get());</div><div class="line">        while (myTicketNum != serviceNum.get()) &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;在排队，号码为：&quot; + myTicketNum + &quot;等待号码：&quot; + serviceNum.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //释放锁,传入当前</div><div class="line">    @Override</div><div class="line">    public void unlock() &#123;</div><div class="line">        // 只有当前线程拥有者才能释放锁</div><div class="line">        Integer currentTicket  = ticketLocal.get();</div><div class="line">        serviceNum.compareAndSet(currentTicket, currentTicket + 1);</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;已消费完,下个就餐号码：&quot; + serviceNum.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>缺点</p>
<ul>
<li>在多处理器上，每个进程/线程占用的处理器都在读写同一个变量queueNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。<br>为解决这个问题，MCSLock 和CLHLock应运而生。</li>
</ul>
<h5 id="CLHLock"><a href="#CLHLock" class="headerlink" title="CLHLock"></a>CLHLock</h5><p>CLH 是一种基于链表的可扩展，高性能，公平的自旋锁，申请线程只能在本地变量上自旋，它会不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。<br>1.公平，FIFO，先来后到的顺序进入锁<br>2.而且没有竞争同一个变量，因为每个线程只要等待自己的前继释放就好了。<br>3.空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。</p>
<ul>
<li>适合CLH在SMP系统结构下。<br>缺点：</li>
<li>在NUMA系统架构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，解决NUMA系统结构的思路是MCS队列锁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">![](JAVA各种锁/CLHLock.jpg)</div><div class="line">public class CLHLock implements Lock &#123;</div><div class="line">    public static class CLHNode&#123;</div><div class="line">        private volatile boolean isLocked = true;</div><div class="line">    &#125;</div><div class="line">    //尾部节点</div><div class="line">    private volatile CLHNode tail;</div><div class="line"></div><div class="line">    private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    private static final AtomicReferenceFieldUpdater&lt;CLHLock,CLHNode&gt; UPDATER =</div><div class="line">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class,CLHNode.class,&quot;tail&quot;);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void lock()&#123;</div><div class="line">        CLHNode node = new CLHNode();</div><div class="line">        LOCAL.set(node);</div><div class="line">        // 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点</div><div class="line">        CLHNode preNode = UPDATER.getAndSet(this, node);</div><div class="line">        if(preNode != null) &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;需要排队吗?&quot; + preNode.isLocked + &quot;，tail:&quot; + tail.isLocked );</div><div class="line">            // 前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁</div><div class="line">            while (preNode.isLocked) &#123;</div><div class="line">                System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;还在排队&quot; );</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;线程&quot; +  Thread.currentThread().getName() + &quot;不需要排队了，后面的人别插队：&quot; + tail.isLocked );</div><div class="line">            preNode = null;</div><div class="line">            LOCAL.set(node);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;线程&quot; +  Thread.currentThread().getName() + &quot;前面没人，我还没吃，后面的人别插队&quot; + tail.isLocked );</div><div class="line">        &#125;</div><div class="line">        // 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void unlock() &#123;</div><div class="line">        // 获取当前线程对应的节点</div><div class="line">        CLHNode node = LOCAL.get();</div><div class="line">        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;用完餐了，节点值：&quot; + node.isLocked);</div><div class="line">        // 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态职位false，表示当前线程释放了锁</div><div class="line">        if (!UPDATER.compareAndSet(this, node, null)) &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;开始叫下一位&quot; + tail.isLocked);</div><div class="line">            node.isLocked = false;</div><div class="line">        &#125;</div><div class="line">        node = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="MCSLock"><a href="#MCSLock" class="headerlink" title="MCSLock"></a>MCSLock</h5><p>MSC与CLH最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:</p>
<ul>
<li>CLH是在前趋结点的locked域上自旋等待，而MCS是在自己的结点的locked域上自旋等待。</li>
</ul>
<p>具体实现：前驱节点在释放锁之后，会主动将后继节点的locked域更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class MCSLock implements Lock &#123;</div><div class="line">    public static class MCSNode &#123;</div><div class="line">        volatile MCSNode next;</div><div class="line">        volatile boolean isLocked = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    //队列</div><div class="line">    private volatile MCSNode queue;</div><div class="line"></div><div class="line">    private static final AtomicReferenceFieldUpdater&lt;MCSLock,MCSNode&gt;UPDATE =</div><div class="line">            AtomicReferenceFieldUpdater.newUpdater(MCSLock.class,MCSNode.class,&quot;queue&quot;);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void lock() &#123;</div><div class="line">        //创建节点并保存到ThreadLocal中</div><div class="line">        MCSNode currentNode = new MCSNode();</div><div class="line">        NODE.set(currentNode);</div><div class="line">        //将queue设置为当前节点，并且返回之前的节点</div><div class="line">        MCSNode preNode = UPDATE.getAndSet(this, currentNode);</div><div class="line">        if (preNode != null) &#123;</div><div class="line">            // 如果之前节点不为null，表示锁已经被其他线程持有</div><div class="line">            preNode.next = currentNode;</div><div class="line">            // 循环判断，直到当前节点的锁标志位为false</div><div class="line">            while (currentNode.isLocked) &#123;</div><div class="line">                System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;还在排队&quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;轮到我了&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;哈哈，不用排队，美滋滋&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void unlock() &#123;</div><div class="line">        MCSNode currentNode = NODE.get();</div><div class="line">        // next为null表示没有正在等待获取锁的线程</div><div class="line">        if (currentNode.next == null) &#123;</div><div class="line">            // 更新状态并设置queue为null</div><div class="line">            if (UPDATE.compareAndSet(this, currentNode, null)) &#123;</div><div class="line">                System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;后面没人排队了&quot;);</div><div class="line">                // 如果成功了，表示queue==currentNode,即当前节点后面没有节点了</div><div class="line">                return;</div><div class="line">            &#125;else &#123;</div><div class="line">                // 如果不成功，表示queue!=currentNode,即当前节点后面多了一个节点，表示有线程在等待</div><div class="line">                System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;后面又来一个排队着呢&quot;);</div><div class="line">                // 如果当前节点的后续节点为null，则需要等待其不为null（参考加锁方法）</div><div class="line">                while (currentNode.next == null) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;else &#123;</div><div class="line">            // 如果不为null，表示有线程在等待获取锁，此时将等待线程对应的节点锁状态更新为false，同时将当前线程的后继节点设为null</div><div class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;后面有人排队着呢&quot;);</div><div class="line">            currentNode.next.isLocked = false;</div><div class="line">            currentNode.next = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年02月19日 22:46</p>
        <p>原始链接： <a class="post-url" href="/2020/02/03/java的各种锁/" title="java的各种锁">https://lukeyli.github.io/2020/02/03/java的各种锁/</a></p>
        <footer>
            <a href="https://lukeyli.github.io">
                <img src="/images/logo.png" alt="LukeyLi">
                LukeyLi
            </a>
        </footer>
    </div>
</div>

      
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lukeyli.github.io/2020/02/03/java的各种锁/&title=《java的各种锁》 — LukeyLi's Blog&pic=https://lukeyli.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lukeyli.github.io/2020/02/03/java的各种锁/&title=《java的各种锁》 — LukeyLi's Blog&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lukeyli.github.io/2020/02/03/java的各种锁/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java的各种锁》 — LukeyLi's Blog&url=https://lukeyli.github.io/2020/02/03/java的各种锁/&via=https://lukeyli.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lukeyli.github.io/2020/02/03/java的各种锁/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://lukeyli.github.io/2020/02/03/java的各种锁/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/悲观锁/" class="color4">悲观锁</a>
      
    <a href="/tags/多线程/" class="color4">多线程</a>
      
    <a href="/tags/乐观锁/" class="color4">乐观锁</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#悲观锁"><span class="post-toc-text">悲观锁</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#乐观锁"><span class="post-toc-text">乐观锁</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#悲观锁的使用场景"><span class="post-toc-text">悲观锁的使用场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#乐观锁的使用场景"><span class="post-toc-text">乐观锁的使用场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#乐观锁的实现方式"><span class="post-toc-text">乐观锁的实现方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#版本号机制"><span class="post-toc-text">版本号机制</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#CAS场景"><span class="post-toc-text">CAS场景</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#CAS定义"><span class="post-toc-text">CAS定义</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#乐观锁的缺点"><span class="post-toc-text">乐观锁的缺点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ABA问题"><span class="post-toc-text">ABA问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#循环开销大"><span class="post-toc-text">循环开销大</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CAS与synchronized的使用情景"><span class="post-toc-text">CAS与synchronized的使用情景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#自旋锁"><span class="post-toc-text">自旋锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#自旋锁的实现"><span class="post-toc-text">自旋锁的实现</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#TicketLock"><span class="post-toc-text">TicketLock</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#CLHLock"><span class="post-toc-text">CLHLock</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#MCSLock"><span class="post-toc-text">MCSLock</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/02/18/java对象/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          java对象
        
      </span>
    </a>
  
  
    <a href="/2020/02/03/Java8时间与日期API/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Java8时间与日期API</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
          <div id="uyan_frame"></div>
  <script src="http://v2.uyan.cc/code/uyan.js?uid=2147648"></script>

    
</section>
        
      </div>
      <footer id="footer">

  <div class="outer">

    <div id="footer-info" class="inner">
      
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="300" height="600" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 3px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/haru/haru.model.json",0.5)</script>
  
      

<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 LukeyLi<br>
      </p>
    </div>

  </div>
</footer>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://lukeyli.github.io",
      animate: true,
      isHome: false,
      share: true
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Java基础/">Java基础</a><a class="category-link" href="/categories/Json详解/">Json详解</a><a class="category-link" href="/categories/git/">git</a><a class="category-link" href="/categories/java/">java</a><a class="category-link" href="/categories/rabbitMQ/">rabbitMQ</a><a class="category-link" href="/categories/sql/">sql</a><a class="category-link" href="/categories/前端/">前端</a><a class="category-link" href="/categories/后端框架/">后端框架</a><a class="category-link" href="/categories/设计模式/">设计模式</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Mark-Word/" style="font-size: 10px;">Mark Word</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/java8/" style="font-size: 10px;">java8</a> <a href="/tags/java对象头/" style="font-size: 10px;">java对象头</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/servlet/" style="font-size: 15px;">servlet</a> <a href="/tags/乐观锁/" style="font-size: 10px;">乐观锁</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/悲观锁/" style="font-size: 10px;">悲观锁</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a> <a href="/tags/设计模式/" style="font-size: 20px;">设计模式</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/home">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Mark-Word/" style="font-size: 10px;">Mark Word</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/java8/" style="font-size: 10px;">java8</a> <a href="/tags/java对象头/" style="font-size: 10px;">java对象头</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/servlet/" style="font-size: 15px;">servlet</a> <a href="/tags/乐观锁/" style="font-size: 10px;">乐观锁</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/悲观锁/" style="font-size: 10px;">悲观锁</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a> <a href="/tags/设计模式/" style="font-size: 20px;">设计模式</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  </div>
</body>
</html>