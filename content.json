{"meta":{"title":"LukeyLi's Blog","subtitle":null,"description":null,"author":"LukeyLi","url":"https://lukeyli.github.io"},"pages":[{"title":"","date":"2020-01-25T12:34:31.798Z","updated":"2020-01-25T12:34:31.798Z","comments":true,"path":"about/index.html","permalink":"https://lukeyli.github.io/about/index.html","excerpt":"","text":"关于我 从事java后端开发, 熟悉使用ssm、springCloud等主流框架。热爱生活、热爱新技术、热爱新事物。 关于工作 城市：福州 关于学习 活到老学到老，正在往终身学习者前进。 关于座右铭 The Harder You Work, The Luckier You Will Be. 关于爱好 热爱运动，喜欢慢跑,听音乐看电影等。"}],"posts":[{"title":"简单工厂","slug":"简单工厂","date":"2020-01-24T15:01:53.000Z","updated":"2020-01-26T14:49:18.244Z","comments":true,"path":"2020/01/24/简单工厂/","link":"","permalink":"https://lukeyli.github.io/2020/01/24/简单工厂/","excerpt":"","text":"简单工厂定义：由一个工厂对象决定创建出哪一种产品类的实例。白话: 在家里，做菜得买洗炒菜等繁琐的步骤,现在都嫌做菜麻烦。但是我们还是想吃五花八门的菜怎么办，打开饿了么app对不同的菜品下单就好,不需要关心他是怎么做出来的，能吃到自己点的餐就好。类型：创建型，但不属于 GOF23 种设计模式。 适用场景1.工厂类负责创建的对象比较少2.客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心优点：1.只需要传入一个正确的参数，就可以获取你所需要的对象而无序知道其创建细节2.将对象的创建和使用分离缺点：1.工厂类的职责相对过重，增加新产品时需要修改工厂类的判断逻辑，违背开闭原则。当产品过多的时候会产生很多的类，不利于维护。2.无法形成基于继承的等级结构 coding场景：这个餐馆比较牛掰，菜品丰富，有粤菜、川菜, 在Test类(Client端)创建相应的菜品。(其实应该是具体的菜名)代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041/** * @description:菜品 * @author: lzy **/public abstract class Cuisine &#123; public abstract void cookie();&#125;/** * @description:粤菜 * @author: lzy **/public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;/** * @description:川菜 * @author: lzy **/public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public class Test &#123; public static void cookieSichuan() &#123; Cuisine cuisine = new SichuanCuisine(); cuisine.cookie(); &#125; public static void main(String[] args) &#123; cookieSichuan(); &#125;&#125; 从上面代码来看，Test 类里面声明了一个 Cuisine 类型的变量指向其 SichuanCuisine 子类, Test类是非常依赖子类（违反依赖倒置原则）。想要粤菜就得创建Cuisine的子类CantoneseCuisine。我们意愿是让客户端代码不依赖对应的产品类，把创建具体视频类的逻辑对客户端代码隐藏，使应用层的代码不依赖对应的具体实现类。 通过一个工厂类解决此问题1234567891011public class CuisineFactory &#123; //v1 根据传入的类型创建具体的实例 public Cuisine getCuisine(String type) &#123; if (&quot;Sichuan&quot;.equalsIgnoreCase(type)) &#123; return new SichuanCuisine(); &#125; else if (&quot;Cantonese&quot;.equalsIgnoreCase(type)) &#123; return new CantoneseCuisine(); &#125; return null; &#125;&#125; 问题是解决了，但是如果新增菜品，就需要新建类。需要修改CuisineFactory的判断逻辑，违背开闭原则。工厂方法类可以通过反射来优化上诉问题。通过传入的Class类型，创建对应实例，当需要新的实例时，只需要新建一个类即可，不需要修改CuisineFactory类内部创建类的判断逻辑。代码如下：12345678910111213141516171819202122232425262728public class CuisineFactory &#123; //v2 通过反射优化工厂创建对应实例 public Cuisine getCuisine(Class c) &#123; Cuisine cuisine = null; try &#123; cuisine = (Cuisine) Class.forName(c.getName()).newInstance(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return cuisine; &#125;&#125;public class Test &#123; //v2 使用反射机制优化过的工厂类 public static void main(String[] args) &#123; CuisineFactory cuisineFactory = new CuisineFactory(); Cuisine cuisine = cuisineFactory.getCuisine(SichuanCuisine.class); if (cuisine == null)&#123; return; &#125; cuisine.cookie(); &#125;&#125; 类图改进之后，不需要修改工厂类的判断逻辑，但是客户端需要创建另一种产品时，还是需要修改客户端代码，有没有一种方式就是在不修改代码的前提下做到随时创建新的产品呢？ 可以通过将所创建的产品配置到外部的配置文件中，来解决这个问题，就像Spring中数据源的一些连接信息外部化到配置文件。 改造点： 在之前版本的基础上新建一个工具类，用于读取配置文件，或得需要创建的产品的配置，这里以properties文件为例，也可以以xml文件为例key-value，value可以是多个，以逗号隔开。这样替换或者新增创建的产品根本不需要改动任何代码，就改下配置文件即可。 jdk源码使用简单工厂案例分析1.Calendar类getInstance方法。12345678910111213141516171819202122232425262728293031323334353637383940414243// getInstancepublic static Calendar getInstance(Locale aLocale)&#123; return createCalendar(TimeZone.getDefault(), aLocale);&#125;private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; // 主要看这里创建的方式，与客户端调通过传入 类型 用工厂方法时，思想一致(V1) if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;); if (caltype != null) &#123; switch (caltype) &#123; case &quot;buddhist&quot;: cal = new BuddhistCalendar(zone, aLocale); break; case &quot;japanese&quot;: cal = new JapaneseImperialCalendar(zone, aLocale); break; case &quot;gregory&quot;: cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; 2.DriverManager类getConnection()方法分析(1) Class.formName(“com.mysql.jdbc.Driver”);// 将 MySQL 的驱动加载进来，(2) 通过 DriverManager#getConnection() 方法获取 Connection。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application&apos;s * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); &#125; println(&quot;DriverManager.getConnection(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(&quot; trying &quot; + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(&quot;getConnection failed: &quot; + reason); throw reason; &#125; println(&quot;getConnection: no suitable driver found for &quot;+ url); throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); &#125; 问题:为什么执行完 Class.formName(“com.mysql.jdbc.Driver”); 就可以获取其对应数据库驱动的连接呢，是什么时候注册进去的呢？答:在com.mysql.jdbc.Driver的源码中发现有段静态初始化方法。在初始化的时候调用 DriverManager 的相应方法，最终将其注入DriverManager的private final static CopyOnWriteArrayList registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();进去。这个就是类似v2通过反射的思想一致。1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException; public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; // 注册对应的 Driver DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125;&#125; 工厂方法类型: 创建型定义：定义一个创建对象接口，但是让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。 适用场景1.创建对象需要大量重复的代码，可以考虑工厂方法是不是适用在这里。2.客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，只需要知道所对应的工厂，具体产品对象由对应工厂创建。3.一个类通过其子类来指定创建哪个对象。优点：1.用户只需要关心所需产品对应的工厂，无需关心创建细节2.加入新产品符合开闭原则，提高可扩展性。tip：缺点：1.类的个数容易过多，增加复杂度（增加新的类的时候，就需要同时添加该类对应的工厂类）2.增加了系统的抽象性和理解难度 tips:1.依赖倒置原则,定义：高级模块不应当依赖于低级模块。它们都应当依赖于抽象。抽象不应当依赖于实现，实现应当依赖于抽象。2.开闭原则,定义：一个软件实体如类、模块、函数应该对扩展开放，对修改关闭。无非就是用抽象构建框架，用实现扩展细节。","categories":[],"tags":[]},{"title":"简单工厂","slug":"工厂模式","date":"2020-01-24T15:01:53.000Z","updated":"2020-01-26T14:51:05.752Z","comments":true,"path":"2020/01/24/工厂模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/24/工厂模式/","excerpt":"","text":"简单工厂定义：由一个工厂对象决定创建出哪一种产品类的实例。白话: 在家里，做菜得买洗炒菜等繁琐的步骤,现在都嫌做菜麻烦。但是我们还是想吃五花八门的菜怎么办，打开饿了么app对不同的菜品下单就好,不需要关心他是怎么做出来的，能吃到自己点的餐就好。类型：创建型，但不属于 GOF23 种设计模式。 适用场景1.工厂类负责创建的对象比较少2.客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心优点：1.只需要传入一个正确的参数，就可以获取你所需要的对象而无序知道其创建细节2.将对象的创建和使用分离缺点：1.工厂类的职责相对过重，增加新产品时需要修改工厂类的判断逻辑，违背开闭原则。当产品过多的时候会产生很多的类，不利于维护。2.无法形成基于继承的等级结构 coding场景：这个餐馆比较牛掰，菜品丰富，有粤菜、川菜, 在Test类(Client端)创建相应的菜品。(其实应该是具体的菜名)代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041/** * @description:菜品 * @author: lzy **/public abstract class Cuisine &#123; public abstract void cookie();&#125;/** * @description:粤菜 * @author: lzy **/public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;/** * @description:川菜 * @author: lzy **/public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public class Test &#123; public static void cookieSichuan() &#123; Cuisine cuisine = new SichuanCuisine(); cuisine.cookie(); &#125; public static void main(String[] args) &#123; cookieSichuan(); &#125;&#125; 从上面代码来看，Test 类里面声明了一个 Cuisine 类型的变量指向其 SichuanCuisine 子类, Test类是非常依赖子类（违反依赖倒置原则）。想要粤菜就得创建Cuisine的子类CantoneseCuisine。我们意愿是让客户端代码不依赖对应的产品类，把创建具体视频类的逻辑对客户端代码隐藏，使应用层的代码不依赖对应的具体实现类。 通过一个工厂类解决此问题1234567891011public class CuisineFactory &#123; //v1 根据传入的类型创建具体的实例 public Cuisine getCuisine(String type) &#123; if (&quot;Sichuan&quot;.equalsIgnoreCase(type)) &#123; return new SichuanCuisine(); &#125; else if (&quot;Cantonese&quot;.equalsIgnoreCase(type)) &#123; return new CantoneseCuisine(); &#125; return null; &#125;&#125; 问题是解决了，但是如果新增菜品，就需要新建类。需要修改CuisineFactory的判断逻辑，违背开闭原则。工厂方法类可以通过反射来优化上诉问题。通过传入的Class类型，创建对应实例，当需要新的实例时，只需要新建一个类即可，不需要修改CuisineFactory类内部创建类的判断逻辑。代码如下：12345678910111213141516171819202122232425262728public class CuisineFactory &#123; //v2 通过反射优化工厂创建对应实例 public Cuisine getCuisine(Class c) &#123; Cuisine cuisine = null; try &#123; cuisine = (Cuisine) Class.forName(c.getName()).newInstance(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return cuisine; &#125;&#125;public class Test &#123; //v2 使用反射机制优化过的工厂类 public static void main(String[] args) &#123; CuisineFactory cuisineFactory = new CuisineFactory(); Cuisine cuisine = cuisineFactory.getCuisine(SichuanCuisine.class); if (cuisine == null)&#123; return; &#125; cuisine.cookie(); &#125;&#125; 类图改进之后，不需要修改工厂类的判断逻辑，但是客户端需要创建另一种产品时，还是需要修改客户端代码，有没有一种方式就是在不修改代码的前提下做到随时创建新的产品呢？ 可以通过将所创建的产品配置到外部的配置文件中，来解决这个问题，就像Spring中数据源的一些连接信息外部化到配置文件。 改造点： 在之前版本的基础上新建一个工具类，用于读取配置文件，或得需要创建的产品的配置，这里以properties文件为例，也可以以xml文件为例key-value，value可以是多个，以逗号隔开。这样替换或者新增创建的产品根本不需要改动任何代码，就改下配置文件即可。 jdk源码使用简单工厂案例分析1.Calendar类getInstance方法。12345678910111213141516171819202122232425262728293031323334353637383940414243// getInstancepublic static Calendar getInstance(Locale aLocale)&#123; return createCalendar(TimeZone.getDefault(), aLocale);&#125;private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; // 主要看这里创建的方式，与客户端调通过传入 类型 用工厂方法时，思想一致(V1) if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;); if (caltype != null) &#123; switch (caltype) &#123; case &quot;buddhist&quot;: cal = new BuddhistCalendar(zone, aLocale); break; case &quot;japanese&quot;: cal = new JapaneseImperialCalendar(zone, aLocale); break; case &quot;gregory&quot;: cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; 2.DriverManager类getConnection()方法分析(1) Class.formName(“com.mysql.jdbc.Driver”);// 将 MySQL 的驱动加载进来，(2) 通过 DriverManager#getConnection() 方法获取 Connection。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application&apos;s * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); &#125; println(&quot;DriverManager.getConnection(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(&quot; trying &quot; + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(&quot;getConnection failed: &quot; + reason); throw reason; &#125; println(&quot;getConnection: no suitable driver found for &quot;+ url); throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); &#125; 问题:为什么执行完 Class.formName(“com.mysql.jdbc.Driver”); 就可以获取其对应数据库驱动的连接呢，是什么时候注册进去的呢？答:在com.mysql.jdbc.Driver的源码中发现有段静态初始化方法。在初始化的时候调用 DriverManager 的相应方法，最终将其注入DriverManager的private final static CopyOnWriteArrayList registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();进去。这个就是类似v2通过反射的思想一致。1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException; public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; // 注册对应的 Driver DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125;&#125; 工厂方法类型: 创建型定义：定义一个创建对象接口，但是让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。 适用场景1.创建对象需要大量重复的代码，可以考虑工厂方法是不是适用在这里。2.客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，只需要知道所对应的工厂，具体产品对象由对应工厂创建。3.一个类通过其子类来指定创建哪个对象。优点：1.用户只需要关心所需产品对应的工厂，无需关心创建细节2.加入新产品符合开闭原则，提高可扩展性。tip：缺点：1.类的个数容易过多，增加复杂度（增加新的类的时候，就需要同时添加该类对应的工厂类）2.增加了系统的抽象性和理解难度 tips:1.依赖倒置原则,定义：高级模块不应当依赖于低级模块。它们都应当依赖于抽象。抽象不应当依赖于实现，实现应当依赖于抽象。2.开闭原则,定义：一个软件实体如类、模块、函数应该对扩展开放，对修改关闭。无非就是用抽象构建框架，用实现扩展细节。","categories":[],"tags":[]},{"title":"Mybatis学习","slug":"Mybatis学习","date":"2017-08-21T11:12:16.000Z","updated":"2017-09-09T00:55:10.538Z","comments":true,"path":"2017/08/21/Mybatis学习/","link":"","permalink":"https://lukeyli.github.io/2017/08/21/Mybatis学习/","excerpt":"","text":"在学习Mybatis的过程中， 写程序练手，遇到的最烦的问题是org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)，这还是我只调用increase方法向数据库增加一条信息。打印了sqlSession，可以打印出信息。 初步猜测，是mybatis-config.xml和BookMapper.xml中，猜测文件路径映射错误。检查验证发现没错，很是无奈。org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): org.lzy.mappers.BookMapper.increase。 再次检查Mapper XML文件中SQL映射语句配置，检查，书写无误。（即使只调用一个increase，但是其他SQL映射配置错误，也是会报错。） 之后查看Web Depolyment Assembly，整理文件结构，（在eclipse中新建web项目，再转成maven项目，目录结构有点乱）。推测可能是没有编译到的问题。 清理，运行编译，发现property name=”driver与jdbc.properties中名字jdbc.driverName对应错误。 总结：基本解决思路：在看错误异常提示，找到对应Mapper.XML中寻找错误，主要注意namespace命名，其次sql映射。实在不行，就先锁定区域注释其他语句，准确确定出错代码块，再分析。","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://lukeyli.github.io/categories/Mybatis/"}],"tags":[{"name":"异常","slug":"异常","permalink":"https://lukeyli.github.io/tags/异常/"}]},{"title":"使用git完成基本的版本控制","slug":"使用git完成基本版本的控制","date":"2017-08-17T11:12:16.000Z","updated":"2017-10-17T00:49:59.487Z","comments":true,"path":"2017/08/17/使用git完成基本版本的控制/","link":"","permalink":"https://lukeyli.github.io/2017/08/17/使用git完成基本版本的控制/","excerpt":"","text":"Git为目前世界上先进的分布式版本控制系统。学习git是为了维护代码的版本，希望网络上有一份永久的存储，这样我们可以将代代码退回到历史版本，和别人协作。 配置用户信息git第一件事情设置自己的用户名与邮件地址。Git的提交会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name “zhangsan”git config --global user.email 邮箱 如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 文本编辑器配置默认文本编辑器，当Git需要你输入信息时会调用它，如果未配置，git会使用操作系统默认的文本编辑器，通常是Vim。如果想使用不同的编辑器，如Emacs 1git config --global core.editor emacs 检查配置信息git config –list 命令来列出所有Git当时能找到的配置。git config:检查git的莫一项配置。 获取Git仓库说明有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。 123456//在当前目录新建一个Git代码库$ git init//新建一个目录，将其初始化为Git代码库$ git init [project-name]// 下载一个项目和它的整个代码历史$ git clone [url] 一般来说，我们会用远程仓库来对代码进行备份，同时便于多人协作。可以到github,oschina或者码市上去注册一个帐号并建立一个远程仓库。 个人解读：远程库是本地库的镜像，本地库是远程库的镜像。 新增（修改）一些文件并跟踪跟踪文件 版本控制的最大作用就是记录文件的历史状态，以便随时可以回退到历史版本。如果没有版本控制，虽然编辑器都有ctrl+z功能，但是次数有限，且编辑器重启后，这些暂时记录就丢失了。把文件纳入版本控制之下。git中这个动作叫做跟踪文件. git add开始跟踪一个文件1234# 跟踪一个具体的文件git add &lt;filepath&gt;# 跟踪所有文件git add . 工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件（废话）。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态. 忽略某些文件我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式 1234567891011*.class # 忽略clsss文件# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar #忽略jar包*.war*.ear# eclipse files #.project.classpath.settings/ GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 https://github.com/github/gitignore 找到它. 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令.status命令不仅列出了文件状态，还对下一步应该使用的命令给出了提示. 提交git commit git commit -m “第一次提交” 写注释 git 状态Git 有三种状态，你的文件可能处于其中之一：已修改（modified）、已暂存（staged）和已提交（committed）。 已修改表示修改了文件，但还没跟踪，如新增的文件和刚修改过的文件。 已暂存表示对一个已修改文件的当前版本做了标记（git add）。 已提交表示数据已经安全地保存在本地数据库中(git commit)。 Git 项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。 工作目录是放在磁盘上供你使用或修改的文件及目录总和。 暂存区域是一个文件，缓存文件快照，有时候也被称作“索引”，不过一般说法还是叫暂存区域。 Git仓库是 Git 用来保存项目的元数据和文件快照的地方，记录了所有历史提交。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件（git add），将文件的快照放入暂存区域。 提交更新(git commit)，找到暂存区域的文件，将快照永久性存储到 Git 仓库。 PS:文件快照必须先经过暂存区，才能到仓库区 git add . git commit -m &quot;第一次提交&quot; 查看提交历史 git log 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。 一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交 如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项. 另外一个常用的选项是 –pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。 移除文件git rm 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 同步远程仓库git push 推送是在远程仓库建立本地仓库的副本，便于别人拉取。如果本地库和远程库一样，会得到Everything up-to-date提示. git pull 用远程仓库更新本地仓库以获得协作者推送的最新的变化.如果远端没有更新，会得到Already up-to-date.提示。","categories":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://lukeyli.github.io/tags/版本控制/"}]},{"title":"Git分支上的工作","slug":"git分支工作","date":"2017-08-17T11:12:16.000Z","updated":"2017-10-17T00:45:32.411Z","comments":true,"path":"2017/08/17/git分支工作/","link":"","permalink":"https://lukeyli.github.io/2017/08/17/git分支工作/","excerpt":"","text":"我们一定在某个分支上工作——master分支，这是git特性决定的。关于这一点，我们可以在gitdemo目录下执行git branch命令来查看，会得到这样的结果： * master 这个命令列出现存本地分支，并以星号（*）高亮当前所在的分支。 git branch -r列出远程分支 git branch -a列出远程分支和本地分支 我们需要在分支上工作几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 通常，master分支作为稳定分支，和线上发布版同步，不适合频繁更改。我们会建立多个开发分支，在开发分支上开发、测试，直到认为新功能或旧功能改造完全完成，再往主分支上合并。整个过程就像一条河流，有多个支流，每个支流都各自向前推进，某些地方他么又并入主干，然后在下面的某个地方有分叉开来，但最终汇入大海。 创建一个开发分支git branch testing // 新建分支 执行这个命令仍在 master 分支上。 因为 git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。 切换分支12345$ git checkout testing # 切换分支$ git branch # 查看分支 * testing master$ ll #查看目录结构 查看目录结构我们发现和切换前一模一样，这是因为新建分支并不是建立一个完全无关的空目录，事实上只是在此处开叉了 git checkout -，快速切换回上个分支。练习执行两次又会回到当前分支。 git checkout -b testing可新建并立即切换分支。 分支的机制git的分支，本质上仅仅是指向提交对象的可变指针。 创建分支，git只是为你创建了一个可以移动的新的指针，指针的名字就是分支的名字，你可以这样认为分支就是指针。创建一个testing分支,这会在当前所在的提交对象上创建一个指针（名字叫testing）。 它有一个名为HEAD的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支。 在新分支上工作并提交我们已经成功切换到testing分支，现在我们可以在testing分支上做一些自己的开发任务，而不用担心影响主分支。每个分支都可以独立地向前推进，如下： HEAD和分支随着提交操作自动向前移动 不同分支间不断地来回切换和工作，在时机成熟时将它们合并起来。 分支合并现在我们在主分支，我们认为testing上的改变很重要，现在希望master上拥有这些变化，这么做 1234567$ git branch # 确认当前分支$ git merge testing # 将testing的修改合并到当前master分支---Merge made by the &apos;recursive&apos; strategy. lesson2/test.rb | 1 + 1 file changed, 1 insertion(+) create mode 100644 lesson2/test.rb 合并会产生新的提交，因此，git弹出文本编辑器要求你记录下这次合并的日志。 删除分支$ git branch -d testing # 删除分支 解决分支合并冲突在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没法干净的合并它们。 12345678git checkout -b dev #新建并切换分支 vi test1.rb #编辑test1.rb，在第二行输入&quot;dev中新增一行&quot; git add . git commit -m &quot;dev change test1&quot; git checkout master vi test1.rb #编辑test1.rb，在第二行输入&quot;master新增一行&quot; git add . git commit -m &quot;master change test1&quot; 现在来合并 git merge dev --- Auto-merging lesson2/test1.rb CONFLICT (content): Merge conflict in lesson2/test1.rb Automatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。明显，lesson2/test1.rb 是有冲突的文件，自动合并失败，需要我们手工解决冲突然后再提交 合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：复制 testsomething &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD master新增一行 ======= dev中新增一行 &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev =======将内容分为两部分，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和分割线中间的部分表示HEAD所指的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支），而分割线和&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev中间的部分是dev分支的版本。为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决，然后提交","categories":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/categories/git/"}],"tags":[{"name":"分支","slug":"分支","permalink":"https://lukeyli.github.io/tags/分支/"}]},{"title":"Json详解","slug":"json详解","date":"2017-08-06T12:10:11.000Z","updated":"2017-09-09T02:56:01.595Z","comments":true,"path":"2017/08/06/json详解/","link":"","permalink":"https://lukeyli.github.io/2017/08/06/json详解/","excerpt":"","text":"本篇本人学习理解JSON的学习记录用，共同进步，欢迎指点。 JSON概念 JSON(JavaScript Object Notation)，即JavaScript对象表示法，它是用于轻量级数据交互，完全独立于语言的 文本格式，取代XML格式的繁琐标记。JSON易于程序员阅读和编写，同时也易于机器解析生成。 JSON的两种结构 JSON有两种结构：1、对象。2、数组1。对象：对象在js中表示为{}里面的内容，key/value 构成，value 的值可以是true、false、null、对象或数组。数据结构如下： 12345&#123; key1:value1,／／例如 &quot;name&quot;:&quot;张三&quot; key2:value2,／／“age”：22 ...&#125; 2.数组：数组表示一系列有序的值。数据结构：12345678910[ &#123; key1:value1, key2:value2 &#125;, &#123; key3:value3, key4:value4 &#125;] JSON字符串：var str =‘{ “name”: “李四”, “sex”: “man” }’；JSON对象：var jsobj ={ “name”: “李四”, “sex”: “man” }； JSON字符串和对象的转换一、JSON字符串转换为JSON对象。注意区分字符串和JSON字符串的区别。字符串：使用“”双引号或’’单引号包括的字符。json字符串：符合json格式要求的js字符串。var obj = JSON.parse(str);JSON.parse(). 现在大多数浏览器都支持这个方法，是推荐使用的方法。 二、JSON对象转JSON字符串var str2 = JSON.stringify（jsobj）；默认情况下，JSON.stringify()输出的JSON字符串不包括任何空格字符或缩进。 在JS中使用JSONJSON的读写有两种方式：一、利用”.”操作符二、“[key]”的方式。 123456789101112131415161718192021222324var obj = &#123; 1: &quot;value1&quot;, &quot;2&quot;: &quot;value2&quot;， person: [ //数组结构JSON对象，可以嵌套使用 &#123; id: 1, name: &quot;张三&quot; &#125;, &#123; id: 2, name: &quot;李四&quot; &#125; ], object: &#123; //对象结构JSON对象 id: 1, msg: &quot;对象里的对象&quot; &#125; &#125;; 1.从JSON中读数据 function readJSON（）&#123; alert(obj.1); //会报语法错误，可以用alert(obj[&quot;1&quot;]);说明数字最好不要做关键字 alert(obj.person[0].name); //或者alert(obj.person[0][&quot;name&quot;]) alert(obj.object.msg); //或者alert(obj.object[&quot;msg&quot;]) &#125; 2.向JSON中写数据 function write（）{ //往JSON对象中增加了一条记录 obj.sex= “男” //或者obj[“sex”]=”男”}3.修改JSON中的cout的值function Update() { obj.count = 10; //或obj[“count”]=10 } 4.删除JSON中数据 delete obj.count; 处理客户端提交的JSON数据客户端提交过来的数据一般是JSON字符串，我们一般处理方式为将JSON字符串转换为JSON对象，可以利com.alibaba.fastjson快速序列化转换。","categories":[{"name":"Json详解","slug":"Json详解","permalink":"https://lukeyli.github.io/categories/Json详解/"}],"tags":[{"name":"Json详解","slug":"Json详解","permalink":"https://lukeyli.github.io/tags/Json详解/"}]},{"title":"JAVAEE之jQuery","slug":"jQuery","date":"2017-08-05T11:13:44.000Z","updated":"2017-10-17T00:35:37.374Z","comments":true,"path":"2017/08/05/jQuery/","link":"","permalink":"https://lukeyli.github.io/2017/08/05/jQuery/","excerpt":"","text":"jQuery的编程模式：1、选择对象 2、do something 4、jQuery注册事件[重点]（1）常用事件与原生JS中的事件是一样的，但注册方式不一样；（2）jQuery事件注册方式： jQuery对象.事件（fn）; ----- 理解 this 关键字 jQuery对象.on(事件，fn) ----- 注册任意事件 5.重点掌握datagrid控件 1、DataGrid所展示的数据有格式 — 如果不需要分页,只需要传一个集合对象就可以了; — 如果需要分页，数据格式必须 {“total”:28,”rows”:[]}导入easyui必要的文件1、下载 easyui 包; （demo|locale(本地化)|themes(皮肤)|easyloader.js|jquery.easyui.min.js|jquery.min.js）2、将 easyui 放到工程中（保留必要的项）3、页面中需要导入的 easyui 文件 – jquery – jquery.easyui.min.js – locale文件夹下的：easyui-lang-zh_CN.js – css: themes/default /easyui.css themes/icon.css","categories":[{"name":"前端","slug":"前端","permalink":"https://lukeyli.github.io/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://lukeyli.github.io/tags/jQuery/"}]},{"title":"Servlet中URL请求参数获取","slug":"Servlet中URL请求参数获取","date":"2017-07-29T12:30:09.000Z","updated":"2017-10-17T00:40:13.077Z","comments":true,"path":"2017/07/29/Servlet中URL请求参数获取/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/Servlet中URL请求参数获取/","excerpt":"","text":"本篇介绍servle请求参数获取,整理记录自己的学习笔记。 1234567891011121314151617181920212223242526272829303132//获取单一参数,request.getParameter()返回为一个String类型System.out.println(request.getParameter(&quot;name&quot;)+request.getParameter(&quot;password&quot;)); //request.getParameterNames()返回一个枚举类型 Enumeration&lt;String&gt; paramName = request.getParameterNames(); while (paramName.hasMoreElements()) &#123; String string = (String) paramName.nextElement(); System.out.println(string+&quot;:&quot;+request.getParameter(string)); &#125; //request.getParameterMap()返回一个Map&lt;String,String[]&gt; Map&lt;String,String[]&gt; paramMap =request.getParameterMap();f or (String key : paramMap.keySet()) &#123; System.out.println(key+&quot;:&quot;+Arrays.toString(paramMap.get(key))); &#125;//获取多个同名参数值，多用于多选项获取。System.out.println(Arrays.toString(request.getParameterValues(&quot;name&quot;)));URL访问只能触发get请求，参数随URL携带post请求可以通过F orm的method选项来设定。post 的请求：参数不随URL携带。这边也记录下请求转发和重定向//请求转发,url不变。等于一次请求，服务器行为/ request.getRequestDispatcher(&quot;login.html&quot;).forward(request, response);//重定向-&gt;URL变化，等于发起了两次，客户端行为 response.sendRedirect(&quot;login.html&quot;);","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/tags/Servlet/"},{"name":"request","slug":"request","permalink":"https://lukeyli.github.io/tags/request/"},{"name":"reponse","slug":"reponse","permalink":"https://lukeyli.github.io/tags/reponse/"}]},{"title":"Servlet会话跟踪技术","slug":"Servlet会话跟踪技术","date":"2017-07-29T12:10:11.000Z","updated":"2017-09-09T02:45:46.927Z","comments":true,"path":"2017/07/29/Servlet会话跟踪技术/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/Servlet会话跟踪技术/","excerpt":"","text":"前面引用一些大纵、通俗易懂的描述。笔记贴，有错还请提出，互相进步，谢谢。 一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术Cookie 、Session Cookie：是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 Session：是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于 session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它 web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 四、Cookie类的主要方法Cookie(String name, String value)描述：实例化Cookie对象，传入cooke名称public String getName() 描述：取得Cookie的名字public String getValue() 描述：取得Cookie的值public void setValue(String newValue) 描述：设置Cookie的值public void setMaxAge(int expiry)描述：设置Cookie的最大保存时间public void setPath(String uri) 描述：设置cookie的有效路径public void setDomain(String pattern)描述： 设置cookie的有效域详细细节阅读java中javax.servlet.http.Cookie 五、Cookie类使用范例 //获取会话信息 Cookie[] cookies = request.getCookies(); if(cookies!=null) { for (Cookie cookie : cookies) { //打印cookie信息 response.getWriter().println(cookie.getName()+”:”+URLDecoder.decode(cookie.getValue())); } //获取session信息 response.getWriter().println(“——session信息————–); response.getWriter().print(request.getSession().getAttribute(“info”)); response.getWriter().println(request.getSession().getId()); //Cookie实现会话跟踪 //写cookie Cookie cookie =new Cookie(“info”, URLEncoder.encode(name)); cookie.setMaxAge(-1);//有效时间0代表删除，-1永久有效，或者以秒为单位的int response.addCookie(cookie); //session会话跟踪 HttpSession session = request.getSession(); session.setAttribute(“info”, name); response.sendRedirect(“view.do”); 六、关于Cookie和Session的问题一、描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。如果客户在浏览器上禁用了cookie，如何做会话跟踪？回答：Cookie是浏览器端技术，将会按照服务端响应的指示（response.addCookie(new Cookie(k,v))）把cookie键值对存储在本地（和网址关联的），且在随后的访问中把cookie添加到请求header中发送给服务器。 Seesion是服务端，web容器当中的一个容器，存储在服务器端的内存里面，用来进行会话跟踪的，同一个客户端的多个请求将映射到同一个session。典型的应用：1、存储用户的登录状态 2、维持购物车这样的可连续操作的内容","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/tags/Servlet/"},{"name":"会话","slug":"会话","permalink":"https://lukeyli.github.io/tags/会话/"},{"name":"Cookie","slug":"Cookie","permalink":"https://lukeyli.github.io/tags/Cookie/"},{"name":"session","slug":"session","permalink":"https://lukeyli.github.io/tags/session/"}]},{"title":"JAVAEE之Servlet进阶","slug":"JAVAEE之Servlet进阶","date":"2017-07-29T11:12:11.000Z","updated":"2017-10-17T00:41:32.736Z","comments":true,"path":"2017/07/29/JAVAEE之Servlet进阶/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/JAVAEE之Servlet进阶/","excerpt":"","text":"Servlet中的九大内置对象ServletConfig|config1、ServletConfig 对象 ： init-param 节点中注册的初使化参数被封装ServletConfig对象中;2、此对象在init方法被调用时由服务器自动创建,并通过参数传递给用户; --- 通过 init 方法拿到 ServletConfig 对象; --- getServletConfig(); 3、ServletConfig API – getInitParameter(paraname) ##ServletContext|application1、ServletContext：整个WEB应用程序，此对象在工程运运行时创建，在服务器关闭时消失； – 1、存放所有Servlet共享的数据 – 2、获取应用程序资源 -- 获取class路径下的资源 -- WEB根路径下的资源 –3、获取ServletContext的初使化数据 2、获取ServletContext; ##HttpServletResponse|response1.输出信息1.通过字节流输出数据：— getOutputStream() —&gt; ServletOutputStream2、输出字符数据： — getWriter() — &gt;PrintWriter; ##HttpServletRequest|request HttpServletRequest：The servlet container creates an HttpServletRequest object and passes it as an argument to the servlet’s service methods (doGet, doPost, etc). – 接收来自用户信息（浏览器）– getHeader(headname);– getHeaderNames()– get…… –getParameter(参数名); —&gt;String–getParameterValues() —&gt;String[] –getRequestDispatcher(url).forward(request,response); –解决中文 ###1、获取网页中的表单数据 request.getParameter(“参数名”);解决中文乱码问题： 1、单个重新编码 String str = new String (data.getBytes(“ISO-8859-1”,”UTF-8”);2、统一设置 request.setCharacterEncoding(“UTF-8”); ###2、获取URL中的参数数据 123request.getParameter(&quot;参数名&quot;);String add = request.getParmeter(&quot;add&quot;); String data = new String(add.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); ##HttpSession|sessionHTTPSession：会话（当请求或者访问一个网页，就标识与当前页面建立了一次会话）；可以在会话的对象存放数据（标识用户身份的数据），此数据在下一个页面中可以取到（session对象中所存放的数据可以跨页面访问） – HttpSession session = request.getSession(); – 1、可以在session对象中存放数据；此数据可以跨页面访问– 2、当访问某一个页面时，服务器会给每一个用户创建一个sessionid,sessionid是唯一的 此sessionid在服务器内存中存一份，同发送给用户;当提交网页到服务器;将用户端的sessionid和服务器存的sessionid做比对，以判断是哪一个用户提交的; –3、存活期：默认为30分钟 ##PrintWriter|JspWriter|out ##this(page) ##pageContext ##exception只能在标识 isErrorPage的页面中使用 #2、Servlet三大域对象 ##ServletContext|application ##HttpSession|session ##HttpServletRequest|request三大域对象都可以存数据，并都可以在页面中取出域对象中的数据 HttpServletRequest域对象中存放数据在同一个Request请求中有效;","categories":[{"name":"前端","slug":"前端","permalink":"https://lukeyli.github.io/categories/前端/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lukeyli.github.io/tags/servlet/"}]},{"title":"JAVAEE之Servlet入门","slug":"JAVAEE之Servlet入门","date":"2017-07-22T12:48:43.000Z","updated":"2017-10-17T00:43:23.331Z","comments":true,"path":"2017/07/22/JAVAEE之Servlet入门/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/JAVAEE之Servlet入门/","excerpt":"","text":"理解Servlet Servlet：A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol. 如何开发一个Servletimplement this interface, you can write a generic servlet that extends javax.servlet.GenericServlet or an HTTP servlet that extends javax.servlet.http.HttpServlet. 开发一个Servlet三种方式： 1、写一个类 ，实现 Servlet 接口 ；2、写一个类 ，继承 javax.servlet.GenericServlet3、写一个类， 继承 javax.servlet.http.HttpServlet. 1、创建Servlet2、发布Servlet123456789&lt;!-- 发布 Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;servlet-class&gt;org.lanqiao.servlet.ServletA&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletA.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3、Servlet生命周期This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from the server 1、初使化Servlet (init);2、接收和响应用户请求（service）3、从服务器中移出 (destroy) 4、url-pattern1234/servletA.do/user/servletA.do/user/**.do","categories":[{"name":"前端","slug":"前端","permalink":"https://lukeyli.github.io/categories/前端/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lukeyli.github.io/tags/servlet/"}]},{"title":"JAVAEE之web基础知识","slug":"web基础知识","date":"2017-07-22T11:40:44.000Z","updated":"2017-10-17T00:52:56.468Z","comments":true,"path":"2017/07/22/web基础知识/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/web基础知识/","excerpt":"","text":"持续更新 理解Web1、WEB应用程序的结构（采用JSP技术开发的WEB应用程序） —META-INF —WEB-INF –class –lib –web.xml —JSP页面|基它资源2、在Eclispe中创建一个Web应用程序(网站)3、理解WEB应用程序的工作模式：请求、响应模式 Client(brows) &lt;------&gt; Web服务器 ---(解析：生成一个浏览器能识别的数据（html|css| js -- 静态数据）) web服务器：tomcat1、了解tomcat服务器目录结构 2、在Eclispe中配制Tomcat服务器3、将Eclispe中创建的Web应用程序发布到Tomcat服务器中; – webapps路径下;4、在Eclispe中启动和关闭Tomcat服务器 --- 调式模式 ---当需要重新启动Tomcat服务器时，建议先关闭Tomcat服务器，再启动 Eclispe中相关配制1、配制JSP文件配制的编码2、配制工程编码3、配制workspace编码1、eclipse必须支持JAVAEE2、Servers面板3、建议将网站部署到Tomcat服务器;问题1、eclipse必须支持JAVAEE2、Servers面板3、建议将网站部署到Tomcat服务器;","categories":[{"name":"前端","slug":"前端","permalink":"https://lukeyli.github.io/categories/前端/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lukeyli.github.io/tags/web/"},{"name":"JavaEE","slug":"JavaEE","permalink":"https://lukeyli.github.io/tags/JavaEE/"}]},{"title":"Java之注解","slug":"注解","date":"2017-07-22T11:12:16.000Z","updated":"2017-09-09T02:33:43.729Z","comments":true,"path":"2017/07/22/注解/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/注解/","excerpt":"","text":"持续更新","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://lukeyli.github.io/tags/注解/"},{"name":"测试","slug":"测试","permalink":"https://lukeyli.github.io/tags/测试/"}]},{"title":"Java之反射机制","slug":"反射机制","date":"2017-07-16T12:22:11.000Z","updated":"2017-09-09T02:42:52.088Z","comments":true,"path":"2017/07/16/反射机制/","link":"","permalink":"https://lukeyli.github.io/2017/07/16/反射机制/","excerpt":"","text":"持续更新…","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"反射机制","slug":"反射机制","permalink":"https://lukeyli.github.io/tags/反射机制/"}]},{"title":"Java之IO&XML","slug":"IO和XML","date":"2017-07-16T10:40:11.000Z","updated":"2017-09-09T02:43:20.047Z","comments":true,"path":"2017/07/16/IO和XML/","link":"","permalink":"https://lukeyli.github.io/2017/07/16/IO和XML/","excerpt":"","text":"持续更新中…","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://lukeyli.github.io/tags/IO/"},{"name":"XML","slug":"XML","permalink":"https://lukeyli.github.io/tags/XML/"}]},{"title":"Java之多线程","slug":"多线程","date":"2017-07-15T11:03:44.000Z","updated":"2017-09-09T02:43:35.633Z","comments":true,"path":"2017/07/15/多线程/","link":"","permalink":"https://lukeyli.github.io/2017/07/15/多线程/","excerpt":"","text":"持续更新","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lukeyli.github.io/tags/多线程/"}]},{"title":"Java之异常处理","slug":"Java之异常处理","date":"2017-07-08T11:15:16.000Z","updated":"2017-09-09T02:42:09.136Z","comments":true,"path":"2017/07/08/Java之异常处理/","link":"","permalink":"https://lukeyli.github.io/2017/07/08/Java之异常处理/","excerpt":"","text":"本人学习笔记记录专用，有不足之处望之处，内容持续更新。后续更新中…","categories":[{"name":"Java","slug":"Java","permalink":"https://lukeyli.github.io/categories/Java/"}],"tags":[{"name":"exception","slug":"exception","permalink":"https://lukeyli.github.io/tags/exception/"},{"name":"异常","slug":"异常","permalink":"https://lukeyli.github.io/tags/异常/"}]},{"title":"Java之数据结构","slug":"Java数据结构","date":"2017-07-01T12:40:01.000Z","updated":"2017-09-09T02:46:56.435Z","comments":true,"path":"2017/07/01/Java数据结构/","link":"","permalink":"https://lukeyli.github.io/2017/07/01/Java数据结构/","excerpt":"","text":"学习笔记专用，持续更新。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lukeyli.github.io/tags/数据结构/"}]},{"title":"Java之网络编程","slug":"java网络编程","date":"2017-07-01T12:12:11.000Z","updated":"2017-09-09T02:46:57.370Z","comments":true,"path":"2017/07/01/java网络编程/","link":"","permalink":"https://lukeyli.github.io/2017/07/01/java网络编程/","excerpt":"","text":"持续更新中...","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://lukeyli.github.io/tags/网络编程/"}]},{"title":"Java集合和泛型","slug":"java集合和泛型","date":"2017-06-25T11:04:14.000Z","updated":"2017-09-09T02:35:37.312Z","comments":true,"path":"2017/06/25/java集合和泛型/","link":"","permalink":"https://lukeyli.github.io/2017/06/25/java集合和泛型/","excerpt":"","text":"持续更新中...","categories":[{"name":"Java","slug":"Java","permalink":"https://lukeyli.github.io/categories/Java/"}],"tags":[{"name":"集合和泛型","slug":"集合和泛型","permalink":"https://lukeyli.github.io/tags/集合和泛型/"}]},{"title":"Java基础之面向对象","slug":"Java基础之面向对象 ","date":"2017-06-24T11:30:11.000Z","updated":"2017-09-09T02:35:12.711Z","comments":true,"path":"2017/06/24/Java基础之面向对象 /","link":"","permalink":"https://lukeyli.github.io/2017/06/24/Java基础之面向对象 /","excerpt":"","text":"本篇整理个人以前笔记，有不足之处还望指出。 Object类 类和对象 包和访问控制 抽象类和接口接口和抽象类的相同特征：两者都不能实例化。它们都位于继承树的顶端，用于被其他类实现和继承。两者都可包含抽象方法，留待子类去实现。 接口和抽象类的差别：接口类似于整个系统的总纲，它制定了系统各模块应遵循的标准。因此一个系统中的接口不应该经常改变。抽象类作为系统中多个子类的父类，体现的是一种模板式设计。其相当于系统实现过程的中间产品，已有部分实现，但须进一步完善。接口里只能包含抽象方法，而抽象类可以同时包含抽象方法和普通方法。接口里不能定义静态方法，抽象类里可以。接口里只能定义静态常量 Field，不能定义普通 Field；抽象类里二者均可定义。接口里不包含构造器，抽象类里可以包含（供其子类调用进行初始化操作）。接口里不能包含初始化块，抽象类可以。一个类最多只能有一个直接父类，但可以直接实现多个接口。 继承和多态","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lukeyli.github.io/tags/Java/"},{"name":"类和对象","slug":"类和对象","permalink":"https://lukeyli.github.io/tags/类和对象/"},{"name":"Object","slug":"Object","permalink":"https://lukeyli.github.io/tags/Object/"},{"name":"访问控制权限","slug":"访问控制权限","permalink":"https://lukeyli.github.io/tags/访问控制权限/"},{"name":"继承和多态","slug":"继承和多态","permalink":"https://lukeyli.github.io/tags/继承和多态/"}]},{"title":"Java基础之程序设计基础","slug":"Java基础之程序设计基础 ","date":"2017-06-15T11:11:16.000Z","updated":"2017-09-09T02:34:51.921Z","comments":true,"path":"2017/06/15/Java基础之程序设计基础 /","link":"","permalink":"https://lukeyli.github.io/2017/06/15/Java基础之程序设计基础 /","excerpt":"","text":"整理自己以前笔记专用，有不足之处还望指出 JAVA数据类型个人整理思维导图，所用工具XMind 流程控制 方法和数组 字符串","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lukeyli.github.io/tags/Java/"},{"name":"流程控制","slug":"流程控制","permalink":"https://lukeyli.github.io/tags/流程控制/"},{"name":"数据类型","slug":"数据类型","permalink":"https://lukeyli.github.io/tags/数据类型/"},{"name":"方法和数组","slug":"方法和数组","permalink":"https://lukeyli.github.io/tags/方法和数组/"},{"name":"字符串","slug":"字符串","permalink":"https://lukeyli.github.io/tags/字符串/"}]},{"title":"Java基础之初识Java","slug":"java基础","date":"2017-06-04T11:12:16.000Z","updated":"2017-09-09T02:34:30.282Z","comments":true,"path":"2017/06/04/java基础/","link":"","permalink":"https://lukeyli.github.io/2017/06/04/java基础/","excerpt":"","text":"本篇本人整理以前笔记记录用的，有不足之处还望指出。用Xmind整理的思维导图。初识Java的话 谈JavaJava发展历程的话，很长，有兴趣了解Java发展史，可以自行百度一下，很多很详细的内容，毕竟这家伙比我年龄还大。比较有趣的是一家伙原本叫Oak，当时James Gosling办公室的窗外，正好有偶一棵橡树（Oak），但是有一家公司已经用了这个名字，工程师后来一边喝咖啡一边讨论新名字，看看手上的咖啡，顺手就取了JAVA这个名字。 Java的特点 Java是门优秀的语言，当然他的特点也就很多了，比如面向对象，平台无关性（仅语言）、分布性（网络）、移植性、解释性、高性能、多线程、动态安全、健壮性等。主要熟知Java的封装继承多态，还有他的平台无关性（跨平台）。 封装：就是把同一类事物的共性（属性和方法）归为一个类中，方便使用。 继承：子承父业，一个类继承另一个类，实现代码的复用。 多态：多态的概念是以封装和继承为基础的。子类以父类的身份出现，但做事情时还是以自己的方法实现。子类以父类的身份出现需要向上转型(upcast)，其中向上转型是由JVM自动实现的，是安全的，但向下转型(downcast)是不安全的，需要强制转换。子类以父类的身份出现时自己特有的属性和方法将不能使用。（多态为Java初学者一容易踩坑的地方） 跨平台：不是java语言跨平台，是由于不同操作系统有不同的JVM虚拟机，java程序员不用考虑所写的程序在哪里运行，写好的程序.java由编译器编译成.class文件，放心的交给虚拟机，变成相对应的平台的机器语言。（字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言） gc回收机制（Garbage Collections） 扩展：G1:对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lukeyli.github.io/tags/Java/"},{"name":"基础","slug":"基础","permalink":"https://lukeyli.github.io/tags/基础/"},{"name":"历史","slug":"历史","permalink":"https://lukeyli.github.io/tags/历史/"},{"name":"gc","slug":"gc","permalink":"https://lukeyli.github.io/tags/gc/"}]}]}