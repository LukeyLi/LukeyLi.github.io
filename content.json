{"meta":{"title":"LukeyLi's Blog","subtitle":null,"description":null,"author":"LukeyLi","url":"https://lukeyli.github.io"},"pages":[{"title":"","date":"2020-01-25T12:34:31.798Z","updated":"2020-01-25T12:34:31.798Z","comments":true,"path":"about/index.html","permalink":"https://lukeyli.github.io/about/index.html","excerpt":"","text":"关于我 从事java后端开发, 熟悉使用ssm、springCloud等主流框架。热爱生活、热爱新技术、热爱新事物。 关于工作 城市：福州 关于学习 活到老学到老，正在往终身学习者前进。 关于座右铭 The Harder You Work, The Luckier You Will Be. 关于爱好 热爱运动，喜欢慢跑,听音乐看电影等。"}],"posts":[{"title":"装饰者模式","slug":"装饰者模式","date":"2020-01-28T13:11:42.000Z","updated":"2020-01-28T13:48:15.800Z","comments":true,"path":"2020/01/28/装饰者模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/装饰者模式/","excerpt":"","text":"装饰者模式定义：在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象功能） 类型：结构型 适用场景1.扩展一个类的功能或给一个类添加附加职责2.动态的给一个对象添加功能，这些功能可以再动态的撤销 优点:1.是继承的有力补充，比继承灵活，不改变原有对象的情况下给对象扩展功能。通常可以使用继承来实现功能的扩展，如果需要扩展的功能的和种类繁多，那么将会生成很多子类，这样增加了系统的复杂性，同时使用继承功能扩展必须可预见这些扩展功能，因为这些功能在编译时就确定了是静态的，如果使用装饰者模式，这些功能是由用户来动态的决定加入的方式和时间，装饰者模式提供了一种即插即用的方法，我们可以在运行期间决定何时增加何种功能。装饰者模式也是建立在继承的基础之上。2.通过使用不同装饰类以及这些类的排列组合，可以实现不同效果。比如插花，不同的组合有不同的花语。3.符合开闭原则缺点1.会出现更多的代码，更多的类，增加程序的复杂性2.当动态装饰时，多层装饰会更复杂 相关设计模式:1.装饰者模式和代理模式。装饰者模式关注在一个对象上动态的增加功能，而代理模式控制对对象的访问，代理模式的代理类对他的客户隐藏一个对象的具体信息。通常在使用代理模式的时候，常在一个代理类中创建一个对象的实例。而当使用装饰者模式的时候我们通常会把原始对象作为一个参数传给装饰者的构造器。 2.装饰者模式和适配器模式。两者都可称之为包装模式。装饰者和被装饰者可以实现相同的接口或者装饰者是被装饰者的子类；适配器模式中，适配器和被适配的类具有不同的接口当然也有可能有部分接口是重合的。装饰者模式还可以退化为半装饰者，即一个装饰者除了提供被装饰类接口外，还可以提供其他方法。 Coding通过继承扩展1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Battercake &#123; protected String getDesc() &#123; return &quot;煎饼&quot;; &#125; protected int cost() &#123; return 20; &#125;&#125;public class BattercakeWithEgg extends Battercake &#123; @Override public String getDesc() &#123; return super.getDesc()+&quot; 加一个鸡蛋&quot;; &#125; @Override public int cost() &#123; return super.cost()+1; &#125;&#125;public class BattercakeWithEggSausage extends BattercakeWithEgg &#123; @Override public String getDesc() &#123; return super.getDesc()+ &quot; 加一根香肠&quot;; &#125; @Override public int cost() &#123; return super.cost()+2; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 小A Battercake battercake = new Battercake(); System.out.println(battercake.getDesc()+&quot; 销售价格:&quot;+battercake.cost()); // 小B Battercake battercakeWithEgg = new BattercakeWithEgg(); System.out.println(battercakeWithEgg.getDesc()+&quot; 销售价格:&quot;+battercakeWithEgg.cost()); // 小C Battercake battercakeWithEggSausage = new BattercakeWithEggSausage(); System.out.println(battercakeWithEggSausage.getDesc()+&quot; 销售价格:&quot;+battercakeWithEggSausage.cost()); &#125;&#125; 假设小c又来买煎饼加2个鸡蛋，两个香肠,..其他人等…组合会非常多。那以现有的系统是无法计算这样的煎饼要卖多少钱，如果对这种要扩展，那么类将会很庞大。 通过装饰者模式扩展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Battercake extends ABattercake &#123; @Override protected String getDesc() &#123; return &quot;煎饼&quot;; &#125; @Override protected int cost() &#123; return 20; &#125;&#125;public abstract class ABattercake &#123; protected abstract String getDesc(); protected abstract int cost();&#125;public abstract class AbstractDecorator extends ABattercake &#123; private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) &#123; this.aBattercake = aBattercake; &#125; protected abstract void doSomething(); @Override protected String getDesc() &#123; return this.aBattercake.getDesc(); &#125; @Override protected int cost() &#123; return this.aBattercake.cost(); &#125;&#125;public class EggDecorator extends AbstractDecorator &#123; public EggDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected void doSomething() &#123; &#125; @Override protected String getDesc() &#123; return super.getDesc()+&quot; 加一个鸡蛋&quot;; &#125; @Override protected int cost() &#123; return super.cost()+1; &#125;&#125;public class SausageDecorator extends AbstractDecorator &#123; public SausageDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected void doSomething() &#123; &#125; @Override protected String getDesc() &#123; return super.getDesc()+&quot; 加一根香肠&quot;; &#125; @Override protected int cost() &#123; return super.cost()+2; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; ABattercake aBattercake = new Battercake() ; aBattercake = new EggDecorator(aBattercake); aBattercake = new EggDecorator(aBattercake); aBattercake = new SausageDecorator(aBattercake); System.out.println(aBattercake.getDesc()+&quot; 销售价格:&quot;+aBattercake.cost()); &#125;&#125; 运行结果:煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格:24 源码分析BufferedReader 就是一个经典的装饰者类，而 Reader 就是被装饰的抽象类12345678910111213141516171819202122232425262728public class BufferedReader extends Reader &#123; // 被装饰的 Reader 抽象类 private Reader in; ... /** * Creates a buffering character-input stream that uses an input buffer of * the specified size. * * @param in A Reader * @param sz Input-buffer size * * @exception IllegalArgumentException If &#123;@code sz &lt;= 0&#125; */ public BufferedReader(Reader in, int sz) &#123; super(in); if (sz &lt;= 0) throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); this.in = in; cb = new char[sz]; nextChar = nChars = 0; &#125; ... ｝","categories":[],"tags":[]},{"title":"外观模式","slug":"外观模式","date":"2020-01-28T11:46:53.000Z","updated":"2020-01-28T13:11:04.320Z","comments":true,"path":"2020/01/28/外观模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/外观模式/","excerpt":"","text":"外观模式定义：外观模式又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口，外观模式定义了一个高层接口，让子系统更容易使用。可能应用层实现某个功能的时候需要调用多个服务类的方法，这样应用层就和各个服务类耦合度很高，那么通过提供出来一个接口方法，将实现这个功能的这些类的方法根据业务需求组织到一个类的方法里面，只对应用层提供该类的方法即可实现同样的功能，这样不仅降低了耦合度，而且应用层也不需要了解每个类方法的作用。 类型：结构型 适用场景1.子系统越来越复杂，增加外观模式提供简单的调用接口2.构建多层系统结构，利用外观对象作为每层的入口，简化层间调用 优点：1.简化了调用过程，无需了解深入子系统，防止带来风险。2.减少系统依赖、松散耦合。外观模式松散了客户端于子系统的耦合关系，客户端通过外观模式于子系统交流，让子系统内部的模块更容易扩展和维护。3.更好的划分访问层次。有些方法是供系统外部调用的，有些则是供系统内部调用的，把需要暴露给外部的功能集中到外观类上，这样既方便客户端调用，也隐藏了系统内部的细节。4.符合迪米特法则 缺点：1.增加子系统、扩展子系统行为容易引入风险2.不符合开闭原则 相关设计模式1.外观模式和中介者模式。外观模式关注的是外界和子系统的交互，而中介者模式关注的是子系统内部之间的交互。2.外观模式和单例模式。通常可以把外观模式中的外观对象做成单例模式的结合使用。3.外观模式和抽象工厂模式。外观类可以通过抽象工厂获取子系统的实例，这样子系统内部可以对外观类进行屏蔽。 codig场景: 积分礼物兑换。涉及一个实体积分礼物，三个子系统积分子系统、支付子系统、物流子系统。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @description: 积分礼物 **/public class PointGift &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;/** * @description: 支付子系统 **/public class PointPaymentService &#123; public boolean pay(PointGift pointGift) &#123; //扣减积分 System.out.println(&quot;支付&quot; + pointGift.getName() + &quot;积分成功&quot;); return true; &#125;&#125;/** * @description:积分子系统 **/public class QualityService &#123; public boolean isAvailable(PointGift pointGift) &#123; System.out.println(&quot;检验&quot; + pointGift.getName() + &quot;积分资格通过，库存通过&quot;); return true; &#125;&#125;/** * @description: 物流子系统 **/public class ShippingService &#123; public String shipGift(PointGift pointGift) &#123; //物流系统的对接逻辑 System.out.println(pointGift.getName() + &quot;进入物流系统&quot;); String shippingOrderNo = &quot;666&quot;; return shippingOrderNo; &#125;&#125;public class GiftExchangeService &#123; private QualityService qualityService = new QualityService(); private PointPaymentService pointPaymentService = new PointPaymentService(); private ShippingService shippingService = new ShippingService(); public void giftExchange(PointGift pointGift) &#123; // 如果资格校验通过 if (qualityService.isAvailable(pointGift)) &#123; // 如果支付积分成功 if (pointPaymentService.pay(pointGift))&#123; String shippingOrderNo = shippingService.shipGift(pointGift); System.out.println(&quot;物流系统下单成功, 订单号是：&quot; + shippingOrderNo); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; PointGift pointGift = new PointGift(&quot;iphone&quot;); GiftExchangeService giftExchangeService = new GiftExchangeService(); giftExchangeService.giftExchange(pointGift); &#125;&#125; 上述外观类使用的是实体外观类，非常完美的支持了迪米特法则，但是对于扩展性并不友好，如果实现某个功能需要增加子系统，除了新增子系统之外，对于的外观类也要修改。不符合开闭原则。可以使用抽象外观类优化解决扩张性，根据业务场景决定。外观类不需要经常变化，使用实外观类即可，如果需要经常变化，则需要使用抽象外观类。 源码分析1.Spring的jdbcUtils 中closeConnection，closeResultSet，getResultSetValue方法12345678public abstract class JdbcUtils &#123;... public static void closeConnection(@Nullable Connection con) &#123;...&#125;...&#125; 2.Mybatis 中的 Configuration 实例，也有外观模式。newMetaObject、newParameterHandler、newResultSetHandler都是封装了接口，对外提供服务。123456789101112131415 public MetaObject newMetaObject(Object object) &#123; return MetaObject.forObject(object, this.objectFactory, this.objectWrapperFactory, this.reflectorFactory); &#125;public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql); parameterHandler = (ParameterHandler)this.interceptorChain.pluginAll(parameterHandler); return parameterHandler;&#125;public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) &#123; ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds); ResultSetHandler resultSetHandler = (ResultSetHandler)this.interceptorChain.pluginAll(resultSetHandler); return resultSetHandler;&#125; 3.Tomcat 也用了很多外观模式，像一些带Facade的接口。（RequestFacade 是对 Request进行的封装、ResponseFacade 等） tips迪米特法则：一个对象应该对其他对象保持最少的了解。意义在于降低类之间的耦合。开闭原则：一个软件实体,如类、模块和函数应该对扩展开放,对修改关闭.即一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码来实现变化.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[]},{"title":"建造者模式","slug":"建造者模式","date":"2020-01-28T09:47:26.000Z","updated":"2020-01-28T11:36:29.103Z","comments":true,"path":"2020/01/28/建造者模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/建造者模式/","excerpt":"","text":"设计模式定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需要指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。这个定义通俗的讲就是说建造者模式就是如何一步一步构建一个包含多个组件的对象，相同的构建过程可以创建不同的产品，比较适用于那些流程固定但是顺序不一定固定。个人觉得建造者模式就是根据业务场景针对那些一次性无法创建出最终的对象，比如 StringBuilder ，在创建 String 时，有很多 append方法追加，直到不再调用 append 时，String 对象才算最终创建完成。很多 ORM 框架的查询条件的创建也是运用了建造者模式。 类型：创建型 适用场景1.如果一个对象有非常复杂的内部结构（它有很多属性）2.想把复杂对象的创建和使用分离3.当创造一个对象需要很多步骤时适合使用建造者模式，而当需要一个简单的方法就可以简单的创建整个对象时适合使用工厂相关模式。 优点:1.封装性好，创建和使用分离2.扩展性好、建造类之间独立，一定程度上解耦缺点:1.会产生多余的 Builder 对象2.产品内部发生变化，建造者都要修改，成本比较大 建造者模式和工厂模式的区别：1.注重点不同，建造者模式更注重于方法的调用顺序，而工厂模式注重于创建产品2.创建对象的粒度不同，建造者模式可以创建复杂的产品，由各种复杂的部件组成，工厂模式创建出来的都是一个样子3.关注点不同，工厂模式注重的把这个对象创建出来就行了，而建造者模式不止要创建出这个产品，还要知道这个产品都是由哪些部件组成的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Datapublic class Course &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String CourseQA;&#125;public abstract class CourseBuilder &#123; public abstract void builderCourseName(String courseName); public abstract void builderCoursePPT(String coursePPT); public abstract void builderCourseVideo(String courseVideo); public abstract void builderCourseArticle(String courseArticle); public abstract void builderCourseQA(String courseQA); public abstract Course makeCourse();&#125;/** * 课程的建造者实现类 */public class CourseActualBuilder extends CourseBuilder &#123; private Course course = new Course(); @Override public void builderCourseName(String courseName) &#123; course.setCourseName(courseName); &#125; @Override public void builderCoursePPT(String coursePPT) &#123; course.setCoursePPT(coursePPT); &#125; @Override public void builderCourseVideo(String courseVideo) &#123; course.setCourseVideo(courseVideo); &#125; @Override public void builderCourseArticle(String courseArticle) &#123; course.setCourseArticle(courseArticle); &#125; @Override public void builderCourseQA(String courseQA) &#123; course.setCourseQA(courseQA); &#125; @Override public Course makeCourse() &#123; return course; &#125;&#125;/** * 指挥如何建造者如何创建 Course */public class Teacher &#123; private CourseBuilder courseBuilder; public void setCourseBuilder(CourseBuilder courseBuilder) &#123; this.courseBuilder = courseBuilder; &#125; public Course makeCourse(String courseName, String coursePPT, String courseVideo, String courseArticle, String courseQA) &#123; this.courseBuilder.builderCourseName(courseName); this.courseBuilder.builderCoursePPT(coursePPT); this.courseBuilder.builderCourseVideo(courseVideo); this.courseBuilder.builderCourseArticle(courseArticle); this.courseBuilder.builderCourseQA(courseQA); return this.courseBuilder.makeCourse(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; CourseBuilder courseBuilder = new CourseActualBuilder(); Teacher teacher = new Teacher(); teacher.setCourseBuilder(courseBuilder); Course course = teacher.makeCourse(&quot;设计模式&quot;, &quot;PPT&quot;, &quot;视频&quot;, &quot;手记&quot;, &quot;问答&quot;); System.out.println(course); &#125;&#125; 演进版本可以将建造者类当做被构造类的内部类存在123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Course &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; public Course(CourseBuilder courseBuilder) &#123; this.courseName = courseBuilder.courseName; this.coursePPT = courseBuilder.coursePPT; this.courseVideo = courseBuilder.courseVideo; this.courseArticle = courseBuilder.courseArticle; this.courseQA = courseBuilder.courseQA; &#125; public static class CourseBuilder &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; public CourseBuilder builderCourseName(String courseName) &#123; this.courseName = courseName; return this; &#125; public CourseBuilder buildCoursePPT(String coursePPT) &#123; this.coursePPT = coursePPT; return this; &#125; public CourseBuilder buildCourseVideo(String courseVideo) &#123; this.courseVideo = courseVideo; return this; &#125; public CourseBuilder buildCourseArticle(String courseArticle) &#123; this.courseArticle = courseArticle; return this; &#125; public CourseBuilder buildCourseQA(String courseQA) &#123; this.courseQA = courseQA; return this; &#125; public Course build()&#123; return new Course(this); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Course course = new Course.CourseBuilder().builderCourseName(&quot;设计模式&quot;).buildCoursePPT(&quot;PPT&quot;).buildCourseVideo(&quot;视频&quot;).build(); System.out.println(course); &#125;&#125; 源码分析StringBuilder（StringBuffer） 就是经典的建造者模式吗， append 方法。Activitie 工作流框架里面 Deployment + DeploymentBuilder 也应用了建造者模式。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[]},{"title":"原型模式","slug":"原型模式","date":"2020-01-28T02:59:43.000Z","updated":"2020-01-28T08:50:51.919Z","comments":true,"path":"2020/01/28/原型模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/原型模式/","excerpt":"","text":"原型模式定义：指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。不需要知道任何创建的细节，不调用构造函数（这里说的不调用构造函数是指不通过new的方式创建，查看jdk源码是通过反射机制实现对象的创建） 类型：创建型 适用场景1.类初始化消耗较多资源2.new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）3.构造函数比较复杂4.循环体中创建大量对象 优点：1.原型模式性能比直接 new 一个对象性能高2.简化创建过程 缺点：1.必须实现 Cloneable 接口并且实现配备克隆方法2.对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险3.在对复杂对象进行深拷贝、浅拷贝要运用得当 Coding场景:给一群活动中奖的人发生邮件,需要保存原始的邮件模板,而且中奖的人很多意味着要new很多类,并且给每个属性都赋值,有些内容一致,有些则不同。123456789101112131415161718192021222324252627282930313233343536373839404142434445@Datapublic class Mail &#123; private String name; private String emailAddress; private String content; public Mail()&#123; System.out.println(&quot;Mail Class Contructor&quot;); &#125; @Override public String toString() &#123; return &quot;Mail&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, emailAddress=&apos;&quot; + emailAddress + &apos;\\&apos;&apos; + &quot;, content=&apos;&quot; + content + &apos;\\&apos;&apos; + &apos;&#125;&apos; + super.toString(); &#125;&#125;public class MailUtil &#123; public static void sendMail(Mail mail) &#123; String outputContent = &quot;向&#123;0&#125;同学,发送邮件地址：&#123;1&#125;, 邮件内容：&#123;2&#125;发送邮件成功&quot;; System.out.println(MessageFormat.format(outputContent, mail.getName(), mail.getEmailAddress(), mail.getContent())); &#125; public static void saveOriginMailRecord(Mail mail) &#123; System.out.println(&quot;存储 originMail记录, originMail:&quot; + mail.getContent()); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Mail mail = new Mail(); mail.setContent(&quot;初始化模板&quot;); MailUtil.saveOriginMailRecord(mail); for (int i = 0; i &lt; 1000; i++) &#123; mail.setName(&quot;姓名&quot; + i); mail.setEmailAddress(&quot;姓名&quot; + i + &quot;@163.com&quot;); mail.setContent(&quot;恭喜你，中奖了&quot;); MailUtil.sendMail(mail); &#125; &#125;&#125; 运行结果:Mail Class Contructor存储 originMail记录, originMail:初始化模板向姓名0同学,发送邮件地址：姓名0@163.com, 邮件内容：恭喜你，中奖了发送邮件成功…向姓名999同学,发送邮件地址：姓名999@163.com, 邮件内容：恭喜你，中奖了发送邮件成功 假设saveOriginMailRecord一定要在发送email之后,在for循环内 new 对象将消耗很大。 使用原型模式12345678910111213141516171819202122232425@Datapublic class Mail implements Cloneable &#123; private String name; private String emailAddress; private String content; public Mail()&#123; System.out.println(&quot;Mail Class Contructor&quot;); &#125; @Override public String toString() &#123; return &quot;Mail&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, emailAddress=&apos;&quot; + emailAddress + &apos;\\&apos;&apos; + &quot;, content=&apos;&quot; + content + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; System.out.println(&quot;clone mail object&quot;); return super.clone(); &#125;&#125; 通过抽象类使用原型模式12345678910111213141516171819/** * 通过抽象类实现原型模式 */public abstract class A implements Cloneable&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; /** * 继承 A ，因此也有 clone 属性 */public class B extends A &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; B b = new B(); b.clone(); &#125;&#125; 深克隆在实际使用中，建议对原型类中的引用属性进行深克隆，以避免不必要的坑。根据实际业务考虑使用深克隆还是浅克隆。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-01-27T06:21:29.000Z","updated":"2020-01-28T08:48:39.058Z","comments":true,"path":"2020/01/27/单例模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/27/单例模式/","excerpt":"","text":"单例模式定义：保证一个类仅有一个实例，并提供一个全局访问点。 类型：创建型 适用场景想确保任何情况下都绝对只有一个实例 优点：1.在内存里只有一个实例，减少了内存的开销2.可以对避免对资源的多重占用3.设置全局的访问点，严格控制访问。 缺点：1.没有接口，扩展困难 重点：1.私有构造器，禁止从单例类外部调用构造函数创建对象2.线程安全3.延迟加载，等使用到的时候再创建。懒汉模式4.序列化和反序列化安全5.反射,通过反射可以破坏单例 单例模式和其他设计模式的结合：1.单例模式和工厂模式2.单例模式和享元模式 coding懒汉式线程不安全注重延迟加载，只有使用的时候才会创建。123456789101112131415public class LazySingleton &#123; // 声明该类变量，但是不创建，等到真正使用的时候调用 getInstance 方法创建 private static LazySingleton lazySingleton = null; // 构造函数私有化，避免外部调用 private LazySingleton() &#123; &#125; //v1 线程不安全 public static LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; //在多线程的情况下,可能使用很多对象。 lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 懒汉式安全版本1.直接锁类的静态方法加锁范围大，对程序消耗较大123456789101112131415161718192021222324public class LazySingleton &#123; // 声明该类变量，但是不创建，等到真正使用的时候调用 getInstance 方法创建 private static LazySingleton lazySingleton = null; // 构造函数私有化，避免外部调用 private LazySingleton() &#123; &#125; //v2 加上 synchronized 关键字，使该方法变为同步方法， public synchronized static LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125; //与上面的方法效果一样。// public static LazySingleton getInstance()&#123;// synchronized(LazySingleton.class)&#123;// if (lazySingleton == null) &#123;// lazySingleton = new LazySingleton();// &#125;// &#125;// return lazySingleton;// &#125;&#125; 2.Double-Check 双重检查1234567891011121314public class LazyDoubleCheckSingleton &#123; private static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton()&#123;&#125; private static LazyDoubleCheckSingleton getInstance()&#123; if (lazyDoubleCheckSingleton == null) &#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if(lazyDoubleCheckSingleton == null) &#123; lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazyDoubleCheckSingleton; &#125;&#125; 分析：这边看似逻辑正确，但是这边存在坑，指定重排序问题lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton()的过程：1.分配对象的内存空间。2.初始化对象3.设置lazyDoubleCheckSingleton指向刚分配的内存地址。4.初次访问对象在发生的过程中可能发生重排序, 执行顺序可能发生2和3互换位置，即执行顺序为1-3-2-4.在单线程内，重排序不会影响程序执行结果。但是在多线程中就会出现问题：如何解决？ (1)Double-Check + volatile1.不允许2、3进行重排序（Double-Check + volatile 关键字）使用 volatile 关键字修饰我们的变量，就会禁止重排序，在多线程的时候CPU也有共享内存，我们在加了 volatile 关键字之后，所有的线程都可以看到共享内存的最新状态，保证了内存的可见性。用 volatile 关键字修饰的共享变量在进行写操作的时候会多出一些汇编代码，将当前处理器缓存好的数据写回系统内存，该操作会使在其他CPU里缓存了该内存地址的数据无效，从而又从共享内存同步数据，这样就保证了内存的可见性。这里主要使用了缓存一致性协议。1234567891011121314public class LazyDoubleCheckSingleton &#123; private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton()&#123;&#125; private static LazyDoubleCheckSingleton getInstance()&#123; if (lazyDoubleCheckSingleton == null) &#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if(lazyDoubleCheckSingleton == null) &#123; lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazyDoubleCheckSingleton; &#125;&#125; 2.允许2、3重排序，但是不允许其他线程看到这个重排序。 (2)静态内部类123456789101112public class StaticInnerClassSingleton &#123; private StaticInnerClassSingleton() &#123; &#125; // 静态内部类的静态初始化锁，哪个线程拿到哪个线程就去初始化它 private static class InnerClass &#123; private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); &#125; private static StaticInnerClassSingleton getInstance()&#123; return InnerClass.staticInnerClassSingleton; &#125;&#125; 原理:jvm 在类的初始化阶段，也就是 class 被加载后，并且被线程使用前都是类的初始化阶段，在这个阶段会执行类的初始化，在执行类的初始化期间 jvm 会获取一个锁，这个锁会同步多个线程对一个类的初始化，也就是图中绿色的部分,基于这个基于这个特性，我们可以实现基于静态内部类的并且是线程安全的延迟初始化方案按照这个方式，假如线程1拿到类初始化锁,右边部分指令的重排序，对于线程1并不会看到，也就是说非构造线程是不允许看到重排序的。初始化一个类，包括执行这个类的静态初始化以及初始化在这个类中的声明的静态变量，根据 java 语言规范主要分为五种情况，首次发生的时候一个类将被立刻初始化，这里说的类是泛指一个接口也是一个类，假设该类为 A，以下五种情况都会导致 A 类会被立刻初始化。1.有一个 A 类型的实例被创建2.A 类中声明的一个静态方法被调用3.A 类中声明的一个静态成员被赋值4.A 类中声明的一个静态成员被使用，并且该成员不是一个常量成员5.如果 A 类是个顶级类，并且在该类中有嵌套的断言语句，此时 A 也会被立即初始化这里的原理可以这样理解下：线程 0 拿到了 内部类的初始化锁，而内部类的初始化过程有 3 ，整个绿色的过程被上了锁，所以锁内指令重排序2、3颠倒顺序无所谓，因为从其他线程此时是没有办法进来的，只能等待这个初始化过程完毕。 饿汉式线程安全，但是如果创建出来的实际程序没有使用就会造成浪费（感觉这个担心多余，不用删掉，创建它干嘛）123456789public class HungrySingleton &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125;&#125; 基于枚举的单列1234567891011121314151617线程安全、反序列化和反射不能破坏其单例的初衷 ，可以通过jad反编译该 class 文件查看（最优解）public enum EnumInstance &#123; INSTANCE; private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public static EnumInstance getInstance() &#123; return INSTANCE; &#125;&#125; 基于 ThreadLocal 的单例模式该方法并不能保证全局唯一，但可以保证线程唯一，很多框架也用到这个模式的单例。12345678910111213141516public class ThreadLocalInstance &#123; private static final ThreadLocal&lt;ThreadLocalInstance&gt; threadLocalInstance = new ThreadLocal&lt;ThreadLocalInstance&gt;()&#123; @Override protected ThreadLocalInstance initialValue() &#123; return new ThreadLocalInstance(); &#125; &#125;; private ThreadLocalInstance() &#123; &#125; public static ThreadLocalInstance getInstance()&#123; return threadLocalInstance.get(); &#125;&#125; 序列化破坏单例模式123456789101112131415161718192021222324public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125;&#125;public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; HungrySingleton instance = HungrySingleton.getInstance(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;singleton_file&quot;)); oos.writeObject(instance); File file = new File(&quot;singleton_file&quot;); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); HungrySingleton newInstance = (HungrySingleton) ois.readObject(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); &#125;&#125; 运行结果：com.lzy.design.pattern.singleton.HungrySingleton@2626b418com.lzy.design.pattern.singleton.HungrySingleton@7530d0afalse结果发现，经过序列化和反序列化之后拿到的对象地址不一样，这违背了单例模式的初衷。增加以下方法，可以解决上述问题。注意该方法名称和返回类型最好跟下面所写一致。 解决方案123456789101112public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125; // 该方法并非被重写的方法 private Object readResolve()&#123; return hungrySingleton; &#125;&#125; 源码追踪ObjectInputStream类中readObject方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public final Object readObject() throws IOException, ClassNotFoundException &#123; if (enableOverride) &#123; return readObjectOverride(); &#125; // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try &#123; // TODO 从这里查看 Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) &#123; throw ex; &#125; if (depth == 0) &#123; vlist.doCallbacks(); &#125; return obj; &#125; finally &#123; passHandle = outerHandle; if (closed &amp;&amp; depth == 0) &#123; clear(); &#125; &#125; &#125; // ObjectInputStream#readObject0private Object readObject0(boolean unshared) throws IOException &#123; ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); ...&#125; // ObjectInputStream#readOrdinaryObjectprivate Object readOrdinaryObject(boolean unshared)&#123; ... obj = desc.isInstantiable() ? desc.newInstance() : null; ... &#125; // ObjectInputStream#isInstantiable 返回 true，执行 desc.newInstance()，通过反射创建新的单例类，// 到此时也看到了为什么在 HungrySingleton 没添加 readResolve 方法之前会返回新的对象./** * Returns true if represented class is serializable/externalizable and can * be instantiated by the serialization runtime--i.e., if it is * externalizable and defines a public no-arg constructor, or if it is * non-externalizable and its first non-serializable superclass defines an * accessible no-arg constructor. Otherwise, returns false. */boolean isInstantiable() &#123; requireInitialized(); return (cons != null);&#125; // ObjectInputStream#readOrdinaryObjectprivate Object readOrdinaryObject(boolean unshared)&#123; ... // 在 HungrySingleton 添加 readResolve 方法之后 desc.hasReadResolveMethod() 该方法执行为 true if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; // 通过反射调用 HungrySingleton 类中的 readResolve 方法返回， // 即为我们的单例对象，所以这里讲此处返回的对象赋值给 obj，所以这里我们找到了答案 Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; // Filter the replacement object if (rep != null) &#123; if (rep.getClass().isArray()) &#123; filterCheck(rep.getClass(), Array.getLength(rep)); &#125; else &#123; filterCheck(rep.getClass(), -1); &#125; &#125; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj;&#125; readResolveMethod = getInheritableMethod( // 这里有 readResolve 解答了我们 HungrySingleton 类中方法命名疑惑 cl, &quot;readResolve&quot;, null, Object.class); 反射破坏单例模式12345678910111213141516171819202122public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125;&#125; public static void main(String[] args) throws Exception &#123; Class objectClass = HungrySingleton.class; Constructor constructor = objectClass.getDeclaredConstructor(); HungrySingleton instance = HungrySingleton.getInstance(); constructor.setAccessible(true); HungrySingleton object = (HungrySingleton) constructor.newInstance(); System.out.println(instance); System.out.println(object); System.out.println(instance == object); &#125;&#125; 运行结果:com.lzy.design.pattern.singleton.HungrySingleton@7440e464com.lzy.design.pattern.singleton.HungrySingleton@49476842false 解决方案在私有化构造器中添加防止通过反射调用的代码（只针对在类加载初始化时就已经创建好单例对象的单例模式有效）即（饿汉式和基于内部类实现懒加载的单例模式有效，对其他懒汉加载无效）1234567891011121314public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123; // 防放射破坏代码,如果是通过反射调用就抛出运行时异常 if (hungrySingleton != null) &#123; throw new RuntimeException(&quot;单例构造器禁止反射调用&quot;); &#125; &#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125;&#125; 对于不是在类加载的时候创建好单例实例对象的单例模式无法避免单例被破坏 克隆破坏单例模式123456789101112131415161718192021222324252627282930313233343536public class HungrySingleton implements Serializable, Cloneable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123; if (hungrySingleton != null) &#123; throw new RuntimeException(&quot;单例构造器禁止反射调用&quot;); &#125; &#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125; // 该方法并非被重写的方法 private Object readResolve()&#123; return hungrySingleton; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); // 解决办法，1. 不实现 Cloneable 接口，2. 实现 Cloneable 接口，重写 clone 方法，调用 单例类的 getInstance 方法 //return getInstance(); &#125;&#125; public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; HungrySingleton hungrySingleton = HungrySingleton.getInstance(); Method method = hungrySingleton.getClass().getDeclaredMethod(&quot;clone&quot;); method.setAccessible(true); HungrySingleton cloneHungrySingleton = (HungrySingleton) method.invoke(hungrySingleton); System.out.println(hungrySingleton); System.out.println(cloneHungrySingleton); System.out.println(hungrySingleton == cloneHungrySingleton);&#125; 运行结果:com.lzy.design.pattern.singleton.HungrySingleton@49476842com.lzy.design.pattern.singleton.HungrySingleton@78308db1false 解决方法1.不实现 Cloneable 接口2.实现 Cloneable 接口，重写 clone 方法，调用 单例类的 getInstance 方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"抽象工厂","slug":"抽象工厂","date":"2020-01-27T03:43:26.000Z","updated":"2020-01-28T08:38:24.279Z","comments":true,"path":"2020/01/27/抽象工厂/","link":"","permalink":"https://lukeyli.github.io/2020/01/27/抽象工厂/","excerpt":"","text":"抽象工厂定义：抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。抽象工厂可以将一组具有同一主题单独的工厂封装起来。在正常使用中客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象，在使用的时候是不需要知道或关心他从这些内部的工厂方法中获得对象的具体类型，因为我们的客户端程序仅仅使用这些通用的接口，抽象工厂模式将一组对象的实现细节和他们的使用分离开来。 类型：创建型 适用场景1.客户端（应用层）不依赖于产品类实例如何被创建、实现等细节2.强调一系列相关的产品对象（属于同一产品族）一起使用，创建对象时需要大量重复的代码。3.提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现 使用抽象工厂模式能够再具体工厂变化的时候不用修改使用工厂的客户端程序 优点：1.具体产品在应用层代码隔离，无需关心创建细节2.将一个系列的产品族统一到一起创建缺点：1.规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口2.增加了系统的抽象性和理解难度 产品等级结构与产品族同一产品等级譬如：苹果、梨子、香蕉都是水果的一个产品等级，产品族的概念是：A 水果店里在卖 苹果、梨子、香蕉，B水果店也在卖上面三种水果，C 水果店也卖卖上述三种水果，A、B、C 水果店分别的苹果、梨子、香蕉 就是一个产品族。一个产品族就对应了一个具体工厂类。 coding1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class Cuisine &#123; public abstract void cookie();&#125;public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;public abstract class Soup &#123; public abstract void cookie();&#125;public class SichuanSoup extends Soup &#123; @Override public void cookie() &#123; System.out.println(&quot;做川汤&quot;); &#125;&#125;public class CantoneseSoup extends Soup &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤汤&quot;); &#125;&#125;//一桌大餐,菜少不了汤public interface DinnerFactory &#123; Cuisine getCuisine(); Soup getSoup();&#125;public class SichuanDinnerFactory implements DinnerFactory &#123; @Override public Cuisine getCuisine() &#123; return new SichuanCuisine(); &#125; @Override public Soup getSoup() &#123; return new SichuanSoup(); &#125;&#125;public class CantonseDinnerFactory implements DinnerFactory &#123; @Override public Cuisine getCuisine() &#123; return new CantoneseCuisine(); &#125; @Override public Soup getSoup() &#123; return new SichuanSoup(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; DinnerFactory dinnerFactory = new SichuanDinnerFactory(); Cuisine sichuanCuisine = dinnerFactory.getCuisine(); Soup sichuanSoup = dinnerFactory.getSoup(); sichuanCuisine.cookie(); sichuanSoup.cookie(); &#125;&#125; 源码解析java.sql.Connection 类,通过实际应用可以知道，如果你使用 MySQL 数据库驱动，那么通过该 Connection 的实现类，可以获取MySQL 数据库驱动的Statement和PreparedStatement对应子类，如果是 Oracle,同样可以获取 Oracle 对应的 Statement 和PreparedStatement对应子类，那么 java.sql.Connection 就是抽象工厂类,可以生产Statement和PreparedStatement 这一产品族的工厂。而不同的数据库驱动对应的 PreparedStatement 或 Statement 是同一产品等级。123456public interface Connection extends Wrapper, AutoCloseable &#123; ... Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) ...｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"工厂方法","slug":"工厂方法","date":"2020-01-26T15:23:44.000Z","updated":"2020-01-28T08:38:35.761Z","comments":true,"path":"2020/01/26/工厂方法/","link":"","permalink":"https://lukeyli.github.io/2020/01/26/工厂方法/","excerpt":"","text":"工厂方法类型: 创建型定义：定义一个创建对象接口，但是让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。解决同一产品等级的业务抽象问题。 简单工厂模式如果产品太多，那么工厂类的逻辑判断也会很多，如果再加上创建对象时的一些判断逻辑，那该工厂类的代码会显得很臃肿。用工厂方法模式可以起到拆分的效果，即同一产品等级下利用产品对应的工厂实例创建各自的产品实例。 适用场景1.创建对象需要大量重复的代码，可以考虑工厂方法是不是适用在这里。2.客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，只需要知道所对应的工厂，具体产品对象由对应工厂创建。3.一个类通过其子类来指定创建哪个对象。优点：1.用户只需要关心所需产品对应的工厂，无需关心创建细节2.加入新产品符合开闭原则，提高可扩展性。tip：缺点：1.类的个数容易过多，增加复杂度（增加新的类的时候，就需要同时添加该类对应的工厂类）2.增加了系统的抽象性和理解难度 coding1234567891011121314151617181920212223242526272829303132333435363738394041424344//菜品public abstract class Cuisine &#123; public abstract void cookie();&#125;//粤菜public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;//川菜public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public abstract class CuisineFactory &#123; public abstract Cuisine getCuisine();&#125;public class CantoneseCuisineFactory extends CuisineFactory &#123; @Override public Cuisine getCuisine() &#123; return new CantoneseCuisine(); &#125;&#125;public class SichuanCuisineFactory extends CuisineFactory &#123; @Override public Cuisine getCuisine() &#123; return new SichuanCuisine(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 父类的声明指向子类的应用,根据需要创建对应菜系的工厂类即可 CuisineFactory cantoneseCuisineFactory = new CantoneseCuisineFactory(); CuisineFactory sichuanCuisineFactory = new SichuanCuisineFactory(); Cuisine sichuanCuisine = sichuanCuisineFactory.getCuisine(); sichuanCuisine.cookie(); &#125;&#125; 理解下产品等级概念, 宝马车、奇瑞、悍马、路虎，都属于车的产品等级，苹果、香蕉、梨子都是水果的产品等级。 从上面可以发现，如果需需要扩展，只需要添加对应产品以及对应的产品工厂了即可。做到了对扩展开放对修改关闭。 源码解析Collection类iterator方法, Collection 抽象工厂，产品实例就是 ArrayList里面的一个内部类Itr实现了 Iterator 接口, 而ArrayList本身可以看做 Collection 工厂的子类工厂实例。每个继承 Collection 接口的子类都有不同的实现得到不同的产品实例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ... Iterator&lt;E&gt; iterator(); ...｝ public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; ...｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"简单工厂","slug":"简单工厂","date":"2020-01-24T15:01:53.000Z","updated":"2020-01-28T08:38:31.591Z","comments":true,"path":"2020/01/24/简单工厂/","link":"","permalink":"https://lukeyli.github.io/2020/01/24/简单工厂/","excerpt":"","text":"简单工厂定义：由一个工厂对象决定创建出哪一种产品类的实例。白话: 在家里，做菜得买洗炒菜等繁琐的步骤,现在都嫌做菜麻烦。但是我们还是想吃五花八门的菜怎么办，打开饿了么app对不同的菜品下单就好,不需要关心他是怎么做出来的，能吃到自己点的餐就好。类型：创建型，但不属于 GOF23 种设计模式。 适用场景1.工厂类负责创建的对象比较少2.客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心优点：1.只需要传入一个正确的参数，就可以获取你所需要的对象而无序知道其创建细节2.将对象的创建和使用分离缺点：1.工厂类的职责相对过重，增加新产品时需要修改工厂类的判断逻辑，违背开闭原则。当产品过多的时候会产生很多的类，不利于维护。2.无法形成基于继承的等级结构 coding场景：这个餐馆比较牛掰，菜品丰富，有粤菜、川菜, 在Test类(Client端)创建相应的菜品。(其实应该是具体的菜名)代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041/** * @description:菜品 * @author: lzy **/public abstract class Cuisine &#123; public abstract void cookie();&#125;/** * @description:粤菜 * @author: lzy **/public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;/** * @description:川菜 * @author: lzy **/public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public class Test &#123; public static void cookieSichuan() &#123; Cuisine cuisine = new SichuanCuisine(); cuisine.cookie(); &#125; public static void main(String[] args) &#123; cookieSichuan(); &#125;&#125; 从上面代码来看，Test 类里面声明了一个 Cuisine 类型的变量指向其 SichuanCuisine 子类, Test类是非常依赖子类（违反依赖倒置原则）。想要粤菜就得创建Cuisine的子类CantoneseCuisine。我们意愿是让客户端代码不依赖对应的产品类，把创建具体视频类的逻辑对客户端代码隐藏，使应用层的代码不依赖对应的具体实现类。 通过一个工厂类解决此问题1234567891011public class CuisineFactory &#123; //v1 根据传入的类型创建具体的实例 public Cuisine getCuisine(String type) &#123; if (&quot;Sichuan&quot;.equalsIgnoreCase(type)) &#123; return new SichuanCuisine(); &#125; else if (&quot;Cantonese&quot;.equalsIgnoreCase(type)) &#123; return new CantoneseCuisine(); &#125; return null; &#125;&#125; 问题是解决了，但是如果新增菜品，就需要新建类。需要修改CuisineFactory的判断逻辑，违背开闭原则。工厂方法类可以通过反射来优化上诉问题。通过传入的Class类型，创建对应实例，当需要新的实例时，只需要新建一个类即可，不需要修改CuisineFactory类内部创建类的判断逻辑。代码如下：12345678910111213141516171819202122232425262728public class CuisineFactory &#123; //v2 通过反射优化工厂创建对应实例 public Cuisine getCuisine(Class c) &#123; Cuisine cuisine = null; try &#123; cuisine = (Cuisine) Class.forName(c.getName()).newInstance(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return cuisine; &#125;&#125;public class Test &#123; //v2 使用反射机制优化过的工厂类 public static void main(String[] args) &#123; CuisineFactory cuisineFactory = new CuisineFactory(); Cuisine cuisine = cuisineFactory.getCuisine(SichuanCuisine.class); if (cuisine == null)&#123; return; &#125; cuisine.cookie(); &#125;&#125; 类图改进之后，不需要修改工厂类的判断逻辑，但是客户端需要创建另一种产品时，还是需要修改客户端代码，有没有一种方式就是在不修改代码的前提下做到随时创建新的产品呢？ 可以通过将所创建的产品配置到外部的配置文件中，来解决这个问题，就像Spring中数据源的一些连接信息外部化到配置文件。 改造点： 在之前版本的基础上新建一个工具类，用于读取配置文件，或得需要创建的产品的配置，这里以properties文件为例，也可以以xml文件为例key-value，value可以是多个，以逗号隔开。这样替换或者新增创建的产品根本不需要改动任何代码，就改下配置文件即可。 jdk源码使用简单工厂案例分析1.Calendar类getInstance方法。12345678910111213141516171819202122232425262728293031323334353637383940414243// getInstancepublic static Calendar getInstance(Locale aLocale)&#123; return createCalendar(TimeZone.getDefault(), aLocale);&#125;private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; // 主要看这里创建的方式，与客户端调通过传入 类型 用工厂方法时，思想一致(V1) if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;); if (caltype != null) &#123; switch (caltype) &#123; case &quot;buddhist&quot;: cal = new BuddhistCalendar(zone, aLocale); break; case &quot;japanese&quot;: cal = new JapaneseImperialCalendar(zone, aLocale); break; case &quot;gregory&quot;: cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; 2.DriverManager类getConnection()方法分析(1) Class.formName(“com.mysql.jdbc.Driver”);// 将 MySQL 的驱动加载进来，(2) 通过 DriverManager#getConnection() 方法获取 Connection。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application&apos;s * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); &#125; println(&quot;DriverManager.getConnection(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(&quot; trying &quot; + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(&quot;getConnection failed: &quot; + reason); throw reason; &#125; println(&quot;getConnection: no suitable driver found for &quot;+ url); throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); &#125; 问题:为什么执行完 Class.formName(“com.mysql.jdbc.Driver”); 就可以获取其对应数据库驱动的连接呢，是什么时候注册进去的呢？答:在com.mysql.jdbc.Driver的源码中发现有段静态初始化方法。在初始化的时候调用 DriverManager 的相应方法，最终将其注入DriverManager的private final static CopyOnWriteArrayList registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();进去。这个就是类似v2通过反射的思想一致。1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException; public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; // 注册对应的 Driver DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125;&#125; tips:1.依赖倒置原则,定义：高级模块不应当依赖于低级模块。它们都应当依赖于抽象。抽象不应当依赖于实现，实现应当依赖于抽象。2.开闭原则,定义：一个软件实体如类、模块、函数应该对扩展开放，对修改关闭。无非就是用抽象构建框架，用实现扩展细节。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"Mybatis学习","slug":"Mybatis学习","date":"2017-08-21T11:12:16.000Z","updated":"2020-01-28T09:06:17.098Z","comments":true,"path":"2017/08/21/Mybatis学习/","link":"","permalink":"https://lukeyli.github.io/2017/08/21/Mybatis学习/","excerpt":"","text":"在学习Mybatis的过程中， 写程序练手，遇到的最烦的问题是org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)，这还是我只调用increase方法向数据库增加一条信息。打印了sqlSession，可以打印出信息。 初步猜测，是mybatis-config.xml和BookMapper.xml中，猜测文件路径映射错误。检查验证发现没错，很是无奈。org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): org.lzy.mappers.BookMapper.increase。 再次检查Mapper XML文件中SQL映射语句配置，检查，书写无误。（即使只调用一个increase，但是其他SQL映射配置错误，也是会报错。） 之后查看Web Depolyment Assembly，整理文件结构，（在eclipse中新建web项目，再转成maven项目，目录结构有点乱）。推测可能是没有编译到的问题。 清理，运行编译，发现property name=”driver与jdbc.properties中名字jdbc.driverName对应错误。 总结：基本解决思路：在看错误异常提示，找到对应Mapper.XML中寻找错误，主要注意namespace命名，其次sql映射。实在不行，就先锁定区域注释其他语句，准确确定出错代码块，再分析。","categories":[{"name":"后端框架","slug":"后端框架","permalink":"https://lukeyli.github.io/categories/后端框架/"}],"tags":[]},{"title":"使用git完成基本的版本控制","slug":"使用git完成基本版本的控制","date":"2017-08-17T11:12:16.000Z","updated":"2017-10-17T00:49:59.487Z","comments":true,"path":"2017/08/17/使用git完成基本版本的控制/","link":"","permalink":"https://lukeyli.github.io/2017/08/17/使用git完成基本版本的控制/","excerpt":"","text":"Git为目前世界上先进的分布式版本控制系统。学习git是为了维护代码的版本，希望网络上有一份永久的存储，这样我们可以将代代码退回到历史版本，和别人协作。 配置用户信息git第一件事情设置自己的用户名与邮件地址。Git的提交会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name “zhangsan”git config --global user.email 邮箱 如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 文本编辑器配置默认文本编辑器，当Git需要你输入信息时会调用它，如果未配置，git会使用操作系统默认的文本编辑器，通常是Vim。如果想使用不同的编辑器，如Emacs 1git config --global core.editor emacs 检查配置信息git config –list 命令来列出所有Git当时能找到的配置。git config:检查git的莫一项配置。 获取Git仓库说明有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。 123456//在当前目录新建一个Git代码库$ git init//新建一个目录，将其初始化为Git代码库$ git init [project-name]// 下载一个项目和它的整个代码历史$ git clone [url] 一般来说，我们会用远程仓库来对代码进行备份，同时便于多人协作。可以到github,oschina或者码市上去注册一个帐号并建立一个远程仓库。 个人解读：远程库是本地库的镜像，本地库是远程库的镜像。 新增（修改）一些文件并跟踪跟踪文件 版本控制的最大作用就是记录文件的历史状态，以便随时可以回退到历史版本。如果没有版本控制，虽然编辑器都有ctrl+z功能，但是次数有限，且编辑器重启后，这些暂时记录就丢失了。把文件纳入版本控制之下。git中这个动作叫做跟踪文件. git add开始跟踪一个文件1234# 跟踪一个具体的文件git add &lt;filepath&gt;# 跟踪所有文件git add . 工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件（废话）。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态. 忽略某些文件我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式 1234567891011*.class # 忽略clsss文件# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar #忽略jar包*.war*.ear# eclipse files #.project.classpath.settings/ GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 https://github.com/github/gitignore 找到它. 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令.status命令不仅列出了文件状态，还对下一步应该使用的命令给出了提示. 提交git commit git commit -m “第一次提交” 写注释 git 状态Git 有三种状态，你的文件可能处于其中之一：已修改（modified）、已暂存（staged）和已提交（committed）。 已修改表示修改了文件，但还没跟踪，如新增的文件和刚修改过的文件。 已暂存表示对一个已修改文件的当前版本做了标记（git add）。 已提交表示数据已经安全地保存在本地数据库中(git commit)。 Git 项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。 工作目录是放在磁盘上供你使用或修改的文件及目录总和。 暂存区域是一个文件，缓存文件快照，有时候也被称作“索引”，不过一般说法还是叫暂存区域。 Git仓库是 Git 用来保存项目的元数据和文件快照的地方，记录了所有历史提交。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件（git add），将文件的快照放入暂存区域。 提交更新(git commit)，找到暂存区域的文件，将快照永久性存储到 Git 仓库。 PS:文件快照必须先经过暂存区，才能到仓库区 git add . git commit -m &quot;第一次提交&quot; 查看提交历史 git log 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。 一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交 如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项. 另外一个常用的选项是 –pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。 移除文件git rm 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 同步远程仓库git push 推送是在远程仓库建立本地仓库的副本，便于别人拉取。如果本地库和远程库一样，会得到Everything up-to-date提示. git pull 用远程仓库更新本地仓库以获得协作者推送的最新的变化.如果远端没有更新，会得到Already up-to-date.提示。","categories":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://lukeyli.github.io/tags/版本控制/"}]},{"title":"Git分支上的工作","slug":"git分支工作","date":"2017-08-17T11:12:16.000Z","updated":"2020-01-28T09:02:39.285Z","comments":true,"path":"2017/08/17/git分支工作/","link":"","permalink":"https://lukeyli.github.io/2017/08/17/git分支工作/","excerpt":"","text":"我们一定在某个分支上工作——master分支，这是git特性决定的。关于这一点，我们可以在gitdemo目录下执行git branch命令来查看，会得到这样的结果： * master 这个命令列出现存本地分支，并以星号（*）高亮当前所在的分支。 git branch -r列出远程分支 git branch -a列出远程分支和本地分支 我们需要在分支上工作几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 通常，master分支作为稳定分支，和线上发布版同步，不适合频繁更改。我们会建立多个开发分支，在开发分支上开发、测试，直到认为新功能或旧功能改造完全完成，再往主分支上合并。整个过程就像一条河流，有多个支流，每个支流都各自向前推进，某些地方他么又并入主干，然后在下面的某个地方有分叉开来，但最终汇入大海。 创建一个开发分支git branch testing // 新建分支 执行这个命令仍在 master 分支上。 因为 git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。 切换分支12345$ git checkout testing # 切换分支$ git branch # 查看分支 * testing master$ ll #查看目录结构 查看目录结构我们发现和切换前一模一样，这是因为新建分支并不是建立一个完全无关的空目录，事实上只是在此处开叉了 git checkout -，快速切换回上个分支。练习执行两次又会回到当前分支。 git checkout -b testing可新建并立即切换分支。 分支的机制git的分支，本质上仅仅是指向提交对象的可变指针。 创建分支，git只是为你创建了一个可以移动的新的指针，指针的名字就是分支的名字，你可以这样认为分支就是指针。创建一个testing分支,这会在当前所在的提交对象上创建一个指针（名字叫testing）。 它有一个名为HEAD的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支。 在新分支上工作并提交我们已经成功切换到testing分支，现在我们可以在testing分支上做一些自己的开发任务，而不用担心影响主分支。每个分支都可以独立地向前推进，如下： HEAD和分支随着提交操作自动向前移动 不同分支间不断地来回切换和工作，在时机成熟时将它们合并起来。 分支合并现在我们在主分支，我们认为testing上的改变很重要，现在希望master上拥有这些变化，这么做 1234567$ git branch # 确认当前分支$ git merge testing # 将testing的修改合并到当前master分支---Merge made by the &apos;recursive&apos; strategy. lesson2/test.rb | 1 + 1 file changed, 1 insertion(+) create mode 100644 lesson2/test.rb 合并会产生新的提交，因此，git弹出文本编辑器要求你记录下这次合并的日志。 删除分支$ git branch -d testing # 删除分支 解决分支合并冲突在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没法干净的合并它们。 12345678git checkout -b dev #新建并切换分支 vi test1.rb #编辑test1.rb，在第二行输入&quot;dev中新增一行&quot; git add . git commit -m &quot;dev change test1&quot; git checkout master vi test1.rb #编辑test1.rb，在第二行输入&quot;master新增一行&quot; git add . git commit -m &quot;master change test1&quot; 现在来合并 git merge dev --- Auto-merging lesson2/test1.rb CONFLICT (content): Merge conflict in lesson2/test1.rb Automatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。明显，lesson2/test1.rb 是有冲突的文件，自动合并失败，需要我们手工解决冲突然后再提交 合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：复制 testsomething &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD master新增一行 ======= dev中新增一行 &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev =======将内容分为两部分，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和分割线中间的部分表示HEAD所指的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支），而分割线和&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev中间的部分是dev分支的版本。为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决，然后提交","categories":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/categories/git/"}],"tags":[]},{"title":"Json详解","slug":"json详解","date":"2017-08-06T12:10:11.000Z","updated":"2020-01-28T09:05:52.958Z","comments":true,"path":"2017/08/06/json详解/","link":"","permalink":"https://lukeyli.github.io/2017/08/06/json详解/","excerpt":"","text":"本篇本人学习理解JSON的学习记录用，共同进步，欢迎指点。 JSON概念 JSON(JavaScript Object Notation)，即JavaScript对象表示法，它是用于轻量级数据交互，完全独立于语言的 文本格式，取代XML格式的繁琐标记。JSON易于程序员阅读和编写，同时也易于机器解析生成。 JSON的两种结构 JSON有两种结构：1、对象。2、数组1。对象：对象在js中表示为{}里面的内容，key/value 构成，value 的值可以是true、false、null、对象或数组。数据结构如下： 12345&#123; key1:value1,／／例如 &quot;name&quot;:&quot;张三&quot; key2:value2,／／“age”：22 ...&#125; 2.数组：数组表示一系列有序的值。数据结构：12345678910[ &#123; key1:value1, key2:value2 &#125;, &#123; key3:value3, key4:value4 &#125;] JSON字符串：var str =‘{ “name”: “李四”, “sex”: “man” }’；JSON对象：var jsobj ={ “name”: “李四”, “sex”: “man” }； JSON字符串和对象的转换一、JSON字符串转换为JSON对象。注意区分字符串和JSON字符串的区别。字符串：使用“”双引号或’’单引号包括的字符。json字符串：符合json格式要求的js字符串。var obj = JSON.parse(str);JSON.parse(). 现在大多数浏览器都支持这个方法，是推荐使用的方法。 二、JSON对象转JSON字符串var str2 = JSON.stringify（jsobj）；默认情况下，JSON.stringify()输出的JSON字符串不包括任何空格字符或缩进。 在JS中使用JSONJSON的读写有两种方式：一、利用”.”操作符二、“[key]”的方式。 123456789101112131415161718192021222324var obj = &#123; 1: &quot;value1&quot;, &quot;2&quot;: &quot;value2&quot;， person: [ //数组结构JSON对象，可以嵌套使用 &#123; id: 1, name: &quot;张三&quot; &#125;, &#123; id: 2, name: &quot;李四&quot; &#125; ], object: &#123; //对象结构JSON对象 id: 1, msg: &quot;对象里的对象&quot; &#125; &#125;; 1.从JSON中读数据 function readJSON（）&#123; alert(obj.1); //会报语法错误，可以用alert(obj[&quot;1&quot;]);说明数字最好不要做关键字 alert(obj.person[0].name); //或者alert(obj.person[0][&quot;name&quot;]) alert(obj.object.msg); //或者alert(obj.object[&quot;msg&quot;]) &#125; 2.向JSON中写数据 function write（）{ //往JSON对象中增加了一条记录 obj.sex= “男” //或者obj[“sex”]=”男”}3.修改JSON中的cout的值function Update() { obj.count = 10; //或obj[“count”]=10 } 4.删除JSON中数据 delete obj.count; 处理客户端提交的JSON数据客户端提交过来的数据一般是JSON字符串，我们一般处理方式为将JSON字符串转换为JSON对象，可以利com.alibaba.fastjson快速序列化转换。","categories":[{"name":"Json详解","slug":"Json详解","permalink":"https://lukeyli.github.io/categories/Json详解/"}],"tags":[]},{"title":"JAVAEE之jQuery","slug":"jQuery","date":"2017-08-05T11:13:44.000Z","updated":"2017-10-17T00:35:37.374Z","comments":true,"path":"2017/08/05/jQuery/","link":"","permalink":"https://lukeyli.github.io/2017/08/05/jQuery/","excerpt":"","text":"jQuery的编程模式：1、选择对象 2、do something 4、jQuery注册事件[重点]（1）常用事件与原生JS中的事件是一样的，但注册方式不一样；（2）jQuery事件注册方式： jQuery对象.事件（fn）; ----- 理解 this 关键字 jQuery对象.on(事件，fn) ----- 注册任意事件 5.重点掌握datagrid控件 1、DataGrid所展示的数据有格式 — 如果不需要分页,只需要传一个集合对象就可以了; — 如果需要分页，数据格式必须 {“total”:28,”rows”:[]}导入easyui必要的文件1、下载 easyui 包; （demo|locale(本地化)|themes(皮肤)|easyloader.js|jquery.easyui.min.js|jquery.min.js）2、将 easyui 放到工程中（保留必要的项）3、页面中需要导入的 easyui 文件 – jquery – jquery.easyui.min.js – locale文件夹下的：easyui-lang-zh_CN.js – css: themes/default /easyui.css themes/icon.css","categories":[{"name":"前端","slug":"前端","permalink":"https://lukeyli.github.io/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://lukeyli.github.io/tags/jQuery/"}]},{"title":"Servlet中URL请求参数获取","slug":"Servlet中URL请求参数获取","date":"2017-07-29T12:30:09.000Z","updated":"2020-01-28T09:06:48.910Z","comments":true,"path":"2017/07/29/Servlet中URL请求参数获取/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/Servlet中URL请求参数获取/","excerpt":"","text":"本篇介绍servle请求参数获取,整理记录自己的学习笔记。 1234567891011121314151617181920212223242526272829303132//获取单一参数,request.getParameter()返回为一个String类型System.out.println(request.getParameter(&quot;name&quot;)+request.getParameter(&quot;password&quot;)); //request.getParameterNames()返回一个枚举类型 Enumeration&lt;String&gt; paramName = request.getParameterNames(); while (paramName.hasMoreElements()) &#123; String string = (String) paramName.nextElement(); System.out.println(string+&quot;:&quot;+request.getParameter(string)); &#125; //request.getParameterMap()返回一个Map&lt;String,String[]&gt; Map&lt;String,String[]&gt; paramMap =request.getParameterMap();f or (String key : paramMap.keySet()) &#123; System.out.println(key+&quot;:&quot;+Arrays.toString(paramMap.get(key))); &#125;//获取多个同名参数值，多用于多选项获取。System.out.println(Arrays.toString(request.getParameterValues(&quot;name&quot;)));URL访问只能触发get请求，参数随URL携带post请求可以通过F orm的method选项来设定。post 的请求：参数不随URL携带。这边也记录下请求转发和重定向//请求转发,url不变。等于一次请求，服务器行为/ request.getRequestDispatcher(&quot;login.html&quot;).forward(request, response);//重定向-&gt;URL变化，等于发起了两次，客户端行为 response.sendRedirect(&quot;login.html&quot;);","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/tags/Servlet/"}]},{"title":"Servlet会话跟踪技术","slug":"Servlet会话跟踪技术","date":"2017-07-29T12:10:11.000Z","updated":"2020-01-28T09:06:33.062Z","comments":true,"path":"2017/07/29/Servlet会话跟踪技术/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/Servlet会话跟踪技术/","excerpt":"","text":"前面引用一些大纵、通俗易懂的描述。笔记贴，有错还请提出，互相进步，谢谢。 一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术Cookie 、Session Cookie：是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 Session：是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于 session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它 web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 四、Cookie类的主要方法Cookie(String name, String value)描述：实例化Cookie对象，传入cooke名称public String getName() 描述：取得Cookie的名字public String getValue() 描述：取得Cookie的值public void setValue(String newValue) 描述：设置Cookie的值public void setMaxAge(int expiry)描述：设置Cookie的最大保存时间public void setPath(String uri) 描述：设置cookie的有效路径public void setDomain(String pattern)描述： 设置cookie的有效域详细细节阅读java中javax.servlet.http.Cookie 五、Cookie类使用范例 //获取会话信息 Cookie[] cookies = request.getCookies(); if(cookies!=null) { for (Cookie cookie : cookies) { //打印cookie信息 response.getWriter().println(cookie.getName()+”:”+URLDecoder.decode(cookie.getValue())); } //获取session信息 response.getWriter().println(“——session信息————–); response.getWriter().print(request.getSession().getAttribute(“info”)); response.getWriter().println(request.getSession().getId()); //Cookie实现会话跟踪 //写cookie Cookie cookie =new Cookie(“info”, URLEncoder.encode(name)); cookie.setMaxAge(-1);//有效时间0代表删除，-1永久有效，或者以秒为单位的int response.addCookie(cookie); //session会话跟踪 HttpSession session = request.getSession(); session.setAttribute(“info”, name); response.sendRedirect(“view.do”); 六、关于Cookie和Session的问题一、描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。如果客户在浏览器上禁用了cookie，如何做会话跟踪？回答：Cookie是浏览器端技术，将会按照服务端响应的指示（response.addCookie(new Cookie(k,v))）把cookie键值对存储在本地（和网址关联的），且在随后的访问中把cookie添加到请求header中发送给服务器。 Seesion是服务端，web容器当中的一个容器，存储在服务器端的内存里面，用来进行会话跟踪的，同一个客户端的多个请求将映射到同一个session。典型的应用：1、存储用户的登录状态 2、维持购物车这样的可连续操作的内容","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/tags/Servlet/"}]},{"title":"JAVAEE之Servlet进阶","slug":"JAVAEE之Servlet进阶","date":"2017-07-29T11:12:11.000Z","updated":"2020-01-28T09:03:39.010Z","comments":true,"path":"2017/07/29/JAVAEE之Servlet进阶/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/JAVAEE之Servlet进阶/","excerpt":"","text":"Servlet中的九大内置对象ServletConfig|config1、ServletConfig 对象 ： init-param 节点中注册的初使化参数被封装ServletConfig对象中;2、此对象在init方法被调用时由服务器自动创建,并通过参数传递给用户; --- 通过 init 方法拿到 ServletConfig 对象; --- getServletConfig(); 3、ServletConfig API – getInitParameter(paraname) ##ServletContext|application1、ServletContext：整个WEB应用程序，此对象在工程运运行时创建，在服务器关闭时消失； – 1、存放所有Servlet共享的数据 – 2、获取应用程序资源 -- 获取class路径下的资源 -- WEB根路径下的资源 –3、获取ServletContext的初使化数据 2、获取ServletContext; ##HttpServletResponse|response1.输出信息1.通过字节流输出数据：— getOutputStream() —&gt; ServletOutputStream2、输出字符数据： — getWriter() — &gt;PrintWriter; ##HttpServletRequest|request HttpServletRequest：The servlet container creates an HttpServletRequest object and passes it as an argument to the servlet’s service methods (doGet, doPost, etc). – 接收来自用户信息（浏览器）– getHeader(headname);– getHeaderNames()– get…… –getParameter(参数名); —&gt;String–getParameterValues() —&gt;String[] –getRequestDispatcher(url).forward(request,response); –解决中文 ###1、获取网页中的表单数据 request.getParameter(“参数名”);解决中文乱码问题： 1、单个重新编码 String str = new String (data.getBytes(“ISO-8859-1”,”UTF-8”);2、统一设置 request.setCharacterEncoding(“UTF-8”); ###2、获取URL中的参数数据 123request.getParameter(&quot;参数名&quot;);String add = request.getParmeter(&quot;add&quot;); String data = new String(add.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); ##HttpSession|sessionHTTPSession：会话（当请求或者访问一个网页，就标识与当前页面建立了一次会话）；可以在会话的对象存放数据（标识用户身份的数据），此数据在下一个页面中可以取到（session对象中所存放的数据可以跨页面访问） – HttpSession session = request.getSession(); – 1、可以在session对象中存放数据；此数据可以跨页面访问– 2、当访问某一个页面时，服务器会给每一个用户创建一个sessionid,sessionid是唯一的 此sessionid在服务器内存中存一份，同发送给用户;当提交网页到服务器;将用户端的sessionid和服务器存的sessionid做比对，以判断是哪一个用户提交的; –3、存活期：默认为30分钟 ##PrintWriter|JspWriter|out ##this(page) ##pageContext ##exception只能在标识 isErrorPage的页面中使用 #2、Servlet三大域对象 ##ServletContext|application ##HttpSession|session ##HttpServletRequest|request三大域对象都可以存数据，并都可以在页面中取出域对象中的数据 HttpServletRequest域对象中存放数据在同一个Request请求中有效;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lukeyli.github.io/tags/servlet/"}]},{"title":"JAVAEE之Servlet入门","slug":"JAVAEE之Servlet入门","date":"2017-07-22T12:48:43.000Z","updated":"2020-01-28T09:03:27.762Z","comments":true,"path":"2017/07/22/JAVAEE之Servlet入门/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/JAVAEE之Servlet入门/","excerpt":"","text":"理解Servlet Servlet：A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol. 如何开发一个Servletimplement this interface, you can write a generic servlet that extends javax.servlet.GenericServlet or an HTTP servlet that extends javax.servlet.http.HttpServlet. 开发一个Servlet三种方式： 1、写一个类 ，实现 Servlet 接口 ；2、写一个类 ，继承 javax.servlet.GenericServlet3、写一个类， 继承 javax.servlet.http.HttpServlet. 1、创建Servlet2、发布Servlet123456789&lt;!-- 发布 Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;servlet-class&gt;org.lanqiao.servlet.ServletA&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletA.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3、Servlet生命周期This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from the server 1、初使化Servlet (init);2、接收和响应用户请求（service）3、从服务器中移出 (destroy) 4、url-pattern1234/servletA.do/user/servletA.do/user/**.do","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lukeyli.github.io/tags/servlet/"}]},{"title":"JAVAEE之web基础知识","slug":"web基础知识","date":"2017-07-22T11:40:44.000Z","updated":"2020-01-28T09:07:15.644Z","comments":true,"path":"2017/07/22/web基础知识/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/web基础知识/","excerpt":"","text":"持续更新 理解Web1、WEB应用程序的结构（采用JSP技术开发的WEB应用程序） —META-INF —WEB-INF –class –lib –web.xml —JSP页面|基它资源2、在Eclispe中创建一个Web应用程序(网站)3、理解WEB应用程序的工作模式：请求、响应模式 Client(brows) &lt;------&gt; Web服务器 ---(解析：生成一个浏览器能识别的数据（html|css| js -- 静态数据）) web服务器：tomcat1、了解tomcat服务器目录结构 2、在Eclispe中配制Tomcat服务器3、将Eclispe中创建的Web应用程序发布到Tomcat服务器中; – webapps路径下;4、在Eclispe中启动和关闭Tomcat服务器 --- 调式模式 ---当需要重新启动Tomcat服务器时，建议先关闭Tomcat服务器，再启动 Eclispe中相关配制1、配制JSP文件配制的编码2、配制工程编码3、配制workspace编码1、eclipse必须支持JAVAEE2、Servers面板3、建议将网站部署到Tomcat服务器;问题1、eclipse必须支持JAVAEE2、Servers面板3、建议将网站部署到Tomcat服务器;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之注解","slug":"注解","date":"2017-07-22T11:12:16.000Z","updated":"2020-01-28T08:59:22.973Z","comments":true,"path":"2017/07/22/注解/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/注解/","excerpt":"","text":"持续更新","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之IO&XML","slug":"IO和XML","date":"2017-07-16T10:40:11.000Z","updated":"2020-01-28T09:02:47.904Z","comments":true,"path":"2017/07/16/IO和XML/","link":"","permalink":"https://lukeyli.github.io/2017/07/16/IO和XML/","excerpt":"","text":"持续更新中…","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之多线程","slug":"多线程","date":"2017-07-15T11:03:44.000Z","updated":"2017-09-09T02:43:35.633Z","comments":true,"path":"2017/07/15/多线程/","link":"","permalink":"https://lukeyli.github.io/2017/07/15/多线程/","excerpt":"","text":"持续更新","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lukeyli.github.io/tags/多线程/"}]},{"title":"Java之异常处理","slug":"Java之异常处理","date":"2017-07-08T11:15:16.000Z","updated":"2020-01-28T09:05:31.616Z","comments":true,"path":"2017/07/08/Java之异常处理/","link":"","permalink":"https://lukeyli.github.io/2017/07/08/Java之异常处理/","excerpt":"","text":"本人学习笔记记录专用，有不足之处望之处，内容持续更新。后续更新中…","categories":[{"name":"Java","slug":"Java","permalink":"https://lukeyli.github.io/categories/Java/"}],"tags":[]},{"title":"Java之数据结构","slug":"Java数据结构","date":"2017-07-01T12:40:01.000Z","updated":"2020-01-28T09:05:12.146Z","comments":true,"path":"2017/07/01/Java数据结构/","link":"","permalink":"https://lukeyli.github.io/2017/07/01/Java数据结构/","excerpt":"","text":"学习笔记专用，持续更新。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之网络编程","slug":"java网络编程","date":"2017-07-01T12:12:11.000Z","updated":"2020-01-28T09:05:22.329Z","comments":true,"path":"2017/07/01/java网络编程/","link":"","permalink":"https://lukeyli.github.io/2017/07/01/java网络编程/","excerpt":"","text":"持续更新中...","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java集合和泛型","slug":"java集合和泛型","date":"2017-06-25T11:04:14.000Z","updated":"2020-01-28T09:05:01.404Z","comments":true,"path":"2017/06/25/java集合和泛型/","link":"","permalink":"https://lukeyli.github.io/2017/06/25/java集合和泛型/","excerpt":"","text":"持续更新中...","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java基础之面向对象","slug":"Java基础之面向对象 ","date":"2017-06-24T11:30:11.000Z","updated":"2020-01-28T09:04:35.457Z","comments":true,"path":"2017/06/24/Java基础之面向对象 /","link":"","permalink":"https://lukeyli.github.io/2017/06/24/Java基础之面向对象 /","excerpt":"","text":"本篇整理个人以前笔记，有不足之处还望指出。 Object类 类和对象 包和访问控制 抽象类和接口接口和抽象类的相同特征：两者都不能实例化。它们都位于继承树的顶端，用于被其他类实现和继承。两者都可包含抽象方法，留待子类去实现。 接口和抽象类的差别：接口类似于整个系统的总纲，它制定了系统各模块应遵循的标准。因此一个系统中的接口不应该经常改变。抽象类作为系统中多个子类的父类，体现的是一种模板式设计。其相当于系统实现过程的中间产品，已有部分实现，但须进一步完善。接口里只能包含抽象方法，而抽象类可以同时包含抽象方法和普通方法。接口里不能定义静态方法，抽象类里可以。接口里只能定义静态常量 Field，不能定义普通 Field；抽象类里二者均可定义。接口里不包含构造器，抽象类里可以包含（供其子类调用进行初始化操作）。接口里不能包含初始化块，抽象类可以。一个类最多只能有一个直接父类，但可以直接实现多个接口。 继承和多态","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java基础之程序设计基础","slug":"Java基础之程序设计基础 ","date":"2017-06-15T11:11:16.000Z","updated":"2020-01-28T09:04:46.579Z","comments":true,"path":"2017/06/15/Java基础之程序设计基础 /","link":"","permalink":"https://lukeyli.github.io/2017/06/15/Java基础之程序设计基础 /","excerpt":"","text":"整理自己以前笔记专用，有不足之处还望指出 JAVA数据类型个人整理思维导图，所用工具XMind 流程控制 方法和数组 字符串","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java基础之初识Java","slug":"java基础","date":"2017-06-04T11:12:16.000Z","updated":"2020-01-28T09:03:55.291Z","comments":true,"path":"2017/06/04/java基础/","link":"","permalink":"https://lukeyli.github.io/2017/06/04/java基础/","excerpt":"","text":"本篇本人整理以前笔记记录用的，有不足之处还望指出。用Xmind整理的思维导图。初识Java的话 谈JavaJava发展历程的话，很长，有兴趣了解Java发展史，可以自行百度一下，很多很详细的内容，毕竟这家伙比我年龄还大。比较有趣的是一家伙原本叫Oak，当时James Gosling办公室的窗外，正好有偶一棵橡树（Oak），但是有一家公司已经用了这个名字，工程师后来一边喝咖啡一边讨论新名字，看看手上的咖啡，顺手就取了JAVA这个名字。 Java的特点 Java是门优秀的语言，当然他的特点也就很多了，比如面向对象，平台无关性（仅语言）、分布性（网络）、移植性、解释性、高性能、多线程、动态安全、健壮性等。主要熟知Java的封装继承多态，还有他的平台无关性（跨平台）。 封装：就是把同一类事物的共性（属性和方法）归为一个类中，方便使用。 继承：子承父业，一个类继承另一个类，实现代码的复用。 多态：多态的概念是以封装和继承为基础的。子类以父类的身份出现，但做事情时还是以自己的方法实现。子类以父类的身份出现需要向上转型(upcast)，其中向上转型是由JVM自动实现的，是安全的，但向下转型(downcast)是不安全的，需要强制转换。子类以父类的身份出现时自己特有的属性和方法将不能使用。（多态为Java初学者一容易踩坑的地方） 跨平台：不是java语言跨平台，是由于不同操作系统有不同的JVM虚拟机，java程序员不用考虑所写的程序在哪里运行，写好的程序.java由编译器编译成.class文件，放心的交给虚拟机，变成相对应的平台的机器语言。（字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言） gc回收机制（Garbage Collections） 扩展：G1:对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"gc","slug":"gc","permalink":"https://lukeyli.github.io/tags/gc/"}]}]}