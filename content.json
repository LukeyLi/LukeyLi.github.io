{"meta":{"title":"LukeyLi's Blog","subtitle":null,"description":null,"author":"LukeyLi","url":"https://lukeyli.github.io"},"pages":[{"title":"","date":"2020-01-25T12:34:31.798Z","updated":"2020-01-25T12:34:31.798Z","comments":true,"path":"about/index.html","permalink":"https://lukeyli.github.io/about/index.html","excerpt":"","text":"关于我 从事java后端开发, 熟悉使用ssm、springCloud等主流框架。热爱生活、热爱新技术、热爱新事物。 关于工作 城市：福州 关于学习 活到老学到老，正在往终身学习者前进。 关于座右铭 The Harder You Work, The Luckier You Will Be. 关于爱好 热爱运动，喜欢慢跑,听音乐看电影等。"},{"title":"","date":"2020-02-29T14:53:41.244Z","updated":"2020-02-29T14:53:41.244Z","comments":true,"path":"diary/日志/index.html","permalink":"https://lukeyli.github.io/diary/日志/index.html","excerpt":"","text":"Category: 日志 | LukeyLi&#39;s Blog LukeyLi&#39;s Blog Home Archives diary About LukeyLi&#39;s Blog 一个不断进步的程序猿的技术博客 2020 2020-02-29 10:52 日志模块 #live2dcanvas { position: fixed; right: 0px; z-index: 999; pointer-events: none; bottom: 3px; } loadlive2d(\"live2dcanvas\" ,\"/live2d/assets/haru/haru.model.json\",0.5) 总访客数： 总访问量： Powered by Hexo Theme MiHo &copy; 2020 LukeyLi var mihoConfig = { root: \"https://lukeyli.github.io\", animate: true, isHome: false, share: true } Java基础Json详解gitjavarabbitMQsql前端后端框架日志设计模式 Mark Word Servlet gc git jQuery java8 java对象头 mysql servlet 乐观锁 多线程 悲观锁 版本控制 索引 设计模式 &times; Menus Home Archives diary About Tags Mark Word Servlet gc git jQuery java8 java对象头 mysql servlet 乐观锁 多线程 悲观锁 版本控制 索引 设计模式 &times; {title}"}],"posts":[{"title":"mybatis分页","slug":"mybatis分页","date":"2020-03-22T10:50:31.000Z","updated":"2020-03-23T15:57:01.881Z","comments":true,"path":"2020/03/22/mybatis分页/","link":"","permalink":"https://lukeyli.github.io/2020/03/22/mybatis分页/","excerpt":"","text":"项目中用github上的mybatis的分页插件PageHelper，使用方式是很简单，但是知其然还要知其所以然。要不然他干了什么，性能瓶颈在哪里，是个深究的问题 获取分页信息追踪PageMethod的startPage方法123456789101112131415161718 public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) &#123; Page&lt;E&gt; page = new Page(pageNum, pageSize, count); page.setReasonable(reasonable); page.setPageSizeZero(pageSizeZero); Page&lt;E&gt; oldPage = getLocalPage(); if (oldPage != null &amp;&amp; oldPage.isOrderByOnly()) &#123; page.setOrderBy(oldPage.getOrderBy()); &#125; setLocalPage(page); return page; &#125;protected static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal&lt;Page&gt;();protected static void setLocalPage(Page page) &#123;LOCAL_PAGE.set(page);&#125; 存放ThreadLocal地方，有set必然有removePageInterceptor.intercept(Invocation)中使用代理1234567891011121314finally &#123; dialect.afterAll();&#125;@Overridepublic void afterAll() &#123; //这个方法即使不分页也会被执行，所以要判断 null AbstractHelperDialect delegate = autoDialect.getDelegate(); if (delegate != null) &#123; delegate.afterAll(); autoDialect.clearDelegate(); &#125; clearPage();&#125; 就是先使用PageHelper.startPage这样的语句在当前线程上下文中设置一个ThreadLocal变量，再利用mybatis提供的拦截器（插件）实现一个PageInterceptor接口，分页拦截器拦截到后会从ThreadLocal中拿到分页的信息，如果有分页信息，进行分页查询，最后再把ThreadLocal中的东西清除掉。 plugin加载那么plugin插件是如何加载到sql上去的？ SqlSqlSession是MyBatis的关键对象, 那么加载分页插件肯定是追踪与他相关。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; SqlSessionFactory var5; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //配置文件解析 var5 = this.build(parser.parse()); &#125; catch (Exception var14) &#123; throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, var14); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException var13) &#123; ; &#125; &#125; return var5; &#125;// next step 发现了解析配置public Configuration parse() &#123;if (this.parsed) &#123; throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);&#125; else &#123; this.parsed = true; this.parseConfiguration(this.parser.evalNode(&quot;/configuration&quot;)); return this.configuration;&#125;&#125;// 然后看到了private void parseConfiguration(XNode root) &#123;try &#123; this.propertiesElement(root.evalNode(&quot;properties&quot;)); Properties settings = this.settingsAsProperties(root.evalNode(&quot;settings&quot;)); this.loadCustomVfs(settings); this.loadCustomLogImpl(settings); this.typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); // &lt;font color = #FF0040&gt;解析plugin的方法&lt;/font&gt; this.pluginElement(root.evalNode(&quot;plugins&quot;)); this.objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); this.objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); this.reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); this.settingsElement(settings); this.environmentsElement(root.evalNode(&quot;environments&quot;)); this.databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); this.typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); this.mapperElement(root.evalNode(&quot;mappers&quot;));&#125; catch (Exception var3) &#123; throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + var3, var3);&#125;&#125; 然后接着追踪SqlSessionFactory对象的build过程，加载了全局配置文件及映射文件同时还将配置的拦截器添加到了拦截器链中。12pagehelper: helperDialect: mysql Executor接下来SqlSessionFactory 创建SqlSession，过程中发生了什么1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; DefaultSqlSession var8; try &#123; Environment environment = this.configuration.getEnvironment(); TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); // 关键 Executor 执行过程 Executor executor = this.configuration.newExecutor(tx, execType); var8 = new DefaultSqlSession(this.configuration, executor, autoCommit); &#125; catch (Exception var12) &#123; this.closeTransaction(tx); throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; + var12, var12); &#125; finally &#123; ErrorContext.instance().reset(); &#125; return var8; &#125;public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123; executorType = executorType == null ? this.defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Object executor; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; if (this.cacheEnabled) &#123; executor = new CachingExecutor((Executor)executor); &#125; //拦截器链 Executor executor = (Executor)this.interceptorChain.pluginAll(executor); return executor;&#125;public Object pluginAll(Object target) &#123; Interceptor interceptor; for(Iterator var2 = this.interceptors.iterator(); var2.hasNext(); target = interceptor.plugin(target)) &#123; interceptor = (Interceptor)var2.next(); &#125; return target;&#125;//拦截器的plugin方法default Object plugin(Object target) &#123;//需要拦截的类型，增强 return Plugin.wrap(target, this);&#125; public static Object wrap(Object target, Interceptor interceptor) &#123; Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor); Class&lt;?&gt; type = target.getClass(); Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap); //返回jdk代理类，代理类增强目标 return interfaces.length &gt; 0 ? Proxy.newProxyInstance(type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap)) : target; &#125;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); // 如果是定义的拦截的方法 就执行intercept方法 if (methods != null &amp;&amp; methods.contains(method)) &#123; // 进入查看 该方法增强 return interceptor.intercept(new Invocation(target, method, args)); &#125; // 不是需要拦截的方法 直接执行 return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125;&#125; selectListsqlSession 查看selectList方法1234567891011121314public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; List var5; try &#123; MappedStatement ms = this.configuration.getMappedStatement(statement); // executor执行query 触发invoke方法 var5 = this.executor.query(ms, this.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception var9) &#123; throw ExceptionFactory.wrapException(&quot;Error querying database. Cause: &quot; + var9, var9); &#125; finally &#123; ErrorContext.instance().reset(); &#125; return var5;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://lukeyli.github.io/categories/java/"}],"tags":[{"name":"分页机制","slug":"分页机制","permalink":"https://lukeyli.github.io/tags/分页机制/"}]},{"title":"分布式会话","slug":"分布式会话","date":"2020-03-22T08:16:22.000Z","updated":"2020-03-22T09:41:09.597Z","comments":true,"path":"2020/03/22/分布式会话/","link":"","permalink":"https://lukeyli.github.io/2020/03/22/分布式会话/","excerpt":"","text":"会话 会话Session代表的是客户端与服务器的一次交互过程，这个过程可以是连续也可以是时断时续的。 曾经的Servlet时代（jsp），一旦用户与服务端交互，服务器用户创建一个session, 同时前端会有一个jsessionid, 每次交互都会携带。 服务器只要在接到用户请求时候，就可以拿到jsessionid，并根据这个ID在对应的会话session，当拿到session会话后，那么我们可以操作会话了。 在会话存活期间，我们就能认为用户一直处于正在使用着网站的状态，一旦session过期，就可以认为用户已经离开网站，停止交互了。 用户的身份信息，我们也是通过session来判断的，在session中可以保存不同用户的信息。 代码中体现：123456789@GetMapping(&quot;/setSession&quot;)public Object setSession(HttpServletRequest request) &#123; HttpSession session = request.getSession(); session.setAttribute(&quot;userInfo&quot;, &quot;Micheal&quot;); session.setMaxInactiveInterval(3600); session.getAttribute(&quot;userInfo&quot;); // session.removeAttribute(&quot;userInfo&quot;); return &quot;ok&quot;; &#125; 无状态会话 HTTP请求是无状态的，用户向服务端发起多个请求，服务端并不会知道这多次请求都是来自同一用户，这个就是无状态的。 cookie的出现就是为了有状态的记录。常见的，ios与服务端交互，安卓与服务端交互，前后端分离，小程序与服务端交互，他们都是通过发起http来调用接口数据的。 每次交互服务端都不会拿到客户端的状态，但是我们可以通过手段去处理，比如每次用户发起请求的时候携带一个userid或者user-token,就能让服务端根据用户id或token来获得相应的数据。每个用户的下一次请求都能被服务端识别来自同一个用户。 有状态会话 tomcat中的会话，就是有状态的，一旦用户和服务端交互，就有会话，会话保存了用户的信息，这样用户就”有状态”了，服务端会和每个客户端都保持着一层关系，这个由容器来管理（也就是tomcat），这个session会话是保存到内存空间里的。 当不同的用户访问服务端，那么就能通过会话知道谁是谁了。tomcat会话的出现也是为了让http请求变的有状态。 如果用户不再和服务端交互，那么会话超时则消失，结束了他的生命周期。如此一来，每个用户其实都会有一个会话被维护，这就是有状态会话。理解Cookie是保存在客户端的有状态，Session是保存在服务器的有状态。注：tomcat会话可以通过手段实现多系统之间的状态同步，但是会损耗一定的时间，一旦发生同步那么用户请求就会等待，这种做法不可取。 会话架构单Tomcat会话先来看一下单个tomcat会话，这个就是有状态的，用户首次访问服务端，这个时候会话产生，并且会设置jsessionid放入cookie中，后续每次请求都会携带jsessionid以保持用户状态。 动静分离分话用户请求服务端，由于动静分离，前端发起http请求，不会携带任何状态，当用户第一次请求以后，我们手动设置一个token，作为用户会话，放入redis中，如此作为redis-session，并且这个token设置后放入前端cookie中（app或小程序可以放入本地缓存），如此后续交互过程中，前端只需要传递token给后端，后端就能识别这个用户请求来自谁了。 集群分布式系统会话集群或分布式系统本质都是多个系统，假设这个里有两个服务器节点，分别是AB系统，他们可以是集群，也可以是分布式系统。由于Session是保存在服务器的，我们这里用了两个服务器，两个服务器session不是共享的，所以一个服务器无法访问另一个服务器的会话。 这里我们使用Redis实现分布式的会话：一开始用户和A系统交互，那么这个时候的用户状态，我们可以保存到redis中，作为A系统的会话信息，随后用户的请求进入到了B系统，那么B系统中的会话我也同样和redis关联，如此AB系统的session就统一了。当然cookie是会随着用户的访问携带过来的。那么这个其实就是分布式会话，通过redis来保存用户的状态。","categories":[{"name":"会话","slug":"会话","permalink":"https://lukeyli.github.io/categories/会话/"}],"tags":[]},{"title":"随记20200321","slug":"随记20200321","date":"2020-03-22T06:39:16.000Z","updated":"2020-03-22T06:46:00.753Z","comments":true,"path":"2020/03/22/随记20200321/","link":"","permalink":"https://lukeyli.github.io/2020/03/22/随记20200321/","excerpt":"","text":"2020-0321&emsp;&emsp;最近的感受，就是百感交集。产品小哥哥去意已决，先行一步。原本以为我会先按耐不住先提的。最近呢，新来的一个一年多经验的IOS开发，原本以为会接老IOS开发的班，然后之前的IOS走人，结果一个礼拜不到，在某次下班开会后，第二天就走了。大概是直接看透了，没有晋升方式，没有奖励机制，没有福利。测试一个人瞎划水，没有版本时间规划，一两天发一版，出问题上面直接怼开发。出于考虑，我很真诚的和新来的HR总监，说我在考虑是否长期待在公司，不要造成双方的损失。&emsp;&emsp;稳定应该是能为之长期奋斗以及收获成果的地方。我之所以选择开发，因为我的思维逻辑好，我又坐的住，耐得住bug，不用虚头巴脑的，而且付出与收获能成正比。毕业后的我，第一家是创业公司，一方面考虑到技术方面可以快速磨砺提升，能直接看到你的价值。另一方面，出于他们说做金融方面的产品，与支付相关等，总的来说觉得这家能让自己可以快速成长，快速晋升成为能带领队伍的人，奋斗与收获更能明显。我还带了有能力的前端进了那家公司（说好的内推奖金没给）。我走的时候，他们还在奢望管理层敲响警钟，总监担心我带走同事，跟我说好聚好散，一堆好话，然而我让他们继续积累（开玩笑的说，我找到好地方，勿相忘）。今年就算是疫情期间，他们也铁了走的心，当管理层想涨薪稳定军心的时候，已经没有用了，让我真正开心的是，我推荐的人，留的价格最高，甚是欣慰，哈哈哈迟了。对于上次跳槽的失败，总结来说，眼光放得太小，放在福州仓山以及鼓楼亲戚朋友附近，而忽略自己的价值的发展以及体现地方，最后没有达到预期的薪资将就在熟悉的地方附近，不成熟的做法。该玩的时候好好玩，在什么位置为什么奋斗，不要否定自身的价值。时间让我明白，自己的稳定是，价值的体现以及为之奋斗的孤独者。出于疫情考虑，程序员可不是青春饭，青春也不等人，浑噩不是自己的人生座右铭，何时自己畏首畏尾，害怕失败。 &emsp;&emsp;因为疫情的影响，裸辞可不是明智的选择。内心还是没法接受糟糕的氛围，就去努力。坚信越努力越幸运，不断改善自己的学习方式，不断去学习，不断去提升自己。希望这次的准备，能拿到满意的offer, 虽然还年轻，但越是越年轻，越应该让自己升值。在人生的选择道路上，这次如果没有满意的薪资，就去考研吧，立个Flag, 大男孩。","categories":[{"name":"diary","slug":"diary","permalink":"https://lukeyli.github.io/categories/diary/"}],"tags":[]},{"title":"生产环境的热更新","slug":"生产环境的热更新","date":"2020-03-19T14:12:33.000Z","updated":"2020-03-20T14:18:58.691Z","comments":true,"path":"2020/03/19/生产环境的热更新/","link":"","permalink":"https://lukeyli.github.io/2020/03/19/生产环境的热更新/","excerpt":"","text":"在服务器部署java应用，生成单一 Jar 文件部署的时候，单一文件为我们开发单来的极大的便利性，保障程序的完整性。但同时对我们修改程序中的任何一处都带来重启服务的麻烦。生产环境不热更新就是很头疼的问题，发布极其麻烦。 热加载原理：热加载的实现原理主要依赖jvm的类加载机制，在运行时对被修改过的类进行重新载入。实现方式：在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。适用场景：热加载会直接修改jvm中的字节码，这种方式对既有代码行为的影响难以控制，风险较大，几乎不会在生产环境使用该方案。 热部署原理：热加载是指在服务器运行时重新部署项目，它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。实现方式: Weblogic、tomcat都可以通过配置支持热部署，但主要用于开发测试环境，较少应用于生产环境。适用场景：热部署大大简化了发布操作，在开发和测试环境使用很普遍；但由于开通热部署后会增大系统开销，因此较少在生产环境使用。 集群分批热部署原理：利用nginx、apache等代理服务器自动对后端服务器的有效性进行判断，转发请求到有效的服务器上。在此基础上对后端服务器先后逐个更新，达到不停机部署的目的。实现方式：在集群的前端代理服务器上配置有效性检测和自动剔除失效的后端服务器。适用场景：适用于多台后端服务器的集群环境，该方案普遍应用于生产环境。","categories":[{"name":"生产环境","slug":"生产环境","permalink":"https://lukeyli.github.io/categories/生产环境/"}],"tags":[{"name":"热更新","slug":"热更新","permalink":"https://lukeyli.github.io/tags/热更新/"},{"name":"nginx","slug":"nginx","permalink":"https://lukeyli.github.io/tags/nginx/"}]},{"title":"高并发","slug":"高并发","date":"2020-03-17T15:57:51.000Z","updated":"2020-03-19T13:50:22.088Z","comments":true,"path":"2020/03/17/高并发/","link":"","permalink":"https://lukeyli.github.io/2020/03/17/高并发/","excerpt":"","text":"在架构设计中最需要考虑的一个因素就是高并发，通过设计保证系统能够同时并行处理很多请求常见架构如下： 常见提升性能： 水平扩展反向代理的水平扩展 反向代理的水平扩展： 负载均衡——&gt;默认策略：轮询（平均分配）, 加权轮询，ip_hash负载均衡，url_hash, least_con等。nginx控制浏览器缓存 实现nginx高可用HA，提供备用机nginx，实现高可用。实现方案实现Keepalived。 单个Nginx承受不了压力，使用LVS充当Nginx集群的调度者。nginx接受请求来回，LVS可以只接受不响应 数据库的水平扩展将原本存储在一台服务器上的数据库水平拆分到不同服务器上去，以达到扩充系统性能的目的。 每台数据库服务存储一定范围的数据user0库，存储uid范围1-100w，user1库，存储uid范围100w-200w优点:1.规则简单，service只需判断一下uid范围就能路由到对应的存储服务；2.数据均衡性较好；3.比较容易扩展，可以随时加一个uid[200w,300w]的数据服务；缺点：1.请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大range的服务请求压力会更大； 每一个数据库，存储某个key值hash后的部分数据优点：1.规则简单，service只需对uid进行hash能路由到对应的存储服务；2.数据均衡性较好；3.请求均匀性较好；缺点：1.不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移； 通过主从同步读写分离扩展数据库性能：1.每个服务器上存储的数据量是和总量相同；2.n个服务器上的数据都一样，都是全集；3.理论上读性能扩充了n倍，写仍然是单点，写性能不变；","categories":[{"name":"并发","slug":"并发","permalink":"https://lukeyli.github.io/categories/并发/"}],"tags":[]},{"title":"那些年吐槽的事","slug":"那些年吐槽的事","date":"2020-03-15T15:16:11.000Z","updated":"2020-03-17T13:12:46.716Z","comments":true,"path":"2020/03/15/那些年吐槽的事/","link":"","permalink":"https://lukeyli.github.io/2020/03/15/那些年吐槽的事/","excerpt":"","text":"写代码，不知道有没有人跟我一样的感觉，看到不规范的代码，很是纠结，是同流合污呢还是不予苟同呢。当同事问我，你在纠结什么，反正以后可能就不归你管，前人埋坑，后人买单，因果循环。唉，冤冤相报何时了。 遇到的不规范这些年我遇到的不规范，吐槽点。 enum我们程序员是专业的，要研发属于中国的开发语言，看下项目中的enum让我想到一个表情emmm12345678910111213//课件类型枚举的原codepublic enum CourseWareTypeEnums &#123; PPT(1), WORD(4), 视频(5), 音频(6), PDF(7), ... private Integer code; public Integer getCode() &#123;return code;&#125; public void setCode(Integer code) &#123; this.code = code;&#125; CourseWareTypeEnums(Integer code) &#123; this.code = code &#125;&#125; 看到上面这个,还有全是中文(xxx)的枚举, 我想到滑稽的表情。写好点很难吗。心累12345678public enum CourseWareTypeEnums &#123; PPT(1,&quot;PPT&quot;)， VIDEO(2,&quot;视频&quot;)， ... public final Integer code; public final String display; CourseWareTypeEnums(Integer code, String display) &#123; ... &#125;&#125; 架构方面唉，看到架构这两个字别被吓住，我讲的是常见的三层架构。通常意义上三层架构将业务划分为:表现层、业务逻辑层、数据访问层，（Controller -&gt; Service -&gt; Dao）,区分层次的目的即为了“高内聚，低耦合”的思想。那么见过五层架构吗？我见过，Controller -&gt; 属于Controller 的 service -&gt; 业务的service -&gt; Manager -&gt; dao, 想想写代码多走两个大层级有多麻烦，业务也没有特别复杂，而且还是使用springCloud的框架。两层service，pom依赖都不好区分管理,更何况多出一层manager没起什么作用，只让我觉得这个架构搭建者是不是按照五层网络协议来设计。 在Controller层，接口接收json对象主要使用 @RequestBody接收请求体里面的数据，而 @RequestParam接收的是key-value里面的参数。不知道为什么对Map情有独钟，可能是欠Map的债。传入的参数还得再转换一遍，性能不说，写代码都嫌麻烦。12//以下是示范 public CommonResult xxx(@RequestBody Map&lt;String, String&gt; body, @RequestParam Map&lt;String, String&gt; parameter) 虽然使用mybatis，但是为了快速业务开发，一般都会有通用的curd方法，比如MybatisPlus很多强大的功能，提供了分页插件、条件构造器、sql注入器等。mybatis-plus可谓是站在巨人的肩膀上进行了一系列的创新，可是总有人要自己写。自己写个框架没有问题，但是你不能搭的太没有水平。通用curd没有通过反射来，而是通过自动生成xml文件配置，当表字段修改，得重新生成xml文件，意味着xml如果写自定义标签，发生表变动就变得麻烦。 还是让我觉得服气的是分页查询做了自定义字段查询$构造拼接的条件，不怕sql注入攻击。 pojo对象有bo,vo,dto等，但是看到只有一个Dto承载了业务以及展示，让我觉得不觉得还不如直接用实体对象。","categories":[{"name":"代码","slug":"代码","permalink":"https://lukeyli.github.io/categories/代码/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://lukeyli.github.io/tags/规范/"},{"name":"业务","slug":"业务","permalink":"https://lukeyli.github.io/tags/业务/"}]},{"title":"redis","slug":"redis","date":"2020-03-14T07:59:02.000Z","updated":"2020-03-15T15:14:29.853Z","comments":true,"path":"2020/03/14/redis/","link":"","permalink":"https://lukeyli.github.io/2020/03/14/redis/","excerpt":"","text":"总结一下redis缓存，使用方面分为注解和redisTemplate两种方式。 数据结构redis有五种数据结构分别是：String, List, Hash, Set, Sorted Set 1.使用哈希表、列表及集合时，尽量不要使用big data及添加过多的数据，因为这样会导致存储结构从ziplist变为hash table、linkedlist等空间占用更大的数据结构2.如无必要的情况下，一个集合中不要将string和int混合存储，这会导致内存占用变大3.String不要过长，小于39字符时，使用embstr编码格式，占用更少内存4.set可以用来做数据运算，如交、并等大量数据的运算 String String数据结构是简单的Key-Value类型，value不仅可以是String, 也可是数字（数字类型为Long时候，encoding为整型，其他都存储在 sdshdr 当做字符串）。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。 常规计数：微博数，粉丝数等。12345SET key value 设置key=valueGET key 获得键key对应的值GETSET key value 设置键的字符串值，并返回旧值MGET key1 [key2 ...] 得到所有的给定键的值SETNX key value 设置键的值，只有当该键不存在 list类型 当列表中的object数量小于512个时，redis使用ziplist这种占用空间更小的结构 redis的list类型其实就是每个元素都是String类型的双向链表。我们可以从链表的头部和尾部添加或者删除元素。这样的List既可以作为栈，也可以作为队列使用。 123+ lpush --- 在key对应的list的头部添加一个元素+ lrange --- 获取key对应的list的指定下标范围的元素，-1表示获取所有元素。+ lpop --- 从key对应的list的尾部删除一个元素，并返回该元素。 HashHash是一个String类型的field和value之间的映射表，即redis的hash数据类型key(hash表名称)对应的value实际的内部存储结构为一个HashMap,因此Hash特别适合存储对象。相当于把一个对象的每个属相存储为String类型，将整个对象存储在hash类型中会占用更少内存。redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。（存储、读取、修改用户属性）当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的Hashmap，此时encoding为ht. 应用场景：用一个对象来存储用户信息，商品信息，订单信息等等。123hset --- 设置key对应的hashMap中的field的valuehget --- 获取key对应的hashMap中的filed的valuehgetall --- 获取key对应的HashMap中的所有field的value Set集合当一个set中全是数字时，采用intset为底层，占用空间小，因为尽量不要把少数string和大量int存储在一个set里Redis集合(set类型)是一个无序的String类型数据的集合，类似List的一个列表，与List不同的是Set不能有重复的数据。实际上，Set的内部是用HashMap实现的，Set只用了HashMap的key列来存储对象。 集合有取交集、并集、差集等操作，因此可以求共同好友、共同兴趣、分类标签等123sadd --- 在key对应的set中添加一个元素smembers --- 获取key对应的set的所有元素spop --- 随机返回并删除key对应的set中的一个元素 SortSetSortSet顾名思义，是一个排好序的Set，它在Set的基础上增加了一个顺序属性score，这个属性在添加修改元素时可以指定，每次指定后，SortSet会自动重新按新的值来旭。使用场景：如按时间排序的时间轴1.带有权重的元素，比如一个游戏的用户得分排行榜2.比较复杂的数据结构，一般用到的场景不算太多 注解的支持Spring为我们提供了主键来支持Spring Cache, 主要核心对某个方法进行缓存，其实质就是缓存该方法的返回结果，并把方法参数和结果用键值对的方式存放到缓存中，当再次调用该方法使用相应的参数时，就会直接从缓存里面取出指定的结果进行返回。 @EnableCaching该注解主要用于开启基于注解的缓存功能。ps:在SpringBoot中使用SpringCache可以由自动配置功能来完成CacheManager的注册，SpringBoot会自动发现项目中拥有的缓存系统，而注册对应的缓存管理器，也可以手动指定。1234567891011121314151617181920212223@EnableCaching@Configurationpublic class CacheConfig &#123; @Bean public CacheManager cacheManager() &#123; SimpleCacheManager cacheManager = new SimpleCacheManager(); cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(&quot;default&quot;))); return cacheManager; &#125;&#125;//等价于&lt;beans&gt; &lt;cache:annotation-driven/&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.SimpleCacheManager&gt; &lt;property name=&quot;caches&quot;&gt; &lt;set&gt; &lt;bean class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&gt; &lt;property name=&quot;name&quot; value=&quot;default&quot;/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 源码解析：12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching &#123; // 用于设置使用哪种代理方式，默认为基于接口的JDK动态代理（false）， // 设置为true，则使用基于继承的CGLIB动态代理 boolean proxyTargetClass() default false; // 用于设置切面织入方式(设置面向切面编程的实现方式)， // 默认为使用动态代理的方式织入，当然也可以设置为ASPECTJ的方式来实现AOP AdviceMode mode() default AdviceMode.PROXY; // 用于设置在一个切点存在多个通知的时候各个通知的执行顺序，默认为最低优先级， // 其中数字却大优先级越低，这里默认为最低优先级，int LOWEST_PRECEDENCE = // Integer.MAX_VALUE;，却是整数的最大值 int order() default Ordered.LOWEST_PRECEDENCE;&#125;public enum AdviceMode &#123; PROXY, ASPECTJ&#125;public interface Ordered &#123; int HIGHEST_PRECEDENCE = Integer.MIN_VALUE; int LOWEST_PRECEDENCE = Integer.MAX_VALUE; int getOrder();&#125; 由上面的源码可以看出，缓存功能是依靠AOP来实现的。 类内部的方法调用类内部的缓存方法不会走代理，不会走代理，就不能正常创建缓存，所以每次都需要去调用数据库。 @Cacheable可以指定三个属性：value、key、condition。value 指定Cache名称，value值是必须指定。其表示该方法缓存的返回结果是被缓存在哪个Cache上的，对应Cache的名称。 @CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。 allEntries是表示是否需要清除缓存中所有的元素。beforeInvocation清除操作默认是在方法成功执行之后触发的。使用beforeInvocation可以改变触发清除操作的时间，当我们设置为true时，Spring会在调用该方法之前进行缓存的清除。 @CachePut会清除对应的key值得缓存(或者更新)(1) 如果返回值null，下次进行该key值查询时，还会查一次数据库，此时相当于 @CacheEvict注解;(2) 如果返回值不为null，此时会进行该key值缓存的更新，更新缓存值为返回的数据； @Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关注解，其中拥有属性：cacheable、put、evict。 redisTemplateRedisTemplate是Spring Data Redis提供给用户的最高级的抽象客户端，用户可直接通过RedisTemplate进行多种操作spring-data-redis的提供了如下:1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类2.进行了归类封装,将同一类型操作封装为operation接口12345678ValueOperations：简单K-V操作SetOperations：set类型数据操作ZSetOperations：zset类型数据操作HashOperations：针对map类型的数据操作ListOperations：针对list类型的数据操作``` 3.提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations： BoundValueOperationsBoundSetOperationsBoundListOperationsBoundSetOperationsBoundHashOperations1234.将事务操作封装，有容器控制。5.针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer) 1.JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。 2.StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“newString(bytes,charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。 3.JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。 4.OxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】 ```","categories":[{"name":"缓存","slug":"缓存","permalink":"https://lukeyli.github.io/categories/缓存/"}],"tags":[]},{"title":"支付与对账","slug":"支付流程","date":"2020-03-04T12:26:40.000Z","updated":"2020-03-05T16:04:32.693Z","comments":true,"path":"2020/03/04/支付流程/","link":"","permalink":"https://lukeyli.github.io/2020/03/04/支付流程/","excerpt":"","text":"最近在敲商品项目，归纳总结流程以及开发。购物下单的流程创建订单的流程 开始支付微信支付1.生成二维码(1) 根据商户订单id和用户id查询订单的详情(2) 从redis中去获得这笔订单的微信支付二维码，如果订ding单状态没有支付没有就放入 ps这样的做法防止用户频繁刷新而调用微信接口(3) 生成预付单（自己的平台需要和微信进行支付交易生成的一个微信订单，称之为“预付单”），验签，调用微信统一下单地址，将生成的二维码地址放入缓存。2.支付成功，回调支付通知(1) 获取支付结果，支付成功，支付中心更新订单状态，并通知用户端更新订单信息。(2)// 通知微信已经收到消息，不要再给我发消息了，否则微信会10连击调用本接口 支付宝支付1.根据商户订单id和用户id查询订单的详情2.初始化AlipayClient设置请求参数returnUrl（页面跳转同步通知页面路径），NotifyUrl（服务器异步通知页面路径）3.alipayRequest.setBizContent，请求参数可查阅【电脑网站支付的API文档-alipay.trade.page.pay-请求参数】章节4.alipayClient.pageExecute()5.支付成功后的支付宝异步通知(1)获取支付宝POST过来反馈信息(2) 调用SDK验证签名,验证成功。支付中心更新订单状态，并通知用户端更新订单信息。 对账支付完，总不能不管系统有没用出错。对账，可以发现渠道方与我方交易中的差异。根据差异的不同，再做具体的操作。 对账系统1.01.系统自动从渠道下载对账单2.查询系统交易流水3.以渠道对账单为准，对比本地的支付交易流水4.保存对账差异、对账结果。 细分:(1) 使用导入脚本，将渠道方对账单csv文件批量入库。 步骤表记录 + 1(2) 将订单表与渠道表对账的字段跑批至中间表。 步骤表记录 + 1(3) 在两张中间表内进行批量差错对比处理对比，保存结果进差错表。 步骤表记录 + 1(4) 更新主表状态，差错处理。 步骤表记录 +利用定时脚本，定时跑批，调用存储过程，无需浪费连接。缺点：数据库压力过大，数据库日志过多，不好维护，阅读性差等等。 对账系统2.0利用redis的set结构交集特性，可快速完成对账处理。将所有历史差异都查询出来重新对账，避免漏单。1.存入两个set,以订单号,金额等其他信息组合成string为value,存储至redis。key必须使用{}形式来指定，使我们要比对的集合都处于同一slot。2.利用redis的set集合取交集，将差异入库。弊端1.对账过程中所有链路都是同步调用，数据量过大的情况下导致RPC调用超时。2.渠道对账单中的数据存储至数据库中，量大的情况下，会导致数据插入耗时较长，且有大量RPC调用。 对账3.0引入MQ, 将差异数据信息发送MQ消息，进入差错处理流程","categories":[{"name":"支付与对账","slug":"支付与对账","permalink":"https://lukeyli.github.io/categories/支付与对账/"}],"tags":[{"name":"支付","slug":"支付","permalink":"https://lukeyli.github.io/tags/支付/"},{"name":"对账","slug":"对账","permalink":"https://lukeyli.github.io/tags/对账/"}]},{"title":"随笔","slug":"第一个日志","date":"2020-02-29T14:52:53.000Z","updated":"2020-03-22T06:39:37.590Z","comments":true,"path":"2020/02/29/第一个日志/","link":"","permalink":"https://lukeyli.github.io/2020/02/29/第一个日志/","excerpt":"","text":"工作感受&emsp;&emsp;人还是需要不断去记录，发现自己的不足，吾日三省吾身，为人谋而不忠乎？与朋友交而不信乎？传不习乎？ 第一家&emsp;&emsp;自从毕业后，意义上第一家公司干了8个月离职，按月来算的工作经历跟大多数人相比，刚毕业不久的我，工作时长显得短。那是一家初创型公司，这家小团队是从福州的一家大公司跳出来的管理层，业务的话，主要为江苏农商行服务(当初面试的时候，说做自己的金融产品)。当初刚毕业不久的自己，冲着做自己的金融产品，能受到更多的成长就毫不犹豫。&emsp;&emsp;在那家公司，工作氛围还不错，技术问题问师父，还能讨教一二，还是很感谢师父能和我一起讨论问题，分享技术，要求我们的代码规范。工作安排也还好，规划好时间和事件，平常自己和同事一起到晚上七八点走路回去，周六日有时自己主动去公司加班减少平常的工作量，一起学习进步。而且后来带了一个实习生，教他做项目，算第一个徒弟。那这样的生活，不看待遇的话，还是挺好的，为什么会离职呢？&emsp;&emsp;在那家过的第一个年，发了一千块的永辉购物卡，跟其他同学比的待遇，内心的os不平衡（说好的内推奖金也没有给我），但是自己工作经验还是没有多想什么。领导打的鸡血是我们绩效很好，初创第一年就赚了几百万，第二年现在已经几百万的合同，目标一千万稳当，你们第一批按骨干核心培养，以后就可以分股权。这个鸡血，我还是很理智的没喝，就想着你还不如给我涨工资，或者改善待遇。&emsp;&emsp;真正心塞的是，在让我出差的时候，说出差去江苏银行那边学习业务后，回来做产品，一个月后就可以回来。到那边后，接手不知道几手的老项目，上家公司不合作了的项目，我以为是师父和我一起啃，结果他去其他地方负责原来的东西。数据库表命名中英文混杂，还没有自己的测试环境，本地不能跑，没人懂业务懂技术，一个人还负责银行业务沟通，还说带带银行技术部的新人来一起学习，内心真滴无语。而且还没有在附近租个地方，每天走20分钟的路程去酒店，还很难洗衣服洗鞋子（衣服没地方晒，真滴烦），真的很不方便。嘿嘿，扛着压力，到临近端午的时候说可以回去，真的有解脱的感觉，自己买票顺道去江西找同学嗨皮。被告知当天得先回公司，不然按请假处理（之前说出差路程来回算自己的时间，按带薪假），并且不是直接回福州的票居然不报销。不报销加扣一天工资，让我这个不迟到不早退过的人，没有请过假的人，这顿操作心塞，。&emsp;&emsp;端午后过去上班的时候，找我聊说涨薪，说公司业绩很好，前途无量，我表现的很好，一年给你涨一次薪水，这次提拔你涨百分之二十（一千块），接下来好好表现。原本说的是一年两次调薪，真滴很不爽啊，一年顶多涨20%，还画大饼，然后跟我说，下礼拜还要去江苏宿迁出差，长期。被人当傻子一样欺骗，觉得自己的价值以及智商受到了侮辱， 没有福利，没有年终，天天说赚了多少钱，涨薪还这样虚头巴脑。 裸辞后&emsp;&emsp;刚裸辞后的我，有点小迷茫，像极了刚被解放的小羔羊，不知所措。当时的规划是，下份工作能在亲戚附近或朋友附近，那样的生活就很稳定充实。可是现实哪有那么简单，在BOSS直聘上，福州的公司当时招聘就没有多少家，又瞅了一下工作要求，就是外包人员，内心那个惆怅。投了简历，有的人事，读了压根不理人;还有的人事，找你收了简历后就没有任何回音;甚至还有的人事是帮其他家公司招聘。刚才第一个月就面了一家还是没面上的我，真的觉得有点烦。第二个月的时候，干脆连外包一起投了去增加面试经验，有一家大外包的子外包都找过两三次（当时看公司名字都不一样），还有一家要求不仅你前后端都负责, 复试的时候才跟我说只能开4k等等。。。真的很让我怀疑程序员这行业是不是大白菜了。直到第三个月，有一家离朋友近些，又不是外包，还有好看的人儿，尽管因为时间间隔，被压低了薪资。 第二家&emsp;&emsp;生活就不会那么容易。新进的这家做教育产品，刚进来接收产品，发现有这么几点清奇的点，一、发现代码规范清奇。枚举字段不在代码中定义枚举，各种数字。二、接口文档不用swagger, 用eolinker，每次的接口都要postman测一遍，手动输入进eolinker，下次修改接口的时候又得改一遍，极其麻烦。三、虽然使用springCloud微服务，但是感觉项目就是大杂烩，有两个系统糅一起，有basic项目放业务表以及代码。四、 controllor接收参数,(@RequestBody Map body, @RequestParam Map parameter），body控制参数，parameter传入用户参数，返回参数大多数还有object的，控制层看输入输出就麻烦，更何况还要多转换为实体对象一次。五、一般是controller层-&gt;service-&gt;dao,这家不走寻常路，boot下的contoller-&gt;service-&gt;再到core底下的service-&gt;manager-&gt;dao层，mybatis的xml文件不能写，如果表结构修改，意味着要覆盖xml文件(这套还不如用MybatisPlus)，会把原来select的语句弄掉麻烦。相当于砍了mapper自定义 @Select等标签看sql实在是很不直观。自己的baseMapper连selectOne，按条件delete等都木有啊。六、从不安排什么时候完成，却会在周五晚上的时候，说周六日加个班。七、程序的安全性以及性能从不考虑。八、还有个奇怪的值班制度，会给每个人排班，一个月中大概有一天是你负责晚上关门早上开门，因为他们的门是玻璃指纹，我还是很服气这种。&emsp;&emsp;部门的同事还是可爱的，新来的UI小姐姐，产品小哥哥，老同事们，当然还有新新的我，还是很有爱，产品小哥哥还想改善一下部门原来沉闷的氛围。可惜了，新来的UI走了，IOS开发已经提交申请，让尽快招下个IOS开发，产品经理跟我表达等疫情过去离开，安卓开发的小哥哥也快了的感觉。这个时候，我的感想是，我居然还没提辞呈，嘿嘿，不过我感觉我也快了，没有上升空间（上面就一个java开发主管, 怎么升级打怪兽）。其实理想中的生活状态是，上班离住所近，能步行到公司最好了（当然如果附近有朋友就更好了），最好在福建（父母在福建），项目赶的话平时加班工作，周六日美美的睡一觉，通通快快的刷剧或者学习。&emsp;&emsp;经历后才发现自己，很大不足的是证明自己的价值体现方式。对知识的输入，却没有去总结输出。努力奋斗吧少年，不管你想怎么样，唯一的保持不变的真理是，不断改善自己的学习方式，不断去提升自己。哈哈哈，进现在这家公司可能为了小姐姐(可是看上的小姐姐都离职了)，职业发展上升空间和待遇让我感觉，如果还受气的话，很不值当。唉，我也想好好干下去，希望如果我真滴离职的话，运气好些，待个三五年，做个领导哈哈哈。","categories":[{"name":"diary","slug":"diary","permalink":"https://lukeyli.github.io/categories/diary/"}],"tags":[]},{"title":"java对象","slug":"java对象","date":"2020-02-18T15:21:50.000Z","updated":"2020-02-20T14:29:41.187Z","comments":true,"path":"2020/02/18/java对象/","link":"","permalink":"https://lukeyli.github.io/2020/02/18/java对象/","excerpt":"","text":"学java的时候,大家都知道Java是面向对象的语言，可是这个对象包含哪些东西，怎么组成的，并没有多少人提出疑问。 Java对象保存在内存中，由三部分组成：1.对象头2.实例数据3.对齐填充字节 对象头对象头由三部分组成1.Mark Work2.指向类的指针3.数组长度（只有数组对象才有） Mark WordMark Word记录了对象和锁有关的信息。当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。64位的JVM 锁状态为31bit,两块未使用的分别为25bit和1bit,其他都一样大小。其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。 JDK1.6以后的版本在处理同步锁时存在锁升级的概念.JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈。处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。 锁的升级过程JVM使用锁和Mark Word: 当没有被当成锁时，这就是一个普通的对象， Mark Word记录对象的HashCode,锁标志位是01,是否偏向锁那一位是0。 当对象被当成同步锁并有一个线程抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。 当线程A再次试图获得这个锁，JVM发现同步锁的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。 当线程B试图获得这个锁，JVM发现这个同步锁处于偏向状态，但是Mark Word的线程id记录的不是B，（偏向锁不会主动释放因此还是存储的线程A的threadID）,那么线程B会先用CAS操作试图获得锁，这里的获得锁操作有可能成功的（查询记录线程A是否存活，如果没有存活，锁对象将被重置为无锁状态，即其他线程（线程B）竞争设置为偏向锁）。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。 偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。6.轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。7.自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。 指向类的指针该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。Java对象的类数据保存在方法区。 数组长度只有数组对象保存了这部分数据该数据在32位和64位JVM中长度都是32bit。 实例数据对象的实例数据就是在java代码中能看到的属性和他们的值。 对齐填充字节因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。s","categories":[{"name":"java","slug":"java","permalink":"https://lukeyli.github.io/categories/java/"}],"tags":[{"name":"java对象头","slug":"java对象头","permalink":"https://lukeyli.github.io/tags/java对象头/"},{"name":"Mark Word","slug":"Mark-Word","permalink":"https://lukeyli.github.io/tags/Mark-Word/"}]},{"title":"java的各种锁","slug":"java的各种锁","date":"2020-02-03T15:07:56.000Z","updated":"2020-02-21T14:56:18.101Z","comments":true,"path":"2020/02/03/java的各种锁/","link":"","permalink":"https://lukeyli.github.io/2020/02/03/java的各种锁/","excerpt":"","text":"Java按照是否对资源加锁分为乐观锁和悲观锁，不是真实的锁，而是一种设计思想。 悲观锁悲观锁的思想是，它总认为最坏的情况可能会出现，它认为数据可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 资源 或者 数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。 Java中的 Synchronized 和 ReentrantLock 等独占锁（排他锁）也是一种悲观锁思想的实现，因为Synchronzied 和 ReetrantLocal不管是否持有资源，它都会尝试去加锁。 乐观锁乐观锁的思想与 悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案一般来说有两种：版本号机制 和 CAS实现。乐观锁多适用于多读的应用类型，以提高吞吐量。 Java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的， 悲观锁的使用场景悲观锁不仅会对写操作加锁还会对读操作加锁。1select * from student where name = &quot;a&quot; for update 这条sql语句从Student表中选取name = “a”的记录并对其加锁，那么其他写操作在这个事务提交之前都不会对这条数据进行操作，起到了独占和排他的作用。 悲观锁因为对读写都加锁，所以它的性能比较低。对于现在互联网提倡(高性能、高可用、高并发)来说，悲观锁的实现用的越来越少，但是一般多读的情况下还是需要使用悲观锁的，因为虽然加锁的性能比较低，但是也组织了像乐观锁一样，遇到写不一致的情况下一直重试的时间。 乐观锁的使用场景相对悲观锁而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。 乐观锁的适用场景，典型的比如成本系统，柜员要对一笔金额做修改，为了保证数据的准确性和实效性，使用悲观锁锁住某个数据后，再遇到其他需要修改数据的操作，那么此操作就无法完成金额的修改，对产品来说是灾难性的一刻，使用乐观锁的版本号机制就能够解决这个问题。 乐观锁的实现方式乐观锁一般有两种实现方式：采用版本号机制 和 CAS（Compare-and-Swap，即比较并替换）算法实现。 版本号机制版本号机制是在数据表中加上一个 version 字段来实现的，表示数据被修改的次数，当执行写操作并且写入成功后，version = version + 1，当线程A要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。 以账户存入取出为例子理解这个过程： 账户表数据表有两个字段分别是金额和version, 金额的属性是能实时变化，而version 表示的是金额每次发生变化的版本，一般的策略是，当金额发生改变时，version 采用递增的策略每次都在上一个版本号的基础上 + 1。假如这个人的存款有100元钱 开启事务一：当户主执行存200元钱写入操作，先读账户表还有多少钱，此时为100元，可以执行写操作，并把数据库中的钱更新为 300 元，提交事务。账户表的钱由100 -&gt; 300,version的版本号由 0 -&gt; 1。 开启事务二：后面户主做了发型，消费了100元，需要先执行读请求，查看金库中的钱还有300元，此时的版本号是1，然后从账户消费掉，提交事务。账户表的钱由300 -&gt; 200，此时版本由 1 -&gt; 2。 上面两种情况是最乐观的情况，上面的两个事务都是顺序执行的，也就是事务一和事务二互不干扰，那么事务要并行执行会如何呢？ 事务一开启，户主先执行读操作，读取100元金额和版本号0，执行写操作，将存款更新为30012beginupdate 表 set 金额 = 300,version = version + 1 where 金额 = 100 and version = 0 此时金额改为 120，版本号为1，事务还没有提交事务二开启，户主先执行读操作，读取100元金额和版本号0，执行写操作，12begin update 表 set 金额 = 0,version = version + 1 where 金额 = 100 and version = 0 此时金额改为 0，版本号变为 1，事务未提交 现在提交事务一，金额为300，版本变更为1。事务二的更新建立再版本0上，将会重新读取操作。 CAS场景经典并发问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Counter &#123; int count = 0; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public void add()&#123; count += 1; &#125; public void dec()&#123; count -= 1; &#125;&#125;public class Consumer extends Thread&#123; Counter counter; public Consumer(Counter counter)&#123; this.counter = counter; &#125; @Override public void run() &#123; for(int j = 0;j &lt; Test.LOOP;j++)&#123; counter.dec(); &#125; &#125;&#125;public class Producer extends Thread&#123; Counter counter; public Producer(Counter counter)&#123; this.counter = counter; &#125; @Override public void run() &#123; for(int i = 0;i &lt; Test.LOOP;++i)&#123; counter.add(); &#125; &#125;&#125;public class Test &#123; final static int LOOP = 1000; public static void main(String[] args) throws InterruptedException &#123; Counter counter = new Counter(); Producer producer = new Producer(counter); Consumer consumer = new Consumer(counter); producer.start(); consumer.start(); producer.join(); consumer.join(); System.out.println(counter.getCount()); &#125;&#125; 测试结果不都为0，出现了并发数据不一致的问题，原因是count -= 1 和 count+= 1 执行步骤分为三步: 从内存中读取count的值，把他放入寄存器中 执行 + 1 或者 -1 的操作 执行完成的结果再复制到内存中如图线程A,线程B同时读取count的值，两边都+1，结果会是1，与实际预期2不符合。保证原子性，必须加锁，使用Synchronzied 或者 ReentrantLock，它们是悲观锁的实现。CAS定义CAS 即 compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization CAS中涉及的三个要素1.需要读写的内存值V2.进行比较的值A3.拟写入的新值B当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 乐观锁的缺点ABA问题ABA 问题说的是，如果一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？可以是由 A -&gt; B -&gt; A 的这种情况，但是 AtomicInteger 却不会这么认为，它只相信它看到的，它看到的是什么就是什么。 JDK 1.5 以后的 AtomicStampedReference类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 也可以采用CAS的一个变种DCAS来解决这个问题。DCAS，是对于每一个V增加一个引用的表示修改次数的标记符。对于每个V，如果引用修改了一次，这个计数器就加1。然后再这个变量需要update的时候，就同时检查变量的值和计数器的值。 循环开销大乐观锁在进行写操作的时候会判断是否能够写入成功，如果写入不成功将触发等待 -&gt; 重试机制，这种情况是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期获取不到锁的情况，另外，自旋循环对于性能开销比较大。 CAS与synchronized的使用情景简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多） 对于资源竞争较少（线程冲突较轻）的情况，使用 Synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。 对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。 自旋锁同一时刻只能有一个线程获取到锁。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？通常有两种处理方式：1.没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁2.把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。 SpinLock12345678910111213141516171819202122public class SpinLock &#123; private AtomicBoolean available = new AtomicBoolean(false); public void lock() &#123; // 循环检测尝试获取锁 while (!tryLock()) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;再次尝试获取锁&quot;); &#125; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;获取到锁&quot;); &#125; public boolean tryLock()&#123; // 尝试获取锁，成功返回true，失败返回false return available.compareAndSet(false,true); &#125; public void unLock() &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;解锁&quot;); if (!available.compareAndSet(true, false)) &#123; throw new RuntimeException(&quot;释放锁失败&quot;); &#125; &#125;&#125; 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。 这个例子的自旋锁无法保证多线程竞争的公平性，即无法满足等待时间最长的线程优先获取锁，会造成某些线程一直都未获取到锁造成线程饥饿。类似解决线程饥饿，将采取排队的方式解决该问题。排队自旋锁，如TicketLock，MCSLock，CLHLock。 TicketLock1234567891011121314151617181920212223public class TicketLock&#123; // 服务号 private AtomicInteger serviceNum = new AtomicInteger(); // 排队号 private AtomicInteger ticketNum = new AtomicInteger(); //获取锁。如果成功，返回当前线程的排队号 public int lock() &#123; // 首先原子性地获得一个排队号 int myTicketNum = ticketNum.getAndIncrement(); System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 加入排队,排队号:&quot; + myTicketNum + &quot;距离就餐号码：&quot; + serviceNum.get()); while (myTicketNum != serviceNum.get()) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;在排队，号码为：&quot; + myTicketNum + &quot;等待号码：&quot; + serviceNum.get()); &#125; return myTicketNum; &#125; //释放锁,传入当前 public void unlock(int myTicket) &#123; // 只有当前线程拥有者才能释放锁 serviceNum.compareAndSet(myTicket, myTicket + 1); System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;已消费完,下个就餐号码：&quot; + serviceNum.get()); &#125;&#125; 上面获取自己的号码，可以对号码进行更改，这样会造成紊乱，锁不能及时释放。需要一个确保每个人按照自己的号码排队办业务的角色12345678910111213141516171819202122232425262728public class TicketLock2 implements Lock &#123; // 服务号 private AtomicInteger serviceNum = new AtomicInteger(); // 排队号 private AtomicInteger ticketNum = new AtomicInteger(); private ThreadLocal&lt;Integer&gt; ticketLocal = new ThreadLocal&lt;&gt;(); //获取锁。如果成功，返回当前线程的排队号 @Override public void lock() &#123; // 首先原子性地获得一个排队号 int myTicketNum = ticketNum.getAndIncrement(); ticketLocal.set(myTicketNum); System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;加入排队,排队号:&quot; + myTicketNum + &quot;距离就餐号码：&quot; + serviceNum.get()); while (myTicketNum != serviceNum.get()) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;在排队，号码为：&quot; + myTicketNum + &quot;等待号码：&quot; + serviceNum.get()); &#125; &#125; //释放锁,传入当前 @Override public void unlock() &#123; // 只有当前线程拥有者才能释放锁 Integer currentTicket = ticketLocal.get(); serviceNum.compareAndSet(currentTicket, currentTicket + 1); System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;已消费完,下个就餐号码：&quot; + serviceNum.get()); &#125;&#125; 缺点 在多处理器上，每个进程/线程占用的处理器都在读写同一个变量queueNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。为解决这个问题，MCSLock 和CLHLock应运而生。 CLHLockCLH 是一种基于链表的可扩展，高性能，公平的自旋锁，申请线程只能在本地变量上自旋，它会不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。1.公平，FIFO，先来后到的顺序进入锁2.而且没有竞争同一个变量，因为每个线程只要等待自己的前继释放就好了。3.空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。 适合CLH在SMP系统结构下。缺点： 在NUMA系统架构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，解决NUMA系统结构的思路是MCS队列锁。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647![](JAVA各种锁/CLHLock.jpg)public class CLHLock implements Lock &#123; public static class CLHNode&#123; private volatile boolean isLocked = true; &#125; //尾部节点 private volatile CLHNode tail; private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;(); private static final AtomicReferenceFieldUpdater&lt;CLHLock,CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class,CLHNode.class,&quot;tail&quot;); @Override public void lock()&#123; CLHNode node = new CLHNode(); LOCAL.set(node); // 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点 CLHNode preNode = UPDATER.getAndSet(this, node); if(preNode != null) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;需要排队吗?&quot; + preNode.isLocked + &quot;，tail:&quot; + tail.isLocked ); // 前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁 while (preNode.isLocked) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;还在排队&quot; ); &#125; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;不需要排队了，后面的人别插队：&quot; + tail.isLocked ); preNode = null; LOCAL.set(node); &#125; else &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;前面没人，我还没吃，后面的人别插队&quot; + tail.isLocked ); &#125; // 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁 &#125; @Override public void unlock() &#123; // 获取当前线程对应的节点 CLHNode node = LOCAL.get(); System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;用完餐了，节点值：&quot; + node.isLocked); // 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态职位false，表示当前线程释放了锁 if (!UPDATER.compareAndSet(this, node, null)) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;开始叫下一位&quot; + tail.isLocked); node.isLocked = false; &#125; node = null; &#125;&#125; MCSLockMSC与CLH最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同: CLH是在前趋结点的locked域上自旋等待，而MCS是在自己的结点的locked域上自旋等待。 具体实现：前驱节点在释放锁之后，会主动将后继节点的locked域更新。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MCSLock implements Lock &#123; public static class MCSNode &#123; volatile MCSNode next; volatile boolean isLocked = true; &#125; private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;&gt;(); //队列 private volatile MCSNode queue; private static final AtomicReferenceFieldUpdater&lt;MCSLock,MCSNode&gt;UPDATE = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class,MCSNode.class,&quot;queue&quot;); @Override public void lock() &#123; //创建节点并保存到ThreadLocal中 MCSNode currentNode = new MCSNode(); NODE.set(currentNode); //将queue设置为当前节点，并且返回之前的节点 MCSNode preNode = UPDATE.getAndSet(this, currentNode); if (preNode != null) &#123; // 如果之前节点不为null，表示锁已经被其他线程持有 preNode.next = currentNode; // 循环判断，直到当前节点的锁标志位为false while (currentNode.isLocked) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;还在排队&quot;); &#125; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;轮到我了&quot;); &#125; else &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;哈哈，不用排队，美滋滋&quot;); &#125; &#125; @Override public void unlock() &#123; MCSNode currentNode = NODE.get(); // next为null表示没有正在等待获取锁的线程 if (currentNode.next == null) &#123; // 更新状态并设置queue为null if (UPDATE.compareAndSet(this, currentNode, null)) &#123; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;后面没人排队了&quot;); // 如果成功了，表示queue==currentNode,即当前节点后面没有节点了 return; &#125;else &#123; // 如果不成功，表示queue!=currentNode,即当前节点后面多了一个节点，表示有线程在等待 System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;后面又来一个排队着呢&quot;); // 如果当前节点的后续节点为null，则需要等待其不为null（参考加锁方法） while (currentNode.next == null) &#123; &#125; &#125; &#125;else &#123; // 如果不为null，表示有线程在等待获取锁，此时将等待线程对应的节点锁状态更新为false，同时将当前线程的后继节点设为null System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;后面有人排队着呢&quot;); currentNode.next.isLocked = false; currentNode.next = null; &#125; &#125;&#125; synchronizedsynchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级锁,这几个状态会随着竞争状态逐渐升级，锁可以升级但不能降级，但是偏向锁状态可以被重置为无锁状态 Monitorsynchronized是通过对象内部的一个叫做监视器锁monitor来实现，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为重量级锁 偏向锁大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。 偏向锁的原理和升级过程当线程A访问代码并获取锁对象时，会在java对象头和栈帧中记录偏向标记和threadId。因为偏向锁不会主动释放锁，因此以后线程A再次获取锁的时候，需要比较当前线程的threadID和Java头中threadID是否一致。如果一致（还是线程A持有锁对象）,无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程B要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程A的threadID）;那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程A）的栈帧信息，如果（线程B竞争失败）还是需要继续持有这个锁对象，那么暂停当前线程A，将偏向锁升级为轻量级锁; 如果线程A不再使用该锁对象，那么将锁对象状态设置为无锁状态，重新偏向信的线程。 轻量级锁当竞争锁对象的线程不多，线程持有锁的时间也不长的情况。因为阻塞线程需要CPU从用户态转到内核态，代价太大，如果刚阻塞不久这个锁就被释放了，那么代价得不偿失了，因此这个时候干脆不阻塞这个线程，让它自旋等待锁的释放， 轻量锁的原理和升级过程线程A获取轻量级锁时会把锁对象的对象头MarkWord复制一份到线程A的栈帧中创建的用于存储锁记录的空间，然后使用CAS把对象头中的内容替换为线程A存储的锁记录的地址； 如果在线程A复制对象头的同时（在线程A CAS之前）,线程B也准备获取锁，复制了对象头道线程B的锁记录空间中，但是在线程2CAS的时候，发现线程A已经把对象头换了，线程B的CAS失败，那么线程B就尝试使用自旋锁来等待线程A释放锁。 如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程A还没有释放锁，或者线程A还在执行，线程B还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。 锁状态 优点 缺点 适用场景 偏向锁 加锁解锁无需额外的消耗,和非同步方法时间相差纳秒级别 如果竞争的线程多，那么会带来额外的锁撤销的消耗 基本没有线程竞争锁的同步场景 轻量级锁 竞争的线程不会阻塞，使用自旋，提高程序响应速度 如果一直不能获取锁，长时间的自旋会造成CPU消耗 适用于少量线程竞争锁对象，且线程持有锁的时间不长，追求响应速度的场景 重量级锁 线程竞争不适用CPU自旋,不会导致CPU空转消耗CPU资源 线程阻塞，响应时间长 很多线程竞争锁，且锁持有时间长，追求吞吐量的场景 ReentrantLockJava.util.concurrent.locks包下，它实现了Lock接口和Serializable 接口。特点：可重入锁和互斥锁，它具有与 synchronized 关键字相同的含有隐式监视器锁（monitor）的基本行为和语义，它比 synchronized 具有更多的方法和功能。 基本方法 构造方法ReentrantLock 类中带有两个构造函数，一个是默认的构造函数，不带任何参数；一个是带有 fair 参数的构造函数1234567public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 第二个构造函数也是判断 ReentrantLock 是否是公平锁的条件，如果 fair 为 true，则会创建一个公平锁的实现，也就是 new FairSync()，如果 fair 为 false，则会创建一个 非公平锁的实现，也就是 new NonfairSync()，默认的情况下创建的是非公平锁 12345678// 创建的是公平锁private ReentrantLock lock = new ReentrantLock(true);// 创建的是非公平锁private ReentrantLock lock = new ReentrantLock(false);// 默认创建非公平锁private ReentrantLock lock = new ReentrantLock(); 在多线程尝试加锁时，如果是公平锁，那么锁获取的机会是相同的。否则，如果是非公平锁，那么 ReentrantLock 则不会保证每个锁的访问顺序。 加锁流程 如果lock加锁设置成功，设置当前线程为独占锁的线程 如果lock加锁失败，还会再获取一次锁数量如果锁数量为0，再基于CAS将state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程。 如果锁数量不为0或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了，如果是，则将当前的锁数量+1；如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。","categories":[{"name":"java","slug":"java","permalink":"https://lukeyli.github.io/categories/java/"}],"tags":[{"name":"悲观锁","slug":"悲观锁","permalink":"https://lukeyli.github.io/tags/悲观锁/"},{"name":"多线程","slug":"多线程","permalink":"https://lukeyli.github.io/tags/多线程/"},{"name":"乐观锁","slug":"乐观锁","permalink":"https://lukeyli.github.io/tags/乐观锁/"}]},{"title":"Java8时间与日期API","slug":"Java8时间与日期API","date":"2020-02-03T08:49:46.000Z","updated":"2020-02-03T14:07:47.425Z","comments":true,"path":"2020/02/03/Java8时间与日期API/","link":"","permalink":"https://lukeyli.github.io/2020/02/03/Java8时间与日期API/","excerpt":"","text":"java8之前的时间和日期java.util.Date 和 java.util.Calendar 类易用性差，不支持时区，而且都不是线程安全的。 Date如果没有格式化，打印出的日期可读性差。使用SimpleDateFormat对date进行格式化。SimpleDateFormat为不安全。1234567891011121314151617181920212223242526272829303132private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // Convert input date to time field list calendar.setTime(date); boolean useDateFormatSymbols = useDateFormatSymbols(); for (int i = 0; i &lt; compiledPattern.length; ) &#123; int tag = compiledPattern[i] &gt;&gt;&gt; 8; int count = compiledPattern[i++] &amp; 0xff; if (count == 255) &#123; count = compiledPattern[i++] &lt;&lt; 16; count |= compiledPattern[i++]; &#125; switch (tag) &#123; case TAG_QUOTE_ASCII_CHAR: toAppendTo.append((char)count); break; case TAG_QUOTE_CHARS: toAppendTo.append(compiledPattern, i, count); i += count; break; default: subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols); break; &#125; &#125; return toAppendTo;&#125; 其中calendar为共享变量,并且这个共享变量没有做安全控制。当多个线程同时使用相同的 SimpleDateFormat 对象调用format方法时，多个线程会同时调用 calendar.setTime 方法，可能一个线程刚设置好 time 值另外的一个线程马上把设置的 time 值给修改了导致返回的格式化时间可能是错误的。 在并发情况使用SimpleDateFormat，parse方法也是线程不安全的。 Date对时间处理比较麻烦，比如想获取某年、某月、某星期，以及 n 天以后的时间，如果用Date来处理的话真是太麻烦了，并且 Date 类的 getYear、getMonth 这些方法都被弃用了。 多线程下，保证SimpleDateFormat线程安全 避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次 SimpleDateFormat 对象 =&gt; 创建和销毁对象的开销大。 对使用 format 和 parse 方法的地方进行加锁 =&gt; 线程阻塞性能差 使用 ThreadLocal 保证每个线程最多只创建一次 SimpleDateFormat 对象 =&gt; 较好的方法 java8 新的时间和日期APILocalDateLocalDate只会获取年月日123456789101112// 创建 LocalDate// 获取当前年月日LocalDate localDate = LocalDate.now();//获取年int year = localDate.getYear();int year1 = localDate.get(ChronoField.YEAR);Month month = localDate.getMonth();int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);int day = localDate.getDayOfMonth();int day1 = localDate.get(ChronoField.DAY_OF_MONTH);DayOfWeek dayOfWeek = localDate.getDayOfWeek();int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK); LocalTimeLocalTime 只会获取时分秒123456789101112// 创建 LocalTimeLocalTime localTime = LocalTime.of(20, 20, 20);LocalTime localTime1 = LocalTime.now();// 获取小时int hour = localTime.getHour();int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);// 获取分int minute = localTime.getMinute();int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);// 获取秒int second = localTime.getMinute();int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE); LocalDateTimeLocalDateTime 获取年月日时分秒，相当于 LocalDate + LocalTime12345678910// 创建 LocalDateTimeLocalDateTime localDateTime = LocalDateTime.now();LocalDateTime localDateTime1 = LocalDateTime.of(2020, Month.February, 3, 17, 38, 56);LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);LocalDateTime localDateTime3 = localDate.atTime(localTime);LocalDateTime localDateTime4 = localTime.atDate(localDate);// 获取LocalDateLocalDate localDate2 = localDateTime.toLocalDate();// 获取LocalTimeLocalTime localTime2 = localDateTime.toLocalTime(); InstantInstant 获取秒数，用于表示一个时间戳（精确到纳秒）如果只是为了获取秒数或者毫秒数，可以使用 System.currentTimeMillis()。123456// 创建Instant对象Instant instant = Instant.now();// 获取秒数long currentSecond = instant.getEpochSecond();// 获取毫秒数long currentMilli = instant.toEpochMilli(); DurationDuration 表示一个时间段12345678910// Duration.between()方法创建 Duration 对象LocalDateTime from = LocalDateTime.of(2020, Month.February, 3, 0, 0, 0); // 2020-02-03 00:00:00LocalDateTime to = LocalDateTime.of(2020, Month.February, 9, 0, 0, 0); // 2019-09-15 FebruaryDuration duration = Duration.between(from, to); // 表示从 from 到 to 这段时间long days = duration.toDays(); // 这段时间的总天数long hours = duration.toHours(); // 这段时间的小时数long minutes = duration.toMinutes(); // 这段时间的分钟数long seconds = duration.getSeconds(); // 这段时间的秒数long milliSeconds = duration.toMillis(); // 这段时间的毫秒数long nanoSeconds = duration.toNanos(); // 这段时间的纳秒数 时间日期的修改LocalDate、LocalTime、LocalDateTime、Instant 为不可变对象，修改这些对象对象会返回一个副本。 增加、减少年数、月数、天数等，以LocalDateTime为例:123456789101112131415LocalDateTime localDateTime = LocalDateTime.of(2020, Month.February, 3, 0, 0, 0);// 增加一年localDateTime = localDateTime.plusYears(1);localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);// 减少一个月localDateTime = localDateTime.minusMonths(1);localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS); // 通过with修改某些值// 修改年为2020localDateTime = localDateTime.withYear(2020);localDateTime = localDateTime.with(ChronoField.YEAR, 2020);// 时间计算// 获取该年的第一天LocalDate localDate = LocalDate.now();LocalDate localDate1 = localDate.with(firstDayOfYear()); 格式化时间123456LocalDate localDate = LocalDate.of(2020, 2, 3);String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);//自定义格式DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);String s3 = localDate.format(dateTimeFormatter); 解析时间12LocalDate localDate1 = LocalDate.parse(&quot;20200203&quot;, DateTimeFormatter.BASIC_ISO_DATE);LocalDate localDate2 = LocalDate.parse(&quot;2020-02-03&quot;, DateTimeFormatter.ISO_LOCAL_DATE); TemporalAdjusters 包含许多静态方法，可以直接调用. DateTimeFormatter 是线程安全的。 Instant 的精确度更高，可以精确到纳秒级。 Duration 可以便捷得到时间段内的天数、小时数等。 LocalDateTime 能够快速地获取年、月、日、下一月等。","categories":[{"name":"java","slug":"java","permalink":"https://lukeyli.github.io/categories/java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"https://lukeyli.github.io/tags/java8/"}]},{"title":"mysql表设计注意点","slug":"mysql表设计注意点","date":"2020-02-02T11:45:42.000Z","updated":"2020-02-02T12:54:39.088Z","comments":true,"path":"2020/02/02/mysql表设计注意点/","link":"","permalink":"https://lukeyli.github.io/2020/02/02/mysql表设计注意点/","excerpt":"","text":"1.设置主键在不设置主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。指定主键，显式用上主键索引，提高查询效率。 2.主键用自增比UUID更好。innodb中的主键是聚簇索引。当主键式自增的，每次插入信新的记录，记录就会顺着添加到当前索引节点的后续位置。当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分页，产生很多表碎片。 3.主键不能含有业务含义（1）因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。（2）带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。 4.表示枚举的字段用tinyint不用enum类型。（1）ENUM类型的order by 操作效率低，需要额外操作（2）如果枚举值是数值，12345CREATE TABLE a (status ENUM(&apos;0&apos;, &apos;1&apos;, &apos;2&apos;));- 此时插入一条数据INSERT INTO a values(1);- 执行后插入的status 为0INSERT INTO test VALUES (`1`) #为正确 5.货币字段最好单位应该用分，用Int类型来表示。如果坚持用元，用decimal。不能用float和double是以二元制存储，精度有误差。 6.时间字段类型(1)varchar, 优点在于显示直观。缺点在于插入数据没有校验，做时间比较运算，STR_TO_DATE将无法命中索引。(2)timestamp,该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年后的时间无法用timestamp类型存储。优势timestamp类型有时区信息的。一旦你系统中的时区发生改变，项目该字段的值发生改变。适合国际化项目，跨时区应用。(3)datetiem,datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。但是不带有时区信息，改变数据库的时区，不会发生改变。(4)bigint, 自己维护一个时间戳，自己维护，不大方便。 7.不推荐使用text和blob类型。在实际应用，用HDFS来储存文件。 8.字段定义not null。（1）Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。（2）会查询问题。count不精准 以上内容来自于孤独烟的blog:mysql表设计要注意什么","categories":[{"name":"sql","slug":"sql","permalink":"https://lukeyli.github.io/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://lukeyli.github.io/tags/mysql/"}]},{"title":"sql优化","slug":"sql优化","date":"2020-02-01T09:02:55.000Z","updated":"2020-02-02T09:42:26.326Z","comments":true,"path":"2020/02/01/sql优化/","link":"","permalink":"https://lukeyli.github.io/2020/02/01/sql优化/","excerpt":"","text":"常规索引生效优化1.避免全表，应该考虑在where及order by涉及的列上建立索引 2.NULL列使用索引。where语句中的is null或is not null的语句是不使用索引的。可设置默认值0，确保没有null值。 where 子句中使用!=或&lt;&gt;操作符，将导致全表扫描.12345- 索引无效select .. from .. where num != 100;- 索引生效#select .. from .. where num &lt; 100 or num &gt;100 select .. from .. where num &lt; 100 union all select .. from .. where num &gt; 100; 4.where子句中使用or连接条件。or在myisam能用到索引（还得是独立索引），innodb不行。如第3点替代方案union all1234- 低效select .. from .. where num = 10 or num = 20- 高效select .. from .. where num in (10,20) 5.exists 和in。子查询表小的用in, 反之用exists效率更快。取值连续用between替代。(考虑用外连接替代。再考虑外连接拆分)外查询 &gt; 内查询 in外查询 &lt; 内查询 exists 6.使用not in那么内外表都将进行全表扫描，没有用到索引。not extsts的子查询依然能用到表上的索引。 7.like %a 通配符出现在首位，无法使用索引。如果通配符非得在首位，推荐instr替代like 8.避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。12345select .. from .. where num/2 = 100 select .. from .. where year(nowdate) &lt; 2019-优化select .. from .. where num = 100*2select .. from .. where nowdate &lt; &apos;2019-01-01&apos; 9.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。复合索引参考 10.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率,因为 insert 或 update 时有可能会重建索引。一个表的索引数最好不要超过6个 11.小心隐式类型转换1234567#假设id类型为varchar- 全表扫描 select .. from .. where id = 100 - 等价于select .. from .. where CAST(id AS signed int) = 100- 走索引。如果id 是int,执行下面的语句还是会用到索引 select .. from .. where id = &apos;100&apos; 其他1.分解关联查询。12345678select * from table_a a join table_b b on b.table_id = a.id join table_c c on c.t_id = b.t_id where a.name = &apos;mysql- 分解后:select * from table_a where a.name =&apos;mysql&apos;;select * from table_b where b.table_id = 66;select * from table_c where c.t_id in (..); 好处：(1)拆分关联查询，可以缓存。(2)减少单个查询减少锁的竞争(3)在应用层做关联,可以更容易进行拆分,更容易做到高性能扩展 2.拆分大的delete或insert语句。一次性insert或delete大量数据对服务器压力很大。应分10000条，循环处理，大大降低对于服务器的影响,同事降低删除时锁的持有时间。 3.只要看一条记录，利用limit 1 、top 1 取得一行 limit分页优化当偏移量特别时，limit效率会非常低SELECT id FROM A LIMIT 1000,10 很快SELECT id FROM A LIMIT 90000,10 很慢优化后1.select id from A order by id limit 90000,10;2.select id,title from A where id&gt;=(select id from collect order by id limit 90000,1) limit 10;3.select id from A order by id between 10000000 and 10000010; 5.性能 inner join &gt; left/right join &gt; 子查询。使用jOin，用小的结果驱动大的结果 order by 排序(1）从性能上考虑,应该尽量避免排序,或者尽可能避免对大量数据进行排序.(2)尽量在主键上进行排序,因为主键会使用簇集索引(3)没有主键上排序,也请尽量在索引上排序,如果有多条排序,可以考虑组合索引,但是要注意索引的左匹配原则","categories":[{"name":"sql","slug":"sql","permalink":"https://lukeyli.github.io/categories/sql/"}],"tags":[]},{"title":"mysql索引","slug":"mysql索引","date":"2020-02-01T08:58:30.000Z","updated":"2020-02-03T03:39:02.265Z","comments":true,"path":"2020/02/01/mysql索引/","link":"","permalink":"https://lukeyli.github.io/2020/02/01/mysql索引/","excerpt":"","text":"MySQL(Innodb)索引的原理 建立索引的情况1.一张表的索引最好不超过6个，大量索引占用磁盘空间，降低insert、update、delete的性能。2.经常查询的字段创建索引，如在where子句的字段做索引。避免对经常更新的表做索引。3.索引对于数据量大的表有优化效果，数据量小没有。4.在条件表达式中经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引。比如性别字段只有“男”“女”俩个值，就无需建立索引。如果建立了索引不但不会提升效率，反而严重减低数据的更新速度5.在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引。 索引分类物理存储角度：聚簇索引和非聚簇索引 从数据结构角度：B+树索引、hash索引、FULLTEXT索引、R-Tree索引 从逻辑角度：主键索引：主键索引是一种特殊的唯一索引，不允许有空值普通索引或者单列索引多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合唯一索引或者非唯一索引空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 索引覆盖与回表查询如果一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’。即只需扫描索引而无须回表。12345- 表table1,有一个联合索引(a,b)select a,b from table1#在索引上就能找到结果，就不用回表去查询。select a,b,c from table2#c列在索引上不存在，就需要回表查询。 唯一索引 [强制] 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 唯一索引的插入速度比普通索引慢的原因原因：唯一索引无法利用Change Buffer。普通索引可以利用Change Buffer 在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；如果不在，则先放入Insert Buffer 中，然后再以一定频率和情况进行Insert Buffer和原数据页合并(merge)操作。将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。 为什么唯一索引的更新不使用Change Buffer唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。数据页都加载到内存了，直接更新内存中的数据页，没有必要再使用Change Buffer。 唯一索引的搜索速度比普通索引快的原因普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了。 mysql索引结构mysql索引存储结构和特点","categories":[{"name":"sql","slug":"sql","permalink":"https://lukeyli.github.io/categories/sql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://lukeyli.github.io/tags/索引/"}]},{"title":"RabbitMQ总结","slug":"RabbitMQ总结","date":"2020-01-29T13:45:34.000Z","updated":"2020-02-01T08:44:21.214Z","comments":true,"path":"2020/01/29/RabbitMQ总结/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/RabbitMQ总结/","excerpt":"","text":"rabbitmq流程一条消息在RabbitMQ中的流转过程： Github rabbitMQ demo地址主要流程:1.生产者发送消息的时候指定RoutingKey，然后消息被发送到Exchange2.Exchange根据一些列规则将消息路由到指定的队列中3.消费者从队列中消费消息 整个流程主要就4个参与者message，exchange，queue，consumer。 Message消息可以设置一些列属性 属性 作用 contentType 消息体的MIME类型，如application/json contentEncoding 消息的编码类型，如是否压缩 messageId 消息的唯一性标识，由应用进行设置 timestamp 消息的创建时刻，整型，精确到秒 deliveryMode 消息的持久化类型 ，1为非持久化，2为持久化，性能影响巨大 headers 键/值对表，用户自定义任意的键和值 priority 指定队列中消息的优先级 Exchange接收消息，并根据路由键转发消息到所绑定的队列，常用的属性如下 属性 作用 name 交换器名称 type 交换器类型，有如下四种，direct，topic，fanout，headers durability 是否需要持久化，true为持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息 autoDelete 与这个Exchange绑定的Queue或Exchange都与此解绑时，会删除本交换器 internal 设置是否内置，true为内置。如果是内置交换器，客户端无法发送消息到这个交换器中，只能通过交换器路由到交换器这种方式 argument 其他一些结构化参数 最常使用的就是type属性，下面就详细解释type属性 Fanout Exchange发送到该交换机的消息都会路由到与该交换机绑定的所有队列上，可以用来做广播不处理路由键，只需要简单的将队列绑定到交换机上Fanout交换机转发消息是最快的 Direct Exchange 把消息路由到BindingKey和RoutingKey完全匹配的队列中 Topic Exchange topic和direct类似，也是将消息发送到RoutingKey和BindingKey相匹配的队列中，只不过可以模糊匹配。匹配规则:1.RoutinKey为一个被“.”号分割的字符串（如com.rabbitmq.client）2.BindingKey和RoutingKey也是“.”号分割的字符串3.BindKey中可以存在两种特殊字符串“”和“#”，用于做模糊匹配，其中“”用于匹配不多不少一个词，“#”用于匹配多个单词（包含0个，1个） BingdingKey RoutingKey java.# java.lang，java.util,java.util.concurrent java.* java.lang，java.util *.*.uti com.java.util，org.spring.util 假如现在有2个RoutingKey为java.lang和java.util.concurrent的消息。如下图两个交换机java.lang会被路由到Consumer1和Consumer2，java.util.concurrent会被路由到Consumer1。 Headers Exchangeheaders类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送消息内容中的headers属性进行匹配。headers类型的交换器性能差，不实用，基本上不会使用。 Queue 属性 作用 queue 队列的名称 durable 是否持久化，true为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息 exclusive 设置是否排他，true为排他。如果一个队列被声明为排他队列，该队列仅对首次声明他它的连接可见，并在连接断开时自动删除（即一个队列只能有一个消费者） autoDelete 设置是否自动删除，true为自动删除，自动删除的前提是，至少一个消费者连接到这个队列，之后所有与这个连接的消费者都断开时，才会自动删除 arguments 设置队列的其他参数，如x-message-ttl，x-max-length arguments中可以设置的队列的常见参数如下 参数名 作用 x-dead-letter-exchange 死信交换器 x-dead-letter-routing-key 死信消息的可选路由键 x-expires 队列在指定毫秒数后被删除 x-ha-policy 创建HA队列 x-ha-nodes HA队列的分布节点 x-max-length 队列的最大消息数 x-message-ttl 毫秒为单位的消息过期时间，队列级别 x-max-priority 最大优先值为255的队列优先排序功能 HA队列，镜像队列死信交换器:当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中。消息变成死信一般是由于以下几种情况:1.消息被拒绝，井且设置 requeue 参数为 false2.消息过期3.队列达到最大长度 t2_exchange使用 交换器类型 路由规则 fanout 发送到该交换机的消息都会路由到与该交换机绑定的所有队列上，可以用来做广播 direct 把消息路由到BindingKey和RoutingKey完全匹配的队列中 topic topic和direct类似，也是将消息发送到RoutingKey和BindingKey相匹配的队列中，只不过可以模糊匹配 headers 性能差，基本不会使用 t3_拉取消息消息的获得方式有2种1.拉取消息。拉模式下，轮询，消费channel basicGet(String queue, boolean autoAck);2.推送消息。推模式下，有通知机制，通过socket推送数据的。 channel.basicConsume 那我们应该拉取消息还是推送消息？get是一个轮询模型，而consumer是一个推送模型。get模型会导致每条消息都会产生与RabbitMQ同步通信的开销，这一个请求由发送请求帧的客户端应用程序和发送应答的RabbitMQ组成。所以推送消息，避免拉取 t4_手动ack 消息的确认方式有2种 1.自动确认（autoAck = true）2.手动确认（autoAck = false） 消费者在消费消息的时候，可以指定autoAck参数 String basicConsume(String queue, boolean autoAck, Consumer callback) autoAck=false，RabbitMQ会等待消费者显示回复确认消息后才从内存（或者磁盘）中移出消息autoAck=true， RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正消费了这些消息 手动确认的方法如下，有两个参数 basicAck(long deliveryTag, boolean multiple)deliveryTag: 用来标识信道中投递的消息。RabbitMQ 推送消息给Consumer时，会附带一个deliveryTag，以便Consumer可以在消息确认时告诉RabbitMQ到底时哪条消息被确认了。RabbitMQ保证在每个信道中，每条deliveryTag从1开始递增multiple=true。消息id&lt;=deliveryTag的消息，都会被确认multiple=false. 消息id=deliveryTag的消息，都会被确认 消息一直不确认会发送啥 如果队列中的消息发送到消费者后，消费者不对消息进行确认，那么消息会一直留在队列中，直到确认才会删除。如果发送到A消费者的消息一直不确认，只有等到A消费者与rabbitmq的连接中断，rabbitmq才会考虑将A消费者未确认的消息重新投递给另一个消费者 t5_拒绝消息的两种方式 确认消息只有一种方法 basicAck(long deliveryTag, boolean multiple) 拒绝消息有两种方式 1.basicNack(long deliveryTag, boolean multiple, boolean requeue)2.basicReject(long deliveryTag, boolean requeue)basicNack和basicReject的区别只有一个,basicNack支持批量拒绝requeue=true: 消息会被再次发送到队列中requeue=false：消息会被直接丢失 t6_失败通知 当消息不能被路由到某个queue时，如何获取到不能正确路由的消息 1.在发送消息时设置mandatory为true2.生产者可以通过调用channel.addReturnListener来添加ReturnListener监听器获取没有被路由到队列中的消息 mandatory是channel.basicPublish()方法中的参数mandatory=true。交换器无法根据路由键找到一个符合条件的队列，那么RabbitMQ会调用Basic.Return命令将消息返回给生产者mandatory=false: 出现上述情形，则消息直接被丢弃 t7_发布者确认当消息被发送后，消息到底有没有到达exchange，默认情况生产者是不知道消息有没有到达exchange。 RabbitMQ针对这个问题，提供了两种解决方式 1.事务2.发布者确认 发布者确认有三种编程方式 1.普通confirm模式。每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。2.批量confirm模式。每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。3.异步confirm模式。提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。异步confirm模式性能最高。因此经常使用。12345678910channel.addConfirmListener(new ConfirmListener() &#123; @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123; log.info(&quot;handleAck, deliveryTag: &#123;&#125;, multiple: &#123;&#125;&quot;, deliveryTag, multiple); &#125; @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123; log.info(&quot;handleNack, deliveryTag: &#123;&#125;, multiple: &#123;&#125;&quot;, deliveryTag, multiple); &#125;&#125;); 写过异步confirm代码的小伙伴应该对这段代码不陌生，可以看到这里也有deliveryTag和multiple。但是我要说的是这里的deliveryTag和multiple和消息的ack没有一点关系。 confirmListener中的ack: rabbitmq控制的，用来确认消息是否到达exchange 消息的ack: 上面t4说到可以自动确认，也可以手动确认，用来确认queue中的消息是否被consumer消费 t8_备用交换器备份交换器是为了实现没有路由到队列的消息，声明交换机的时候添加属性alternate-exchange，声明一个备用交换机，一般声明为fanout类型，这样交换机收到路由不到队列的消息就会发送到备用交换机绑定的队列中。生产者在发送消息的时候如果不设置 mandatory 参数那么消息在未被路由到queue的情况下将会丢失，如果设置了 mandatory 参数，那么需要添加 ReturnListener 的编程逻辑，生产者的代码将变得复杂。如果既不想复杂化生产者的编程逻辑，又不想消息丢失，那么可以使用备用交换器，这样可以将未被路由到queue的消息存储在RabbitMQ 中，在需要的时候去处理这些消息 t9_事物rabbitMQ中与事务机制相关的方法 方法 作用 channel.txSelect() 将当前的信道设置成事务模式 channel.txCommit() 提交事务 channel.txRollback() 回滚事务 消息成功被发送到RabbitMQ的exchange上，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发因为事务严重影响RabbitMQ的性能， 所以一般使用发布者确认代替事务 t10_消息持久化 消息持久化，需要将消息属性的delivery-mode设置为2即可 RabbitMQ给我们封装了这个属性，即MessageProperties.PERSISTENT_TEXT_PLAINchannel.queueBind(queueName, MsgDurableProducer.EXCHANGE_NAME, “error”);只设置消息的持久化，重启之后队列消息，继而消息也会丢失。所以也要设置队列的持久化channel.queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map arguments) throws IOException; t11_死信队列DLX，全称为Dead-Letter-Exchange，称之为死信交换器。当一个消息在队列中变成死信之后，它能被重新发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列。DLX也是一个正常的交换器，和一般的交换器没有区别，实际上就是设置某个队列的属性 消息变成死信一般是由于以下几种情况 1.消息被拒绝且不重新投递2.消息过期3.队列达到最大长度 死信交换器和备用交换器的区别 备用交换器1.消息无法路由时转到备用交换器2.备用交换器是在声明主交换器的时候定义的死信交换器1.消息已经到达队列，但是被消费者拒绝等的消息会转到死信交换器。2.死信交换器是在声明队列的时候定义的 t12_流量控制qos即服务端限流，qos对于拉模式的消费方式无效 使用qos只要以下2个步骤 1.autoAck设置为false(autoAck=true的时候不生效)2.调用basicConsume方法前先调用basicQos方法。basicQos(int prefetchSize, int prefetchCount, boolean global) 参数名 作用 prfetchSize 批量取的消息的总大小，0为不限制 prefetchCount 消费完prefetchCount条（prefetchCount条消息被ack）才再次推送 global global为true表示对channel进行限制，否则对每个消费者进行限制，因为一个channel允许有多个消费者 qos的作用 1.提高服务稳定性。假设消费端有一段时间不可用，导致队列中有上万条未处理的消息，如果开启客户端，巨量的消息推送过来，可能会导致消费端变卡，也有可能直接不可用，所以服务端限流很重要2.提高吞吐量。当队列有多个消费者时，队列收到的消息以轮询的方式发送给消费者。但由于机器性能等的原因，每个消费者的消费能力不一样，这就会导致一些消费者处理完了消费的消息，而另一些则还堆积了一些消息，会造成整体应用吞吐量的下降","categories":[{"name":"rabbitMQ","slug":"rabbitMQ","permalink":"https://lukeyli.github.io/categories/rabbitMQ/"}],"tags":[]},{"title":"观察者模式","slug":"观察者模式","date":"2020-01-29T12:26:48.000Z","updated":"2020-01-29T12:50:27.894Z","comments":true,"path":"2020/01/29/观察者模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/观察者模式/","excerpt":"","text":"观察者模式定义: 对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者(观察者)都会收到通知并更新。 类型：行为型 适用场景1.关联行为场景，建立一套触发机制。 优点1.观察者和被观察者之间建立一个抽象的耦合2.观察者模式支持广播通信 缺点1.观察者之间有过多的细节依赖、提高时间消耗及程序复杂度2.使用要得当，要避免循环调用 coding在课堂上发起题问，老师应该实时收到。 继承Observable12345678910111213141516171819202122232425262728293031323334353637383940@Datapublic class Question &#123; private String userName; private String questionContent;&#125;public class Course extends Observable &#123; private String courseName; public Course(String courseName)&#123; this.courseName = courseName; &#125; public String getCourseName() &#123; return courseName; &#125; public void produceQuestion(Course course, Question question) &#123; System.out.println(question.getUserName() + &quot;在&quot; + course.courseName +&quot;提交了一个问题&quot;); setChanged(); notifyObservers(question); &#125;&#125;public class Teacher implements Observer &#123; private String teacherName; public Teacher(String teacherName) &#123; this.teacherName = teacherName; &#125; @Override public void update(Observable o, Object arg) &#123; Course course = (Course) o; Question question = (Question) arg; System.out.println(teacherName + &quot;老师的&quot; + course.getCourseName()+ &quot;课程接收到一个&quot; + question.getUserName()+ &quot;提交的问答：&quot; + question.getQuestionContent()); &#125;&#125; eventbus @Subscribe123456789101112131415public class GuavaEvent &#123; @Subscribe public void subscribe(String str)&#123; System.out.println(&quot;执行subscribe方法，传入的参数是：&quot; + str); &#125;&#125;public class GuavaEventTest &#123; public static void main(String[] args) &#123; EventBus eventBus = new EventBus(); GuavaEvent guavaEvent = new GuavaEvent(); eventBus.register(guavaEvent); eventBus.post(&quot;post的内容&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"策略模式","slug":"策略模式","date":"2020-01-29T11:51:25.000Z","updated":"2020-01-29T12:45:29.488Z","comments":true,"path":"2020/01/29/策略模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/策略模式/","excerpt":"","text":"策略模式定义：定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。 类型：行为型 适用场景1.系统有很多类，而他们的区别仅仅在于他们的行为不同2.一个系统需要动态地在几种算法中选择一种 优点1.符合开闭原则2.避免使用多重条件转移语句3.提高算法的保密性和安全性 缺点：1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类2.产生很多策略类。 coding以下是活动搞促销1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface PromotionStrategy &#123; void doPromotion();&#125;public class FanXianPromotionStrategy implements PromotionStrategy&#123; @Override public void doPromotion() &#123; System.out.println(&quot;返现促销,返回的金额存放到慕课网用户的余额中&quot;); &#125;&#125;public class LiJianPromotionStrategy implements PromotionStrategy &#123; @Override public void doPromotion() &#123; System.out.println(&quot;立减促销,课程的价格直接减去配置的价格&quot;); &#125;&#125;public class ManJianPromotionStrategy implements PromotionStrategy&#123; @Override public void doPromotion() &#123; System.out.println(&quot;满减促销,满200-20元&quot;); &#125;&#125;public class PromotionActivity &#123; private PromotionStrategy promotionStrategy; public PromotionActivity(PromotionStrategy promotionStrategy) &#123; this.promotionStrategy = promotionStrategy; &#125; public void executePromotionStrategy()&#123; promotionStrategy.doPromotion(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; PromotionActivity promotionActivity618 = new PromotionActivity(new LiJianPromotionStrategy()); PromotionActivity promotionActivity1111 = new PromotionActivity(new FanXianPromotionStrategy()); promotionActivity618.executePromotionStrategy(); promotionActivity1111.executePromotionStrategy(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"迭代器模式","slug":"迭代器模式","date":"2020-01-29T11:01:44.000Z","updated":"2020-01-29T12:47:05.725Z","comments":true,"path":"2020/01/29/迭代器模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/迭代器模式/","excerpt":"","text":"迭代器模式定义：提供了一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 类型：行为型 适用场景1.访问一个集合对象的内容而无需暴露它的内部表示2.为遍历不同的集合结构提供一个统一的接口 优点1.分离集合对象的遍历行为 缺点1.类的个数成对增加 coding123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class Course &#123; private String name; public Course(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;public interface CourseAggregate &#123; void addCourse(Course course); void removeCourse(Course course); CourseIterator getCourseIterator();&#125;public class CourseAggregateImpl implements CourseAggregate &#123; private List courseList; public CourseAggregateImpl() &#123; this.courseList = new ArrayList(); &#125; @Override public void addCourse(Course course) &#123; courseList.add(course); &#125; @Override public void removeCourse(Course course) &#123; courseList.remove(course); &#125; @Override public CourseIterator getCourseIterator() &#123; return new CourseIteratorImpl(courseList); &#125;&#125;public interface CourseIterator &#123; Course nextCourse(); boolean isLastCourse();&#125;public class CourseIteratorImpl implements CourseIterator &#123; private List courseList; private int position; private Course course; public CourseIteratorImpl(List courseList)&#123; this.courseList=courseList; &#125; @Override public Course nextCourse() &#123; System.out.println(&quot;返回课程,位置是: &quot;+position); course=(Course)courseList.get(position); position++; return course; &#125; @Override public boolean isLastCourse()&#123; if(position&lt; courseList.size())&#123; return false; &#125; return true; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Course course1 = new Course(&quot;Java电商一期&quot;); Course course2 = new Course(&quot;Java电商二期&quot;); Course course3 = new Course(&quot;Java设计模式精讲&quot;); Course course4 = new Course(&quot;Python课程&quot;); Course course5 = new Course(&quot;算法课程&quot;); Course course6 = new Course(&quot;前端课程&quot;); CourseAggregate courseAggregate = new CourseAggregateImpl(); courseAggregate.addCourse(course1); courseAggregate.addCourse(course2); courseAggregate.addCourse(course3); courseAggregate.addCourse(course4); courseAggregate.addCourse(course5); courseAggregate.addCourse(course6); System.out.println(&quot;-----课程列表-----&quot;); printCourses(courseAggregate); courseAggregate.removeCourse(course4); courseAggregate.removeCourse(course5); System.out.println(&quot;-----删除操作之后的课程列表-----&quot;); printCourses(courseAggregate); &#125; public static void printCourses(CourseAggregate courseAggregate)&#123; CourseIterator courseIterator= courseAggregate.getCourseIterator(); while(!courseIterator.isLastCourse())&#123; Course course=courseIterator.nextCourse(); System.out.println(course.getName()); &#125; &#125; &#125; 源码应用ArrayList中Iterator","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"模板方法模式","slug":"模板方法模式","date":"2020-01-29T10:13:13.000Z","updated":"2020-01-29T12:46:24.801Z","comments":true,"path":"2020/01/29/模板方法模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/模板方法模式/","excerpt":"","text":"模板方法模式定义：定义了一个操作中的算法的骨架，并允许子类为一个或多个步骤提供实现。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 类型：行为型 适用场景1.一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。2.各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复 优点1.模板方法模式通过把不变的行为搬移到超类，去除子类中重复的代码，提供了一个很好的代码复用平台2.提高程序扩展性3.符合开闭原则 缺点1.类数目增加2.增加了系统实现的复杂度3.继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍 coding123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public abstract class ACourse &#123; protected final void makeCourse()&#123; this.makePPT(); this.makeVideo(); if(needWriteArticle())&#123; this.writeArticle(); &#125; this.packageCourse(); &#125; final void makePPT()&#123; System.out.println(&quot;制作PPT&quot;); &#125; final void makeVideo()&#123; System.out.println(&quot;制作视频&quot;); &#125; final void writeArticle()&#123; System.out.println(&quot;编写手记&quot;); &#125; //钩子方法 protected boolean needWriteArticle()&#123; return false; &#125; abstract void packageCourse();&#125;public class FECourse extends ACourse &#123; private boolean needWriteArticleFlag = false; @Override void packageCourse() &#123; System.out.println(&quot;提供课程的前端代码&quot;); System.out.println(&quot;提供课程的图片等多媒体素材&quot;); &#125; public FECourse(boolean needWriteArticleFlag) &#123; this.needWriteArticleFlag = needWriteArticleFlag; &#125; @Override protected boolean needWriteArticle() &#123; return this.needWriteArticleFlag; &#125;&#125;public class DesignPatternCourse extends ACourse &#123; @Override void packageCourse() &#123; System.out.println(&quot;提供课程Java源代码&quot;); &#125; @Override protected boolean needWriteArticle() &#123; return true; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;后端设计模式课程start---&quot;); ACourse designPatternCourse = new DesignPatternCourse(); designPatternCourse.makeCourse(); System.out.println(&quot;后端设计模式课程end---&quot;); System.out.println(&quot;前端课程start---&quot;); ACourse feCourse = new FECourse(false); feCourse.makeCourse(); System.out.println(&quot;前端课程end---&quot;); &#125;&#125; 源码应用AbstractList addll方法httpServlet service, doGet …. tips钩子方法，是一个比较奇怪的东西， 他实际上不做任何业务操作，主要用于后期注册函数然后引用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"桥接模式","slug":"桥接模式","date":"2020-01-29T08:20:36.000Z","updated":"2020-01-29T12:54:54.848Z","comments":true,"path":"2020/01/29/桥接模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/桥接模式/","excerpt":"","text":"桥接模式定义：将抽象部分与它的具体实现部分分离，使它们都可以独立地变化；通过组合的方式建立两个类之间联系，而不是继承。 类型：结构型 适用场景1.抽象和具体实现之间增加更多的灵活性；2.一个类存在两个(或多个)独立变化的维度，且这两个(或多个)维度都需要独立进行扩展； 优点1.分离抽象部分及其具体实现部分；提高了系统的可扩展性；2.符合开闭原则；3.符合合成复用原则。 缺点：1.增加了系统的理解与设计难度2.需要正确地识别出系统中两个独立变化的维度。 coding银行账号分为定期、活期，银行又有工商、农商123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface Account &#123; Account openAccount(); void showAccountType();&#125;public class DepositAccount implements Account &#123; @Override public Account openAccount() &#123; System.out.println(&quot;打开定期账号&quot;); return new DepositAccount(); &#125; @Override public void showAccountType() &#123; System.out.println(&quot;这是一个定期账号&quot;); &#125;&#125;public abstract class Bank &#123; protected Account account; public Bank(Account account)&#123; this.account = account; &#125; abstract Account openAccount();&#125;public class ICBCBank extends Bank &#123; public ICBCBank(Account account) &#123; super(account); &#125; @Override Account openAccount() &#123; System.out.println(&quot;打开中国工商银行账号&quot;); account.openAccount(); return account; &#125;&#125; public class ABCBank extends Bank &#123; public ABCBank(Account account) &#123; super(account); &#125; @Override Account openAccount() &#123; System.out.println(&quot;打开中国农业银行账号&quot;); account.openAccount(); return account; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Bank icbcBank = new ICBCBank(new DepositAccount()); Account icbcAccount = icbcBank.openAccount(); icbcAccount.showAccountType(); Bank icbcBank2 = new ICBCBank(new SavingAccount()); Account icbcAccount2 = icbcBank2.openAccount(); icbcAccount2.showAccountType(); Bank abcBank = new ABCBank(new SavingAccount()); Account abcAccount = abcBank.openAccount(); abcAccount.showAccountType(); &#125;&#125; 源码应用jdbc中Driver, DriverManager tips开闭原则：一个软件实体,如类、模块和函数应该对扩展开放,对修改关闭.即一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码来实现变化.合成复用原则:在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"组合模式","slug":"组合模式","date":"2020-01-29T07:32:00.000Z","updated":"2020-01-29T12:58:55.989Z","comments":true,"path":"2020/01/29/组合模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/组合模式/","excerpt":"","text":"组合模式定义: 将对象组合成树形结构以表示 “部分 - 整体” 的层次结构。组合模式使客户端对单个对象和组合对象保持一致的方式处理。 类型：结构型 适用场景1.希望客户端可以忽略组合对象与单个对象的差异时2.处理一个树形结构时 优点1.清楚的定义分层次的复杂对象，表示对象的全部或部分层次2.让客户端忽略了层次的差异，方便对整个层次结构进行控制3.简化客户端的代码4.符合开闭原则 缺点：1.限制类型时较为复杂2.使设计变得更加抽象 coding目录组件,打印课程和目录。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public abstract class CatalogComponent &#123; public void add(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException(&quot;不支持添加操作&quot;); &#125; public void remove(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException(&quot;不支持删除操作&quot;); &#125; public String getName(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException(&quot;不支持获取名称操作&quot;); &#125; public double getPrice(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException(&quot;不支持获取价格操作&quot;); &#125; public void print()&#123; throw new UnsupportedOperationException(&quot;不支持打印操作&quot;); &#125;&#125;public class CourseCatalog extends CatalogComponent &#123; private List&lt;CatalogComponent&gt; items = new ArrayList&lt;&gt;(); private String name; private Integer level; public CourseCatalog(String name,Integer level) &#123; this.name = name; this.level = level; &#125; @Override public void add(CatalogComponent catalogComponent) &#123; items.add(catalogComponent); &#125; @Override public String getName(CatalogComponent catalogComponent) &#123; return this.name; &#125; @Override public void remove(CatalogComponent catalogComponent) &#123; items.remove(catalogComponent); &#125; @Override public void print() &#123; System.out.println(this.name); for (CatalogComponent catalogComponent : items) &#123; if(this.level != null)&#123; for(int i = 0; i &lt; this.level; i++)&#123; System.out.print(&quot; &quot;); &#125; &#125; catalogComponent.print(); &#125; &#125;&#125;public class Course extends CatalogComponent&#123; private String name; private double price; public Course(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public double getPrice() &#123; return price; &#125; @Override public void print() &#123; System.out.println(&quot;Course Name:&quot;+name+&quot; Price:&quot;+price); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; CatalogComponent javaCourseCatalog = new CourseCatalog(&quot;Java课程目录&quot;, 2); CatalogComponent designPattern = new Course(&quot;Java设计模式&quot;,50); CatalogComponent javaBasic = new Course(&quot;java基础&quot;,11); CatalogComponent dataStruct = new Course(&quot;java数据结构&quot;,11); javaCourseCatalog.add(javaBasic); javaCourseCatalog.add(dataStruct); javaCourseCatalog.add(designPattern); CatalogComponent mainCourseCatalog = new CourseCatalog(&quot;Java课程主目录&quot;,1); CatalogComponent linuxCourse = new Course(&quot;Linux课程&quot;,11); CatalogComponent windowsCourse = new Course(&quot;Windows课程&quot;,11); mainCourseCatalog.add(linuxCourse); mainCourseCatalog.add(windowsCourse); mainCourseCatalog.add(javaCourseCatalog); mainCourseCatalog.print(); &#125;&#125; 源码应用java.util下的hashMap putAlljava.util下的ArrayList addAllorg.apache.ibatis.scripting.xmltags.SqlNode","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"享元模式","slug":"享元模式","date":"2020-01-29T03:40:57.000Z","updated":"2020-01-29T12:58:40.358Z","comments":true,"path":"2020/01/29/享元模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/29/享元模式/","excerpt":"","text":"享元模式定义:提供了减少对象数量从而改善应用所需的对象结构的方式，运用共享技术有效的支持大量细粒度的对象。减少对象创建的数量，从而减少内存的占用，并且提高性能。是一种复用对象的思想。 类型: 结构型 适用场景1.常常应用于系统低层的开发，以便解决系统的性能问题。例如 Java 中的 String 类型，就是使用了享元模式，在使用String时，如果有则返回已有的字符串，没有则创建一个，并且保存在字符串的缓存池里；数据库的连接池，需要的话就拿，不需要就放回去。在系统中如果有大量的对象时就有可能造成内存溢出，那我们把其中共同的部分抽象出来，如果有相同的业务请求我们则返回在内存中的已有对象，避免重新创建。2.系统有大量相似对象、需要缓冲池的场景。例如一个系统中存在着大量的细粒度对象，并且这些细粒度的对象的状态中有大部分都可以外部化。优点：1.减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率22.减少内存之外的其他资源的占用，缺点:1.关注内/外部状态、关注线程安全问题。为了使用享元对象，大部分使用的都是 HashMap，如果为了线程安全使用Hashtable，效率不高2.使系统、程序的逻辑复杂，因为使用了享元对象提高了系统的复杂度，我们还要分离出内部状态和外部状态，并且外部状态不应该随着内部状态的变化而变化，否则我们的系统就混乱了。也就是说在使用享元模式的时候可能会造成系统逻辑比较复杂。 扩展：1.内部状态: 指在享元对象的内部并且不会随着环境改变而改变的共享部分2.外部状态：随着环境改变而改变，不可共享的状态，这个状态是记录在享元对象的外部。 相关设计模式：1.享元模式和代理模式：如果代理模式生成的代理类创建需要花费很多时间，那么可以使用享元模式来提高程序的处理速度2.享元模式和单例模式：容器单例 Coding场景：要求各个部门的管理者做下年底总结报告，如果这些管理者都已经生成过了，我们就没有必要再去 new 一个了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Employee &#123; void report();&#125;public class Manager implements Employee&#123; private String title = &quot;部门经理&quot;; private String department; private String reportContent; public Manager(String department) &#123; this.department = department; &#125; public void setReportContent(String reportContent) &#123; this.reportContent = reportContent; &#125; @Override public void report() &#123; System.out.println(reportContent); &#125;&#125;public class EmployeeFactory &#123; private static final Map&lt;String, Employee&gt; EMPLOYEE_MAP = new HashMap&lt;&gt;(); public static Employee getManager(String department) &#123; Manager manager = (Manager) EMPLOYEE_MAP.get(department); if (manager == null) &#123; manager = new Manager(department); System.out.println(&quot;创建部门经理:&quot; + department); String reportContent = department + &quot;部门汇报:此次报告的主要内容是....&quot;; manager.setReportContent(reportContent); System.out.println(&quot;创建报告:&quot; + reportContent); EMPLOYEE_MAP.put(department, manager); &#125; return manager; &#125;&#125;public class Test &#123; private static final String departments[] = &#123;&quot;RD&quot;, &quot;QA&quot;, &quot;PM&quot;, &quot;BD&quot;&#125;; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; String department = departments[(int)(Math.random() * departments.length)]; Manager manager = (Manager) EmployeeFactory.getManager(department); manager.report(); &#125; &#125;&#125; 外部状态与内部状态：Manager类中有个department属性，他的值取决于外部传值, 是外部状态。假如在类 Manager 再声明一个属性 title 直接赋值为 “部门经理” ，这个时候department 如何传值，title 是不变的，即这个属性是内部状态，不随外部变化而变化。 源码应用Integer类中valueOf(int i)123456public static Integer valueOf(int i) &#123; // 如果传入的数字范围在 IntegerCache 范围内，直接返回，如果不在再 new 一个新对象返回 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"代理模式","slug":"代理模式","date":"2020-01-28T15:08:03.000Z","updated":"2020-01-29T12:59:46.765Z","comments":true,"path":"2020/01/28/代理模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/代理模式/","excerpt":"","text":"代理模式定义: 为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介的作用。 类型: 结构型 使用场景1.保护目标对象2.增强目标对象 优点:1.代理模式能将代理对象与真实对象被调用的目标对象分离。2.一定程度上降低了系统的耦合度，扩展性好。3.保护目标对象。4.增强目标对象。 缺点：1.代理模式会造成系统设计中类的数目的增加。2.在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢3.增加了系统的复杂度。 coding场景:保存订单dao 和service,现在要给数据库分库分表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Order &#123; private Object orderInfo; private Integer userId; public Object getOrderInfo() &#123; return orderInfo; &#125; public void setOrderInfo(Object orderInfo) &#123; this.orderInfo = orderInfo; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125;&#125;public interface IOrderDao &#123; int insert(Order order);&#125;public class OrderDaoImpl implements IOrderDao &#123; @Override public int insert(Order order) &#123; System.out.println(&quot;Dao层添加Order成功&quot;); return 1; &#125;&#125;public interface IOrderService &#123; int saveOrder(Order order);&#125;public class OrderServiceImpl implements IOrderService &#123; private IOrderDao iOrderDao; @Override public int saveOrder(Order order) &#123; //Spring会自己注入，我们课程中就直接new了 iOrderDao = new OrderDaoImpl(); System.out.println(&quot;Service层调用Dao层添加Order&quot;); return iOrderDao.insert(order); &#125;&#125; db相关:1234567891011121314151617181920public class DataSourceContextHolder &#123; private static final ThreadLocal&lt;String&gt; CONTEXT_HOLDER = new ThreadLocal&lt;String&gt;(); public static void setDBType(String dbType)&#123; CONTEXT_HOLDER.set(dbType); &#125; public static String getDBType()&#123; return (String)CONTEXT_HOLDER.get(); &#125; public static void clearDBType()&#123; CONTEXT_HOLDER.remove(); &#125;&#125;public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceContextHolder.getDBType(); &#125;&#125; 静态代理静态代理实现，具体选择数据库的连接由代理增强实现.静态代理代码耦合性比较强，需要在具体的业务方法中手动调用。12345678910111213141516171819202122232425262728293031323334public class OrderServiceStaticProxy &#123; private IOrderService iOrderService; public int saveOrder(Order order)&#123; beforeMethod(order); iOrderService = new OrderServiceImpl(); int result = iOrderService.saveOrder(order); afterMethod(); return result; &#125; private void beforeMethod(Order order)&#123; int userId = order.getUserId(); int dbRouter = userId % 2; System.out.println(&quot;静态代理分配到【db&quot;+dbRouter+&quot;】处理数据&quot;); //todo 设置dataSource; DataSourceContextHolder.setDBType(&quot;db&quot;+String.valueOf(dbRouter)); System.out.println(&quot;静态代理 before code&quot;); &#125; private void afterMethod()&#123; System.out.println(&quot;静态代理 after code&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Order order = new Order(); order.setUserId(2); OrderServiceStaticProxy orderServiceStaticProxy = new OrderServiceStaticProxy(); orderServiceStaticProxy.saveOrder(order); &#125;&#125; 动态代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class OrderServiceDynamicProxy implements InvocationHandler &#123; private Object target; public OrderServiceDynamicProxy(Object target) &#123; this.target = target; &#125; public Object bind()&#123; Class cls = target.getClass(); return Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object argObject = args[0]; beforeMethod(argObject); Object object = method.invoke(target,args); afterMethod(); return object; &#125; private void beforeMethod(Object obj)&#123; int userId = 0; System.out.println(&quot;动态代理 before code&quot;); if(obj instanceof Order)&#123; Order order = (Order)obj; userId = order.getUserId(); &#125; int dbRouter = userId % 2; System.out.println(&quot;动态代理分配到【db&quot;+dbRouter+&quot;】处理数据&quot;); //todo 设置dataSource; DataSourceContextHolder.setDBType(&quot;db&quot;+String.valueOf(dbRouter)); &#125; private void afterMethod()&#123; System.out.println(&quot;动态代理 after code&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Order order = new Order(); order.setUserId(1); IOrderService orderServiceDynamicProxy = (IOrderService) new OrderServiceDynamicProxy(new OrderServiceImpl()).bind(); orderServiceDynamicProxy.saveOrder(order); &#125;&#125; 源码应用java.lang.reflect.proxy, ProxyFactoryBean中 getObject()Spring实现aop核心类 JdkDynamicAopProxy 和 CglibAopProxyMybatis中 MapperProxyFactory","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"适配器模式","slug":"适配器模式","date":"2020-01-28T13:51:35.000Z","updated":"2020-01-29T12:59:22.555Z","comments":true,"path":"2020/01/28/适配器模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/适配器模式/","excerpt":"","text":"适配器模式定义: 将一个类的接口（被适配者）转换成客户期望的另一个接口（目标类）。使原本接口不兼容的类可以一起工作。 类型: 结构型 适用场景1.已经存在的类，它的方法和需求不匹配时（方法结果相同或相似）。适配器模式主要应用于希望复用一些现有的类，但是接口又与复用环境要求不一致的情况。系统的数据和行为都正确，但是接口不符合，这个时候我们应该考虑使用适配器模式是原有对象和某个接口匹配。2.随着软件维护，由于不同产品、不同厂家造成功能类似而接口不同情况下的解决方案。 优点：1.能提高类的透明性和复用，现有的类复用但不需要改变，解决了现有类和目标类不匹配的问题2.目标类和适配器类解耦，提高程序扩展性，可以使用适配器模式开发自己的功能3.符合开闭原则，具体的实现都在适配器中，客户端知道的只有适配器类，扩展时只需要扩展适配器类就可以，原有的类不需要变化缺点：1.适配器编写过程需要全面考虑，可能会增加系统的复杂性2.增加系统代码可读的难度，过多的使用适配器模式会让我们的系统非常凌乱，不易把握，比如，我们调用的是第一个接口,其实呢内部已经被适配成了调用第二个接口的实现。 扩展:对象适配器：对象适配器模式符合组合复用原则，并且使用委托机制（重点掌握推荐使用）类适配器：类适配器通过类继承来实现 相关设计模式:适配器模式和外观模式，适配器模式和外观模式都是对现有的类或者现存的系统的封装，外观模式定义了新的接口，外观模式定义了新的接口，而适配器模式则是复用一个原有的接口。适配器模式是指两个已有的接口协同工作，而外观模式则是在现有的系统中提供一个更为方便的访问入口。 coding对象适配器12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @description:被适配者 **/public class Adaptee &#123; public void adapteeRequest()&#123; System.out.println(&quot;被适配者的方法&quot;); &#125;&#125;/** * @description:目标接口 **/public interface Target &#123; void request();&#125;/** * @description:目标实现类 **/public class ConcreteTarget implements Target&#123; @Override public void request() &#123; System.out.println(&quot;concreteTarget目标方法&quot;); &#125;&#125;public class Adapter implements Target&#123; private Adaptee adaptee = new Adaptee(); @Override public void request() &#123; //... 增加自己的逻辑代码 adaptee.adapteeRequest(); //... 增加自己的逻辑代码 &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //Target target = new ConcreteTarget(); // target.request(); Target adapterTarget = new Adapter(); adapterTarget.request(); &#125;&#125; 类适配器12345678910111213141516171819202122232425262728293031323334public interface Target &#123; void request();&#125;public class ConcreteTarget implements Target &#123; @Override public void request() &#123; System.out.println(&quot;concreteTarget目标方法&quot;); &#125;&#125;public class Adaptee &#123; public void adapteeRequest()&#123; System.out.println(&quot;被适配者的方法&quot;); &#125;&#125;public class Adapter extends Adaptee implements Target &#123; @Override public void request() &#123; //... super.adapteeRequest(); //... &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //Target target = new ConcreteTarget(); // target.request(); Target adapterTarget = new Adapter(); adapterTarget.request(); &#125;&#125; 生活场景手机是用5V直流电才可以充电，而我们的国家用电是220V交流电，那用220V的交流电去给手机充电肯定不行。最好用专门的手机充电器去充12345678910111213141516171819202122232425262728293031public class AC220 &#123; public int outputAC220V()&#123; int output = 220; System.out.println(&quot;输出交流电：&quot; + output + &quot; V&quot;); return output; &#125;&#125;public interface DC5 &#123; int outputDC5V();&#125;public class XiaomiAdaptor implements DC5 &#123; private AC220 ac220 = new AC220(); @Override public int outputDC5V() &#123; int adapterInput = ac220.outputAC220V(); // 变压器，交流变直流 int adapterOutput = adapterInput/44; System.out.println(&quot;使用小米充电器输入 AC:&quot; + adapterInput + &quot;V 输出 DC：&quot; + adapterOutput + &quot;V&quot;); return adapterOutput; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; DC5 dc5 = new XiaomiAdaptor(); dc5.outputDC5V(); &#125;&#125; 源码应用1.springmvc 的适配器 HandlerAdapterDispatcherServlet：客户端Handler(Controller) ：被适配者2.XmlAdapter 适配器","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"装饰者模式","slug":"装饰者模式","date":"2020-01-28T13:11:42.000Z","updated":"2020-01-29T07:23:40.063Z","comments":true,"path":"2020/01/28/装饰者模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/装饰者模式/","excerpt":"","text":"装饰者模式定义：在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象功能） 类型：结构型 适用场景1.扩展一个类的功能或给一个类添加附加职责2.动态的给一个对象添加功能，这些功能可以再动态的撤销 优点:1.是继承的有力补充，比继承灵活，不改变原有对象的情况下给对象扩展功能。通常可以使用继承来实现功能的扩展，如果需要扩展的功能的和种类繁多，那么将会生成很多子类，这样增加了系统的复杂性，同时使用继承功能扩展必须可预见这些扩展功能，因为这些功能在编译时就确定了是静态的，如果使用装饰者模式，这些功能是由用户来动态的决定加入的方式和时间，装饰者模式提供了一种即插即用的方法，我们可以在运行期间决定何时增加何种功能。装饰者模式也是建立在继承的基础之上。2.通过使用不同装饰类以及这些类的排列组合，可以实现不同效果。比如插花，不同的组合有不同的花语。3.符合开闭原则缺点1.会出现更多的代码，更多的类，增加程序的复杂性2.当动态装饰时，多层装饰会更复杂 相关设计模式:1.装饰者模式和代理模式。装饰者模式关注在一个对象上动态的增加功能，而代理模式控制对对象的访问，代理模式的代理类对他的客户隐藏一个对象的具体信息。通常在使用代理模式的时候，常在一个代理类中创建一个对象的实例。而当使用装饰者模式的时候我们通常会把原始对象作为一个参数传给装饰者的构造器。 2.装饰者模式和适配器模式。两者都可称之为包装模式。装饰者和被装饰者可以实现相同的接口或者装饰者是被装饰者的子类；适配器模式中，适配器和被适配的类具有不同的接口当然也有可能有部分接口是重合的。装饰者模式还可以退化为半装饰者，即一个装饰者除了提供被装饰类接口外，还可以提供其他方法。 Coding通过继承扩展1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Battercake &#123; protected String getDesc() &#123; return &quot;煎饼&quot;; &#125; protected int cost() &#123; return 20; &#125;&#125;public class BattercakeWithEgg extends Battercake &#123; @Override public String getDesc() &#123; return super.getDesc()+&quot; 加一个鸡蛋&quot;; &#125; @Override public int cost() &#123; return super.cost()+1; &#125;&#125;public class BattercakeWithEggSausage extends BattercakeWithEgg &#123; @Override public String getDesc() &#123; return super.getDesc()+ &quot; 加一根香肠&quot;; &#125; @Override public int cost() &#123; return super.cost()+2; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 小A Battercake battercake = new Battercake(); System.out.println(battercake.getDesc()+&quot; 销售价格:&quot;+battercake.cost()); // 小B Battercake battercakeWithEgg = new BattercakeWithEgg(); System.out.println(battercakeWithEgg.getDesc()+&quot; 销售价格:&quot;+battercakeWithEgg.cost()); // 小C Battercake battercakeWithEggSausage = new BattercakeWithEggSausage(); System.out.println(battercakeWithEggSausage.getDesc()+&quot; 销售价格:&quot;+battercakeWithEggSausage.cost()); &#125;&#125; 假设小c又来买煎饼加2个鸡蛋，两个香肠,..其他人等…组合会非常多。那以现有的系统是无法计算这样的煎饼要卖多少钱，如果对这种要扩展，那么类将会很庞大。 通过装饰者模式扩展123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Battercake extends ABattercake &#123; @Override protected String getDesc() &#123; return &quot;煎饼&quot;; &#125; @Override protected int cost() &#123; return 20; &#125;&#125;public abstract class ABattercake &#123; protected abstract String getDesc(); protected abstract int cost();&#125;public abstract class AbstractDecorator extends ABattercake &#123; private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) &#123; this.aBattercake = aBattercake; &#125; protected abstract void doSomething(); @Override protected String getDesc() &#123; return this.aBattercake.getDesc(); &#125; @Override protected int cost() &#123; return this.aBattercake.cost(); &#125;&#125;public class EggDecorator extends AbstractDecorator &#123; public EggDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected void doSomething() &#123; &#125; @Override protected String getDesc() &#123; return super.getDesc()+&quot; 加一个鸡蛋&quot;; &#125; @Override protected int cost() &#123; return super.cost()+1; &#125;&#125;public class SausageDecorator extends AbstractDecorator &#123; public SausageDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected void doSomething() &#123; &#125; @Override protected String getDesc() &#123; return super.getDesc()+&quot; 加一根香肠&quot;; &#125; @Override protected int cost() &#123; return super.cost()+2; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; ABattercake aBattercake = new Battercake() ; aBattercake = new EggDecorator(aBattercake); aBattercake = new EggDecorator(aBattercake); aBattercake = new SausageDecorator(aBattercake); System.out.println(aBattercake.getDesc() + &quot; 销售价格:&quot;+aBattercake.cost()); &#125;&#125; 运行结果:煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格:24 源码分析BufferedReader 就是一个经典的装饰者类，而 Reader 就是被装饰的抽象类12345678910111213141516171819202122232425262728public class BufferedReader extends Reader &#123; // 被装饰的 Reader 抽象类 private Reader in; ... /** * Creates a buffering character-input stream that uses an input buffer of * the specified size. * * @param in A Reader * @param sz Input-buffer size * * @exception IllegalArgumentException If &#123;@code sz &lt;= 0&#125; */ public BufferedReader(Reader in, int sz) &#123; super(in); if (sz &lt;= 0) throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); this.in = in; cb = new char[sz]; nextChar = nChars = 0; &#125; ... ｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[]},{"title":"外观模式","slug":"外观模式","date":"2020-01-28T11:46:53.000Z","updated":"2020-01-29T12:45:57.010Z","comments":true,"path":"2020/01/28/外观模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/外观模式/","excerpt":"","text":"外观模式定义：外观模式又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口，外观模式定义了一个高层接口，让子系统更容易使用。可能应用层实现某个功能的时候需要调用多个服务类的方法，这样应用层就和各个服务类耦合度很高，那么通过提供出来一个接口方法，将实现这个功能的这些类的方法根据业务需求组织到一个类的方法里面，只对应用层提供该类的方法即可实现同样的功能，这样不仅降低了耦合度，而且应用层也不需要了解每个类方法的作用。 类型：结构型 适用场景1.子系统越来越复杂，增加外观模式提供简单的调用接口2.构建多层系统结构，利用外观对象作为每层的入口，简化层间调用 优点：1.简化了调用过程，无需了解深入子系统，防止带来风险。2.减少系统依赖、松散耦合。外观模式松散了客户端于子系统的耦合关系，客户端通过外观模式于子系统交流，让子系统内部的模块更容易扩展和维护。3.更好的划分访问层次。有些方法是供系统外部调用的，有些则是供系统内部调用的，把需要暴露给外部的功能集中到外观类上，这样既方便客户端调用，也隐藏了系统内部的细节。4.符合迪米特法则 缺点：1.增加子系统、扩展子系统行为容易引入风险2.不符合开闭原则 相关设计模式1.外观模式和中介者模式。外观模式关注的是外界和子系统的交互，而中介者模式关注的是子系统内部之间的交互。2.外观模式和单例模式。通常可以把外观模式中的外观对象做成单例模式的结合使用。3.外观模式和抽象工厂模式。外观类可以通过抽象工厂获取子系统的实例，这样子系统内部可以对外观类进行屏蔽。 codig场景: 积分礼物兑换。涉及一个实体积分礼物，三个子系统积分子系统、支付子系统、物流子系统。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @description: 积分礼物 **/public class PointGift &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;/** * @description: 支付子系统 **/public class PointPaymentService &#123; public boolean pay(PointGift pointGift) &#123; //扣减积分 System.out.println(&quot;支付&quot; + pointGift.getName() + &quot;积分成功&quot;); return true; &#125;&#125;/** * @description:积分子系统 **/public class QualityService &#123; public boolean isAvailable(PointGift pointGift) &#123; System.out.println(&quot;检验&quot; + pointGift.getName() + &quot;积分资格通过，库存通过&quot;); return true; &#125;&#125;/** * @description: 物流子系统 **/public class ShippingService &#123; public String shipGift(PointGift pointGift) &#123; //物流系统的对接逻辑 System.out.println(pointGift.getName() + &quot;进入物流系统&quot;); String shippingOrderNo = &quot;666&quot;; return shippingOrderNo; &#125;&#125;public class GiftExchangeService &#123; private QualityService qualityService = new QualityService(); private PointPaymentService pointPaymentService = new PointPaymentService(); private ShippingService shippingService = new ShippingService(); public void giftExchange(PointGift pointGift) &#123; // 如果资格校验通过 if (qualityService.isAvailable(pointGift)) &#123; // 如果支付积分成功 if (pointPaymentService.pay(pointGift))&#123; String shippingOrderNo = shippingService.shipGift(pointGift); System.out.println(&quot;物流系统下单成功, 订单号是：&quot; + shippingOrderNo); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; PointGift pointGift = new PointGift(&quot;iphone&quot;); GiftExchangeService giftExchangeService = new GiftExchangeService(); giftExchangeService.giftExchange(pointGift); &#125;&#125; 上述外观类使用的是实体外观类，非常完美的支持了迪米特法则，但是对于扩展性并不友好，如果实现某个功能需要增加子系统，除了新增子系统之外，对于的外观类也要修改。不符合开闭原则。可以使用抽象外观类优化解决扩张性，根据业务场景决定。外观类不需要经常变化，使用实外观类即可，如果需要经常变化，则需要使用抽象外观类。 源码分析1.Spring的jdbcUtils 中closeConnection，closeResultSet，getResultSetValue方法12345678public abstract class JdbcUtils &#123;... public static void closeConnection(@Nullable Connection con) &#123;...&#125;...&#125; 2.Mybatis 中的 Configuration 实例，也有外观模式。newMetaObject、newParameterHandler、newResultSetHandler 都是封装了接口，对外提供服务。123456789101112131415 public MetaObject newMetaObject(Object object) &#123; return MetaObject.forObject(object, this.objectFactory, this.objectWrapperFactory, this.reflectorFactory); &#125;public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql); parameterHandler = (ParameterHandler)this.interceptorChain.pluginAll(parameterHandler); return parameterHandler;&#125;public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) &#123; ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds); ResultSetHandler resultSetHandler = (ResultSetHandler)this.interceptorChain.pluginAll(resultSetHandler); return resultSetHandler;&#125; 3.Tomcat 也用了很多外观模式，像一些带Facade的接口。（RequestFacade 是对 Request进行的封装、ResponseFacade 等） tips迪米特法则：一个对象应该对其他对象保持最少的了解。意义在于降低类之间的耦合。开闭原则：一个软件实体,如类、模块和函数应该对扩展开放,对修改关闭.即一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码来实现变化.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"建造者模式","slug":"建造者模式","date":"2020-01-28T09:47:26.000Z","updated":"2020-01-29T12:46:33.409Z","comments":true,"path":"2020/01/28/建造者模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/建造者模式/","excerpt":"","text":"设计模式定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需要指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。这个定义通俗的讲就是说建造者模式就是如何一步一步构建一个包含多个组件的对象，相同的构建过程可以创建不同的产品，比较适用于那些流程固定但是顺序不一定固定。个人觉得建造者模式就是根据业务场景针对那些一次性无法创建出最终的对象，比如 StringBuilder ，在创建 String 时，有很多 append方法追加，直到不再调用 append 时，String 对象才算最终创建完成。很多 ORM 框架的查询条件的创建也是运用了建造者模式。 类型：创建型 适用场景1.如果一个对象有非常复杂的内部结构（它有很多属性）2.想把复杂对象的创建和使用分离3.当创造一个对象需要很多步骤时适合使用建造者模式，而当需要一个简单的方法就可以简单的创建整个对象时适合使用工厂相关模式。 优点:1.封装性好，创建和使用分离2.扩展性好、建造类之间独立，一定程度上解耦缺点:1.会产生多余的 Builder 对象2.产品内部发生变化，建造者都要修改，成本比较大 建造者模式和工厂模式的区别：1.注重点不同，建造者模式更注重于方法的调用顺序，而工厂模式注重于创建产品2.创建对象的粒度不同，建造者模式可以创建复杂的产品，由各种复杂的部件组成，工厂模式创建出来的都是一个样子3.关注点不同，工厂模式注重的把这个对象创建出来就行了，而建造者模式不止要创建出这个产品，还要知道这个产品都是由哪些部件组成的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Datapublic class Course &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String CourseQA;&#125;public abstract class CourseBuilder &#123; public abstract void builderCourseName(String courseName); public abstract void builderCoursePPT(String coursePPT); public abstract void builderCourseVideo(String courseVideo); public abstract void builderCourseArticle(String courseArticle); public abstract void builderCourseQA(String courseQA); public abstract Course makeCourse();&#125;/** * 课程的建造者实现类 */public class CourseActualBuilder extends CourseBuilder &#123; private Course course = new Course(); @Override public void builderCourseName(String courseName) &#123; course.setCourseName(courseName); &#125; @Override public void builderCoursePPT(String coursePPT) &#123; course.setCoursePPT(coursePPT); &#125; @Override public void builderCourseVideo(String courseVideo) &#123; course.setCourseVideo(courseVideo); &#125; @Override public void builderCourseArticle(String courseArticle) &#123; course.setCourseArticle(courseArticle); &#125; @Override public void builderCourseQA(String courseQA) &#123; course.setCourseQA(courseQA); &#125; @Override public Course makeCourse() &#123; return course; &#125;&#125;/** * 指挥如何建造者如何创建 Course */public class Teacher &#123; private CourseBuilder courseBuilder; public void setCourseBuilder(CourseBuilder courseBuilder) &#123; this.courseBuilder = courseBuilder; &#125; public Course makeCourse(String courseName, String coursePPT, String courseVideo, String courseArticle, String courseQA) &#123; this.courseBuilder.builderCourseName(courseName); this.courseBuilder.builderCoursePPT(coursePPT); this.courseBuilder.builderCourseVideo(courseVideo); this.courseBuilder.builderCourseArticle(courseArticle); this.courseBuilder.builderCourseQA(courseQA); return this.courseBuilder.makeCourse(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; CourseBuilder courseBuilder = new CourseActualBuilder(); Teacher teacher = new Teacher(); teacher.setCourseBuilder(courseBuilder); Course course = teacher.makeCourse(&quot;设计模式&quot;, &quot;PPT&quot;, &quot;视频&quot;, &quot;手记&quot;, &quot;问答&quot;); System.out.println(course); &#125;&#125; 演进版本可以将建造者类当做被构造类的内部类存在123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Course &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; public Course(CourseBuilder courseBuilder) &#123; this.courseName = courseBuilder.courseName; this.coursePPT = courseBuilder.coursePPT; this.courseVideo = courseBuilder.courseVideo; this.courseArticle = courseBuilder.courseArticle; this.courseQA = courseBuilder.courseQA; &#125; public static class CourseBuilder &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; public CourseBuilder builderCourseName(String courseName) &#123; this.courseName = courseName; return this; &#125; public CourseBuilder buildCoursePPT(String coursePPT) &#123; this.coursePPT = coursePPT; return this; &#125; public CourseBuilder buildCourseVideo(String courseVideo) &#123; this.courseVideo = courseVideo; return this; &#125; public CourseBuilder buildCourseArticle(String courseArticle) &#123; this.courseArticle = courseArticle; return this; &#125; public CourseBuilder buildCourseQA(String courseQA) &#123; this.courseQA = courseQA; return this; &#125; public Course build()&#123; return new Course(this); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Course course = new Course.CourseBuilder().builderCourseName(&quot;设计模式&quot;).buildCoursePPT(&quot;PPT&quot;).buildCourseVideo(&quot;视频&quot;).build(); System.out.println(course); &#125;&#125; 源码分析StringBuilder（StringBuffer） 就是经典的建造者模式吗， append 方法。Activitie 工作流框架里面 Deployment + DeploymentBuilder 也应用了建造者模式。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"原型模式","slug":"原型模式","date":"2020-01-28T02:59:43.000Z","updated":"2020-01-29T06:31:36.705Z","comments":true,"path":"2020/01/28/原型模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/28/原型模式/","excerpt":"","text":"原型模式定义：指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。不需要知道任何创建的细节，不调用构造函数（这里说的不调用构造函数是指不通过new的方式创建，查看jdk源码是通过反射机制实现对象的创建） 类型：创建型 适用场景1.类初始化消耗较多资源2.new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）3.构造函数比较复杂4.循环体中创建大量对象 优点：1.原型模式性能比直接 new 一个对象性能高2.简化创建过程 缺点：1.必须实现 Cloneable 接口并且实现配备克隆方法2.对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险3.在对复杂对象进行深拷贝、浅拷贝要运用得当 Coding场景:给一群活动中奖的人发生邮件,需要保存原始的邮件模板,而且中奖的人很多意味着要new很多类,并且给每个属性都赋值,有些内容一致,有些则不同。123456789101112131415161718192021222324252627282930313233343536373839404142434445@Datapublic class Mail &#123; private String name; private String emailAddress; private String content; public Mail()&#123; System.out.println(&quot;Mail Class Contructor&quot;); &#125; @Override public String toString() &#123; return &quot;Mail&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, emailAddress=&apos;&quot; + emailAddress + &apos;\\&apos;&apos; + &quot;, content=&apos;&quot; + content + &apos;\\&apos;&apos; + &apos;&#125;&apos; + super.toString(); &#125;&#125;public class MailUtil &#123; public static void sendMail(Mail mail) &#123; String outputContent = &quot;向&#123;0&#125;同学,发送邮件地址：&#123;1&#125;, 邮件内容：&#123;2&#125;发送邮件成功&quot;; System.out.println(MessageFormat.format(outputContent, mail.getName(), mail.getEmailAddress(), mail.getContent())); &#125; public static void saveOriginMailRecord(Mail mail) &#123; System.out.println(&quot;存储 originMail记录, originMail:&quot; + mail.getContent()); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Mail mail = new Mail(); mail.setContent(&quot;初始化模板&quot;); MailUtil.saveOriginMailRecord(mail); for (int i = 0; i &lt; 1000; i++) &#123; mail.setName(&quot;姓名&quot; + i); mail.setEmailAddress(&quot;姓名&quot; + i + &quot;@163.com&quot;); mail.setContent(&quot;恭喜你，中奖了&quot;); MailUtil.sendMail(mail); &#125; &#125;&#125; 运行结果:Mail Class Contructor存储 originMail记录, originMail:初始化模板向姓名0同学,发送邮件地址：姓名0@163.com, 邮件内容：恭喜你，中奖了发送邮件成功…向姓名999同学,发送邮件地址：姓名999@163.com, 邮件内容：恭喜你，中奖了发送邮件成功 假设saveOriginMailRecord一定要在发送email之后,在for循环内 new 对象将消耗很大。 使用原型模式12345678910111213141516171819202122232425@Datapublic class Mail implements Cloneable &#123; private String name; private String emailAddress; private String content; public Mail()&#123; System.out.println(&quot;Mail Class Contructor&quot;); &#125; @Override public String toString() &#123; return &quot;Mail&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, emailAddress=&apos;&quot; + emailAddress + &apos;\\&apos;&apos; + &quot;, content=&apos;&quot; + content + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; System.out.println(&quot;clone mail object&quot;); return super.clone(); &#125;&#125; 通过抽象类使用原型模式12345678910111213141516171819/** * 通过抽象类实现原型模式 */public abstract class A implements Cloneable&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; /** * 继承 A ，因此也有 clone 属性 */public class B extends A &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; B b = new B(); b.clone(); &#125;&#125; 深克隆在实际使用中，建议对原型类中的引用属性进行深克隆，以避免不必要的坑。根据实际业务考虑使用深克隆还是浅克隆。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-01-27T06:21:29.000Z","updated":"2020-01-29T06:27:35.291Z","comments":true,"path":"2020/01/27/单例模式/","link":"","permalink":"https://lukeyli.github.io/2020/01/27/单例模式/","excerpt":"","text":"单例模式定义：保证一个类仅有一个实例，并提供一个全局访问点。 类型：创建型 适用场景想确保任何情况下都绝对只有一个实例 优点：1.在内存里只有一个实例，减少了内存的开销2.可以对避免对资源的多重占用3.设置全局的访问点，严格控制访问。 缺点：1.没有接口，扩展困难 重点：1.私有构造器，禁止从单例类外部调用构造函数创建对象2.线程安全3.延迟加载，等使用到的时候再创建。懒汉模式4.序列化和反序列化安全5.反射,通过反射可以破坏单例 单例模式和其他设计模式的结合：1.单例模式和工厂模式2.单例模式和享元模式 coding懒汉式线程不安全注重延迟加载，只有使用的时候才会创建。123456789101112131415public class LazySingleton &#123; // 声明该类变量，但是不创建，等到真正使用的时候调用 getInstance 方法创建 private static LazySingleton lazySingleton = null; // 构造函数私有化，避免外部调用 private LazySingleton() &#123; &#125; //v1 线程不安全 public static LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; //在多线程的情况下,可能使用很多对象。 lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 懒汉式安全版本1.直接锁类的静态方法加锁范围大，对程序消耗较大123456789101112131415161718192021222324public class LazySingleton &#123; // 声明该类变量，但是不创建，等到真正使用的时候调用 getInstance 方法创建 private static LazySingleton lazySingleton = null; // 构造函数私有化，避免外部调用 private LazySingleton() &#123; &#125; //v2 加上 synchronized 关键字，使该方法变为同步方法， public synchronized static LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125; //与上面的方法效果一样。// public static LazySingleton getInstance()&#123;// synchronized(LazySingleton.class)&#123;// if (lazySingleton == null) &#123;// lazySingleton = new LazySingleton();// &#125;// &#125;// return lazySingleton;// &#125;&#125; 2.Double-Check 双重检查1234567891011121314public class LazyDoubleCheckSingleton &#123; private static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton()&#123;&#125; private static LazyDoubleCheckSingleton getInstance()&#123; if (lazyDoubleCheckSingleton == null) &#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if(lazyDoubleCheckSingleton == null) &#123; lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazyDoubleCheckSingleton; &#125;&#125; 分析：这边看似逻辑正确，但是这边存在坑，指定重排序问题lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton()的过程：1.分配对象的内存空间。2.初始化对象3.设置lazyDoubleCheckSingleton指向刚分配的内存地址。4.初次访问对象在发生的过程中可能发生重排序, 执行顺序可能发生2和3互换位置，即执行顺序为1-3-2-4.在单线程内，重排序不会影响程序执行结果。但是在多线程中就会出现问题：如何解决？ (1)Double-Check + volatile1.不允许2、3进行重排序（Double-Check + volatile 关键字）使用 volatile 关键字修饰我们的变量，就会禁止重排序，在多线程的时候CPU也有共享内存，我们在加了 volatile 关键字之后，所有的线程都可以看到共享内存的最新状态，保证了内存的可见性。用 volatile 关键字修饰的共享变量在进行写操作的时候会多出一些汇编代码，将当前处理器缓存好的数据写回系统内存，该操作会使在其他CPU里缓存了该内存地址的数据无效，从而又从共享内存同步数据，这样就保证了内存的可见性。这里主要使用了缓存一致性协议。1234567891011121314public class LazyDoubleCheckSingleton &#123; private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton()&#123;&#125; private static LazyDoubleCheckSingleton getInstance()&#123; if (lazyDoubleCheckSingleton == null) &#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if(lazyDoubleCheckSingleton == null) &#123; lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazyDoubleCheckSingleton; &#125;&#125; 2.允许2、3重排序，但是不允许其他线程看到这个重排序。 (2)静态内部类123456789101112public class StaticInnerClassSingleton &#123; private StaticInnerClassSingleton() &#123; &#125; // 静态内部类的静态初始化锁，哪个线程拿到哪个线程就去初始化它 private static class InnerClass &#123; private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); &#125; private static StaticInnerClassSingleton getInstance()&#123; return InnerClass.staticInnerClassSingleton; &#125;&#125; 原理:jvm 在类的初始化阶段，也就是 class 被加载后，并且被线程使用前都是类的初始化阶段，在这个阶段会执行类的初始化，在执行类的初始化期间 jvm 会获取一个锁，这个锁会同步多个线程对一个类的初始化，也就是图中绿色的部分,基于这个基于这个特性，我们可以实现基于静态内部类的并且是线程安全的延迟初始化方案按照这个方式，假如线程1拿到类初始化锁,右边部分指令的重排序，对于线程1并不会看到，也就是说非构造线程是不允许看到重排序的。初始化一个类，包括执行这个类的静态初始化以及初始化在这个类中的声明的静态变量，根据 java 语言规范主要分为五种情况，首次发生的时候一个类将被立刻初始化，这里说的类是泛指一个接口也是一个类，假设该类为 A，以下五种情况都会导致 A 类会被立刻初始化。1.有一个 A 类型的实例被创建2.A 类中声明的一个静态方法被调用3.A 类中声明的一个静态成员被赋值4.A 类中声明的一个静态成员被使用，并且该成员不是一个常量成员5.如果 A 类是个顶级类，并且在该类中有嵌套的断言语句，此时 A 也会被立即初始化这里的原理可以这样理解下：线程 0 拿到了 内部类的初始化锁，而内部类的初始化过程有 3 ，整个绿色的过程被上了锁，所以锁内指令重排序2、3颠倒顺序无所谓，因为从其他线程此时是没有办法进来的，只能等待这个初始化过程完毕。 饿汉式线程安全，但是如果创建出来的实际程序没有使用就会造成浪费（感觉这个担心多余，不用删掉，创建它干嘛）123456789public class HungrySingleton &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125;&#125; 基于枚举的单列1234567891011121314151617线程安全、反序列化和反射不能破坏其单例的初衷 ，可以通过jad反编译该 class 文件查看（最优解）public enum EnumInstance &#123; INSTANCE; private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public static EnumInstance getInstance() &#123; return INSTANCE; &#125;&#125; 基于 ThreadLocal 的单例模式该方法并不能保证全局唯一，但可以保证线程唯一，很多框架也用到这个模式的单例。12345678910111213141516public class ThreadLocalInstance &#123; private static final ThreadLocal&lt;ThreadLocalInstance&gt; threadLocalInstance = new ThreadLocal&lt;ThreadLocalInstance&gt;()&#123; @Override protected ThreadLocalInstance initialValue() &#123; return new ThreadLocalInstance(); &#125; &#125;; private ThreadLocalInstance() &#123; &#125; public static ThreadLocalInstance getInstance()&#123; return threadLocalInstance.get(); &#125;&#125; 序列化破坏单例模式123456789101112131415161718192021222324public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125;&#125;public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; HungrySingleton instance = HungrySingleton.getInstance(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;singleton_file&quot;)); oos.writeObject(instance); File file = new File(&quot;singleton_file&quot;); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); HungrySingleton newInstance = (HungrySingleton) ois.readObject(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); &#125;&#125; 运行结果：com.lzy.design.pattern.singleton.HungrySingleton@2626b418com.lzy.design.pattern.singleton.HungrySingleton@7530d0afalse结果发现，经过序列化和反序列化之后拿到的对象地址不一样，这违背了单例模式的初衷。增加以下方法，可以解决上述问题。注意该方法名称和返回类型最好跟下面所写一致。 解决方案123456789101112public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125; // 该方法并非被重写的方法 private Object readResolve()&#123; return hungrySingleton; &#125;&#125; 源码追踪ObjectInputStream类中readObject方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public final Object readObject() throws IOException, ClassNotFoundException &#123; if (enableOverride) &#123; return readObjectOverride(); &#125; // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try &#123; // TODO 从这里查看 Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) &#123; throw ex; &#125; if (depth == 0) &#123; vlist.doCallbacks(); &#125; return obj; &#125; finally &#123; passHandle = outerHandle; if (closed &amp;&amp; depth == 0) &#123; clear(); &#125; &#125; &#125; // ObjectInputStream#readObject0private Object readObject0(boolean unshared) throws IOException &#123; ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); ...&#125; // ObjectInputStream#readOrdinaryObjectprivate Object readOrdinaryObject(boolean unshared)&#123; ... obj = desc.isInstantiable() ? desc.newInstance() : null; ... &#125; // ObjectInputStream#isInstantiable 返回 true，执行 desc.newInstance()，通过反射创建新的单例类，// 到此时也看到了为什么在 HungrySingleton 没添加 readResolve 方法之前会返回新的对象./** * Returns true if represented class is serializable/externalizable and can * be instantiated by the serialization runtime--i.e., if it is * externalizable and defines a public no-arg constructor, or if it is * non-externalizable and its first non-serializable superclass defines an * accessible no-arg constructor. Otherwise, returns false. */boolean isInstantiable() &#123; requireInitialized(); return (cons != null);&#125; // ObjectInputStream#readOrdinaryObjectprivate Object readOrdinaryObject(boolean unshared)&#123; ... // 在 HungrySingleton 添加 readResolve 方法之后 desc.hasReadResolveMethod() 该方法执行为 true if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; // 通过反射调用 HungrySingleton 类中的 readResolve 方法返回， // 即为我们的单例对象，所以这里讲此处返回的对象赋值给 obj，所以这里我们找到了答案 Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; // Filter the replacement object if (rep != null) &#123; if (rep.getClass().isArray()) &#123; filterCheck(rep.getClass(), Array.getLength(rep)); &#125; else &#123; filterCheck(rep.getClass(), -1); &#125; &#125; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj;&#125; readResolveMethod = getInheritableMethod( // 这里有 readResolve 解答了我们 HungrySingleton 类中方法命名疑惑 cl, &quot;readResolve&quot;, null, Object.class); 反射破坏单例模式12345678910111213141516171819202122public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125;&#125; public static void main(String[] args) throws Exception &#123; Class objectClass = HungrySingleton.class; Constructor constructor = objectClass.getDeclaredConstructor(); HungrySingleton instance = HungrySingleton.getInstance(); constructor.setAccessible(true); HungrySingleton object = (HungrySingleton) constructor.newInstance(); System.out.println(instance); System.out.println(object); System.out.println(instance == object); &#125;&#125; 运行结果:com.lzy.design.pattern.singleton.HungrySingleton@7440e464com.lzy.design.pattern.singleton.HungrySingleton@49476842false 解决方案在私有化构造器中添加防止通过反射调用的代码（只针对在类加载初始化时就已经创建好单例对象的单例模式有效）即（饿汉式和基于内部类实现懒加载的单例模式有效，对其他懒汉加载无效）1234567891011121314public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123; // 防放射破坏代码,如果是通过反射调用就抛出运行时异常 if (hungrySingleton != null) &#123; throw new RuntimeException(&quot;单例构造器禁止反射调用&quot;); &#125; &#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125;&#125; 对于不是在类加载的时候创建好单例实例对象的单例模式无法避免单例被破坏 克隆破坏单例模式123456789101112131415161718192021222324252627282930313233343536public class HungrySingleton implements Serializable, Cloneable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123; if (hungrySingleton != null) &#123; throw new RuntimeException(&quot;单例构造器禁止反射调用&quot;); &#125; &#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125; // 该方法并非被重写的方法 private Object readResolve()&#123; return hungrySingleton; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); // 解决办法，1. 不实现 Cloneable 接口，2. 实现 Cloneable 接口，重写 clone 方法，调用 单例类的 getInstance 方法 //return getInstance(); &#125;&#125; public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; HungrySingleton hungrySingleton = HungrySingleton.getInstance(); Method method = hungrySingleton.getClass().getDeclaredMethod(&quot;clone&quot;); method.setAccessible(true); HungrySingleton cloneHungrySingleton = (HungrySingleton) method.invoke(hungrySingleton); System.out.println(hungrySingleton); System.out.println(cloneHungrySingleton); System.out.println(hungrySingleton == cloneHungrySingleton);&#125; 运行结果:com.lzy.design.pattern.singleton.HungrySingleton@49476842com.lzy.design.pattern.singleton.HungrySingleton@78308db1false 解决方法1.不实现 Cloneable 接口2.实现 Cloneable 接口，重写 clone 方法，调用 单例类的 getInstance 方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"抽象工厂","slug":"抽象工厂","date":"2020-01-27T03:43:26.000Z","updated":"2020-01-29T06:25:39.403Z","comments":true,"path":"2020/01/27/抽象工厂/","link":"","permalink":"https://lukeyli.github.io/2020/01/27/抽象工厂/","excerpt":"","text":"抽象工厂定义：抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。抽象工厂可以将一组具有同一主题单独的工厂封装起来。在正常使用中客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象，在使用的时候是不需要知道或关心他从这些内部的工厂方法中获得对象的具体类型，因为我们的客户端程序仅仅使用这些通用的接口，抽象工厂模式将一组对象的实现细节和他们的使用分离开来。 类型：创建型 适用场景1.客户端（应用层）不依赖于产品类实例如何被创建、实现等细节2.强调一系列相关的产品对象（属于同一产品族）一起使用，创建对象时需要大量重复的代码。3.提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现 使用抽象工厂模式能够再具体工厂变化的时候不用修改使用工厂的客户端程序 优点：1.具体产品在应用层代码隔离，无需关心创建细节2.将一个系列的产品族统一到一起创建缺点：1.规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口2.增加了系统的抽象性和理解难度 产品等级结构与产品族同一产品等级譬如：苹果、梨子、香蕉都是水果的一个产品等级，产品族的概念是：A 水果店里在卖 苹果、梨子、香蕉，B水果店也在卖上面三种水果，C 水果店也卖卖上述三种水果，A、B、C 水果店分别的苹果、梨子、香蕉 就是一个产品族。一个产品族就对应了一个具体工厂类。 coding1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class Cuisine &#123; public abstract void cookie();&#125;public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;public abstract class Soup &#123; public abstract void cookie();&#125;public class SichuanSoup extends Soup &#123; @Override public void cookie() &#123; System.out.println(&quot;做川汤&quot;); &#125;&#125;public class CantoneseSoup extends Soup &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤汤&quot;); &#125;&#125;//一桌大餐,菜少不了汤public interface DinnerFactory &#123; Cuisine getCuisine(); Soup getSoup();&#125;public class SichuanDinnerFactory implements DinnerFactory &#123; @Override public Cuisine getCuisine() &#123; return new SichuanCuisine(); &#125; @Override public Soup getSoup() &#123; return new SichuanSoup(); &#125;&#125;public class CantonseDinnerFactory implements DinnerFactory &#123; @Override public Cuisine getCuisine() &#123; return new CantoneseCuisine(); &#125; @Override public Soup getSoup() &#123; return new SichuanSoup(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; DinnerFactory dinnerFactory = new SichuanDinnerFactory(); Cuisine sichuanCuisine = dinnerFactory.getCuisine(); Soup sichuanSoup = dinnerFactory.getSoup(); sichuanCuisine.cookie(); sichuanSoup.cookie(); &#125;&#125; 源码解析java.sql.Connection 类,通过实际应用可以知道，如果你使用 MySQL 数据库驱动，那么通过该 Connection 的实现类，可以获取MySQL 数据库驱动的Statement和PreparedStatement对应子类，如果是 Oracle,同样可以获取 Oracle 对应的 Statement 和PreparedStatement对应子类，那么 java.sql.Connection 就是抽象工厂类,可以生产Statement和PreparedStatement 这一产品族的工厂。而不同的数据库驱动对应的 PreparedStatement 或 Statement 是同一产品等级。123456public interface Connection extends Wrapper, AutoCloseable &#123; ... Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) ...｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"工厂方法","slug":"工厂方法","date":"2020-01-26T15:23:44.000Z","updated":"2020-01-29T12:49:06.118Z","comments":true,"path":"2020/01/26/工厂方法/","link":"","permalink":"https://lukeyli.github.io/2020/01/26/工厂方法/","excerpt":"","text":"工厂方法类型: 创建型定义：定义一个创建对象接口，但是让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。解决同一产品等级的业务抽象问题。 简单工厂模式如果产品太多，那么工厂类的逻辑判断也会很多，如果再加上创建对象时的一些判断逻辑，那该工厂类的代码会显得很臃肿。用工厂方法模式可以起到拆分的效果，即同一产品等级下利用产品对应的工厂实例创建各自的产品实例。 适用场景1.创建对象需要大量重复的代码，可以考虑工厂方法是不是适用在这里。2.客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，只需要知道所对应的工厂，具体产品对象由对应工厂创建。3.一个类通过其子类来指定创建哪个对象。 优点：1.用户只需要关心所需产品对应的工厂，无需关心创建细节2.加入新产品符合开闭原则，提高可扩展性。 缺点：1.类的个数容易过多，增加复杂度（增加新的类的时候，就需要同时添加该类对应的工厂类）2.增加了系统的抽象性和理解难度 coding1234567891011121314151617181920212223242526272829303132333435363738394041424344//菜品public abstract class Cuisine &#123; public abstract void cookie();&#125;//粤菜public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;//川菜public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public abstract class CuisineFactory &#123; public abstract Cuisine getCuisine();&#125;public class CantoneseCuisineFactory extends CuisineFactory &#123; @Override public Cuisine getCuisine() &#123; return new CantoneseCuisine(); &#125;&#125;public class SichuanCuisineFactory extends CuisineFactory &#123; @Override public Cuisine getCuisine() &#123; return new SichuanCuisine(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 父类的声明指向子类的应用,根据需要创建对应菜系的工厂类即可 CuisineFactory cantoneseCuisineFactory = new CantoneseCuisineFactory(); CuisineFactory sichuanCuisineFactory = new SichuanCuisineFactory(); Cuisine sichuanCuisine = sichuanCuisineFactory.getCuisine(); sichuanCuisine.cookie(); &#125;&#125; 理解下产品等级概念, 宝马车、奇瑞、悍马、路虎，都属于车的产品等级，苹果、香蕉、梨子都是水果的产品等级。 从上面可以发现，如果需需要扩展，只需要添加对应产品以及对应的产品工厂了即可。做到了对扩展开放对修改关闭。 源码解析Collection类iterator方法, Collection 抽象工厂，产品实例就是 ArrayList里面的一个内部类Itr实现了 Iterator 接口, 而ArrayList 本身可以看做 Collection 工厂的子类工厂实例。每个继承 Collection 接口的子类都有不同的实现得到不同的产品实例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ... Iterator&lt;E&gt; iterator(); ...｝ public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; ...｝","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"简单工厂","slug":"简单工厂","date":"2020-01-24T15:01:53.000Z","updated":"2020-01-29T12:57:11.712Z","comments":true,"path":"2020/01/24/简单工厂/","link":"","permalink":"https://lukeyli.github.io/2020/01/24/简单工厂/","excerpt":"","text":"简单工厂定义：由一个工厂对象决定创建出哪一种产品类的实例。白话: 在家里，做菜得买洗炒菜等繁琐的步骤,现在都嫌做菜麻烦。但是我们还是想吃五花八门的菜怎么办，打开饿了么app对不同的菜品下单就好,不需要关心他是怎么做出来的，能吃到自己点的餐就好。类型：创建型，但不属于 GOF23 种设计模式。 适用场景1.工厂类负责创建的对象比较少2.客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心优点：1.只需要传入一个正确的参数，就可以获取你所需要的对象而无序知道其创建细节2.将对象的创建和使用分离缺点：1.工厂类的职责相对过重，增加新产品时需要修改工厂类的判断逻辑，违背开闭原则。当产品过多的时候会产生很多的类，不利于维护。2.无法形成基于继承的等级结构 coding场景：这个餐馆比较牛掰，菜品丰富，有粤菜、川菜, 在Test类(Client端)创建相应的菜品。(其实应该是具体的菜名)代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041/** * @description:菜品 * @author: lzy **/public abstract class Cuisine &#123; public abstract void cookie();&#125;/** * @description:粤菜 * @author: lzy **/public class CantoneseCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做粤菜&quot;); &#125;&#125;/** * @description:川菜 * @author: lzy **/public class SichuanCuisine extends Cuisine &#123; @Override public void cookie() &#123; System.out.println(&quot;做川菜&quot;); &#125;&#125;public class Test &#123; public static void cookieSichuan() &#123; Cuisine cuisine = new SichuanCuisine(); cuisine.cookie(); &#125; public static void main(String[] args) &#123; cookieSichuan(); &#125;&#125; 从上面代码来看，Test 类里面声明了一个 Cuisine 类型的变量指向其 SichuanCuisine 子类, Test类是非常依赖子类（违反依赖倒置原则）。想要粤菜就得创建Cuisine的子类CantoneseCuisine。我们意愿是让客户端代码不依赖对应的产品类，把创建具体视频类的逻辑对客户端代码隐藏，使应用层的代码不依赖对应的具体实现类。 通过一个工厂类解决此问题1234567891011public class CuisineFactory &#123; //v1 根据传入的类型创建具体的实例 public Cuisine getCuisine(String type) &#123; if (&quot;Sichuan&quot;.equalsIgnoreCase(type)) &#123; return new SichuanCuisine(); &#125; else if (&quot;Cantonese&quot;.equalsIgnoreCase(type)) &#123; return new CantoneseCuisine(); &#125; return null; &#125;&#125; 问题是解决了，但是如果新增菜品，就需要新建类。需要修改CuisineFactory的判断逻辑，违背开闭原则。工厂方法类可以通过反射来优化上诉问题。通过传入的Class类型，创建对应实例，当需要新的实例时，只需要新建一个类即可，不需要修改CuisineFactory类内部创建类的判断逻辑。代码如下：12345678910111213141516171819202122232425262728public class CuisineFactory &#123; //v2 通过反射优化工厂创建对应实例 public Cuisine getCuisine(Class c) &#123; Cuisine cuisine = null; try &#123; cuisine = (Cuisine) Class.forName(c.getName()).newInstance(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return cuisine; &#125;&#125;public class Test &#123; //v2 使用反射机制优化过的工厂类 public static void main(String[] args) &#123; CuisineFactory cuisineFactory = new CuisineFactory(); Cuisine cuisine = cuisineFactory.getCuisine(SichuanCuisine.class); if (cuisine == null)&#123; return; &#125; cuisine.cookie(); &#125;&#125; 类图改进之后，不需要修改工厂类的判断逻辑，但是客户端需要创建另一种产品时，还是需要修改客户端代码，有没有一种方式就是在不修改代码的前提下做到随时创建新的产品呢？ 可以通过将所创建的产品配置到外部的配置文件中，来解决这个问题，就像Spring中数据源的一些连接信息外部化到配置文件。 改造点： 在之前版本的基础上新建一个工具类，用于读取配置文件，或得需要创建的产品的配置，这里以properties文件为例，也可以以xml文件为例key-value，value可以是多个，以逗号隔开。这样替换或者新增创建的产品根本不需要改动任何代码，就改下配置文件即可。 源码分析1.Calendar类getInstance方法。12345678910111213141516171819202122232425262728293031323334353637383940414243// getInstancepublic static Calendar getInstance(Locale aLocale)&#123; return createCalendar(TimeZone.getDefault(), aLocale);&#125;private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; // 主要看这里创建的方式，与客户端调通过传入 类型 用工厂方法时，思想一致(V1) if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;); if (caltype != null) &#123; switch (caltype) &#123; case &quot;buddhist&quot;: cal = new BuddhistCalendar(zone, aLocale); break; case &quot;japanese&quot;: cal = new JapaneseImperialCalendar(zone, aLocale); break; case &quot;gregory&quot;: cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal; &#125; 2.DriverManager类getConnection()方法分析(1) Class.formName(“com.mysql.jdbc.Driver”);// 将 MySQL 的驱动加载进来，(2) 通过 DriverManager#getConnection() 方法获取 Connection。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application&apos;s * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); &#125; println(&quot;DriverManager.getConnection(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(&quot; trying &quot; + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(&quot;getConnection failed: &quot; + reason); throw reason; &#125; println(&quot;getConnection: no suitable driver found for &quot;+ url); throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); &#125; 问题:为什么执行完 Class.formName(“com.mysql.jdbc.Driver”); 就可以获取其对应数据库驱动的连接呢，是什么时候注册进去的呢？答:在com.mysql.jdbc.Driver的源码中发现有段静态初始化方法。在初始化的时候调用 DriverManager 的相应方法，最终将其注入DriverManager的private final static CopyOnWriteArrayList registeredDrivers = new CopyOnWriteArrayList&lt;&gt;()进去。这个就是类似v2通过反射的思想一致。1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException; public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; // 注册对应的 Driver DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125;&#125; tips1.依赖倒置原则,定义：高级模块不应当依赖于低级模块。它们都应当依赖于抽象。抽象不应当依赖于实现，实现应当依赖于抽象。2.开闭原则,定义：一个软件实体如类、模块、函数应该对扩展开放，对修改关闭。无非就是用抽象构建框架，用实现扩展细节。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lukeyli.github.io/tags/设计模式/"}]},{"title":"Mybatis学习","slug":"Mybatis学习","date":"2017-08-21T11:12:16.000Z","updated":"2020-01-28T09:06:17.098Z","comments":true,"path":"2017/08/21/Mybatis学习/","link":"","permalink":"https://lukeyli.github.io/2017/08/21/Mybatis学习/","excerpt":"","text":"在学习Mybatis的过程中， 写程序练手，遇到的最烦的问题是org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)，这还是我只调用increase方法向数据库增加一条信息。打印了sqlSession，可以打印出信息。 初步猜测，是mybatis-config.xml和BookMapper.xml中，猜测文件路径映射错误。检查验证发现没错，很是无奈。org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): org.lzy.mappers.BookMapper.increase。 再次检查Mapper XML文件中SQL映射语句配置，检查，书写无误。（即使只调用一个increase，但是其他SQL映射配置错误，也是会报错。） 之后查看Web Depolyment Assembly，整理文件结构，（在eclipse中新建web项目，再转成maven项目，目录结构有点乱）。推测可能是没有编译到的问题。 清理，运行编译，发现property name=”driver与jdbc.properties中名字jdbc.driverName对应错误。 总结：基本解决思路：在看错误异常提示，找到对应Mapper.XML中寻找错误，主要注意namespace命名，其次sql映射。实在不行，就先锁定区域注释其他语句，准确确定出错代码块，再分析。","categories":[{"name":"后端框架","slug":"后端框架","permalink":"https://lukeyli.github.io/categories/后端框架/"}],"tags":[]},{"title":"使用git完成基本的版本控制","slug":"使用git完成基本版本的控制","date":"2017-08-17T11:12:16.000Z","updated":"2017-10-17T00:49:59.487Z","comments":true,"path":"2017/08/17/使用git完成基本版本的控制/","link":"","permalink":"https://lukeyli.github.io/2017/08/17/使用git完成基本版本的控制/","excerpt":"","text":"Git为目前世界上先进的分布式版本控制系统。学习git是为了维护代码的版本，希望网络上有一份永久的存储，这样我们可以将代代码退回到历史版本，和别人协作。 配置用户信息git第一件事情设置自己的用户名与邮件地址。Git的提交会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name “zhangsan”git config --global user.email 邮箱 如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 文本编辑器配置默认文本编辑器，当Git需要你输入信息时会调用它，如果未配置，git会使用操作系统默认的文本编辑器，通常是Vim。如果想使用不同的编辑器，如Emacs 1git config --global core.editor emacs 检查配置信息git config –list 命令来列出所有Git当时能找到的配置。git config:检查git的莫一项配置。 获取Git仓库说明有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。 123456//在当前目录新建一个Git代码库$ git init//新建一个目录，将其初始化为Git代码库$ git init [project-name]// 下载一个项目和它的整个代码历史$ git clone [url] 一般来说，我们会用远程仓库来对代码进行备份，同时便于多人协作。可以到github,oschina或者码市上去注册一个帐号并建立一个远程仓库。 个人解读：远程库是本地库的镜像，本地库是远程库的镜像。 新增（修改）一些文件并跟踪跟踪文件 版本控制的最大作用就是记录文件的历史状态，以便随时可以回退到历史版本。如果没有版本控制，虽然编辑器都有ctrl+z功能，但是次数有限，且编辑器重启后，这些暂时记录就丢失了。把文件纳入版本控制之下。git中这个动作叫做跟踪文件. git add开始跟踪一个文件1234# 跟踪一个具体的文件git add &lt;filepath&gt;# 跟踪所有文件git add . 工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件（废话）。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态. 忽略某些文件我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式 1234567891011*.class # 忽略clsss文件# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar #忽略jar包*.war*.ear# eclipse files #.project.classpath.settings/ GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 https://github.com/github/gitignore 找到它. 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令.status命令不仅列出了文件状态，还对下一步应该使用的命令给出了提示. 提交git commit git commit -m “第一次提交” 写注释 git 状态Git 有三种状态，你的文件可能处于其中之一：已修改（modified）、已暂存（staged）和已提交（committed）。 已修改表示修改了文件，但还没跟踪，如新增的文件和刚修改过的文件。 已暂存表示对一个已修改文件的当前版本做了标记（git add）。 已提交表示数据已经安全地保存在本地数据库中(git commit)。 Git 项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。 工作目录是放在磁盘上供你使用或修改的文件及目录总和。 暂存区域是一个文件，缓存文件快照，有时候也被称作“索引”，不过一般说法还是叫暂存区域。 Git仓库是 Git 用来保存项目的元数据和文件快照的地方，记录了所有历史提交。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件（git add），将文件的快照放入暂存区域。 提交更新(git commit)，找到暂存区域的文件，将快照永久性存储到 Git 仓库。 PS:文件快照必须先经过暂存区，才能到仓库区 git add . git commit -m &quot;第一次提交&quot; 查看提交历史 git log 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。 一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交 如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项. 另外一个常用的选项是 –pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。 移除文件git rm 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 同步远程仓库git push 推送是在远程仓库建立本地仓库的副本，便于别人拉取。如果本地库和远程库一样，会得到Everything up-to-date提示. git pull 用远程仓库更新本地仓库以获得协作者推送的最新的变化.如果远端没有更新，会得到Already up-to-date.提示。","categories":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://lukeyli.github.io/tags/版本控制/"}]},{"title":"Git分支上的工作","slug":"git分支工作","date":"2017-08-17T11:12:16.000Z","updated":"2020-01-28T09:02:39.285Z","comments":true,"path":"2017/08/17/git分支工作/","link":"","permalink":"https://lukeyli.github.io/2017/08/17/git分支工作/","excerpt":"","text":"我们一定在某个分支上工作——master分支，这是git特性决定的。关于这一点，我们可以在gitdemo目录下执行git branch命令来查看，会得到这样的结果： * master 这个命令列出现存本地分支，并以星号（*）高亮当前所在的分支。 git branch -r列出远程分支 git branch -a列出远程分支和本地分支 我们需要在分支上工作几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 通常，master分支作为稳定分支，和线上发布版同步，不适合频繁更改。我们会建立多个开发分支，在开发分支上开发、测试，直到认为新功能或旧功能改造完全完成，再往主分支上合并。整个过程就像一条河流，有多个支流，每个支流都各自向前推进，某些地方他么又并入主干，然后在下面的某个地方有分叉开来，但最终汇入大海。 创建一个开发分支git branch testing // 新建分支 执行这个命令仍在 master 分支上。 因为 git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。 切换分支12345$ git checkout testing # 切换分支$ git branch # 查看分支 * testing master$ ll #查看目录结构 查看目录结构我们发现和切换前一模一样，这是因为新建分支并不是建立一个完全无关的空目录，事实上只是在此处开叉了 git checkout -，快速切换回上个分支。练习执行两次又会回到当前分支。 git checkout -b testing可新建并立即切换分支。 分支的机制git的分支，本质上仅仅是指向提交对象的可变指针。 创建分支，git只是为你创建了一个可以移动的新的指针，指针的名字就是分支的名字，你可以这样认为分支就是指针。创建一个testing分支,这会在当前所在的提交对象上创建一个指针（名字叫testing）。 它有一个名为HEAD的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支。 在新分支上工作并提交我们已经成功切换到testing分支，现在我们可以在testing分支上做一些自己的开发任务，而不用担心影响主分支。每个分支都可以独立地向前推进，如下： HEAD和分支随着提交操作自动向前移动 不同分支间不断地来回切换和工作，在时机成熟时将它们合并起来。 分支合并现在我们在主分支，我们认为testing上的改变很重要，现在希望master上拥有这些变化，这么做 1234567$ git branch # 确认当前分支$ git merge testing # 将testing的修改合并到当前master分支---Merge made by the &apos;recursive&apos; strategy. lesson2/test.rb | 1 + 1 file changed, 1 insertion(+) create mode 100644 lesson2/test.rb 合并会产生新的提交，因此，git弹出文本编辑器要求你记录下这次合并的日志。 删除分支$ git branch -d testing # 删除分支 解决分支合并冲突在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没法干净的合并它们。 12345678git checkout -b dev #新建并切换分支 vi test1.rb #编辑test1.rb，在第二行输入&quot;dev中新增一行&quot; git add . git commit -m &quot;dev change test1&quot; git checkout master vi test1.rb #编辑test1.rb，在第二行输入&quot;master新增一行&quot; git add . git commit -m &quot;master change test1&quot; 现在来合并 git merge dev --- Auto-merging lesson2/test1.rb CONFLICT (content): Merge conflict in lesson2/test1.rb Automatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。明显，lesson2/test1.rb 是有冲突的文件，自动合并失败，需要我们手工解决冲突然后再提交 合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：复制 testsomething &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD master新增一行 ======= dev中新增一行 &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev =======将内容分为两部分，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和分割线中间的部分表示HEAD所指的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支），而分割线和&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev中间的部分是dev分支的版本。为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决，然后提交","categories":[{"name":"git","slug":"git","permalink":"https://lukeyli.github.io/categories/git/"}],"tags":[]},{"title":"Json详解","slug":"json详解","date":"2017-08-06T12:10:11.000Z","updated":"2020-01-28T09:05:52.958Z","comments":true,"path":"2017/08/06/json详解/","link":"","permalink":"https://lukeyli.github.io/2017/08/06/json详解/","excerpt":"","text":"本篇本人学习理解JSON的学习记录用，共同进步，欢迎指点。 JSON概念 JSON(JavaScript Object Notation)，即JavaScript对象表示法，它是用于轻量级数据交互，完全独立于语言的 文本格式，取代XML格式的繁琐标记。JSON易于程序员阅读和编写，同时也易于机器解析生成。 JSON的两种结构 JSON有两种结构：1、对象。2、数组1。对象：对象在js中表示为{}里面的内容，key/value 构成，value 的值可以是true、false、null、对象或数组。数据结构如下： 12345&#123; key1:value1,／／例如 &quot;name&quot;:&quot;张三&quot; key2:value2,／／“age”：22 ...&#125; 2.数组：数组表示一系列有序的值。数据结构：12345678910[ &#123; key1:value1, key2:value2 &#125;, &#123; key3:value3, key4:value4 &#125;] JSON字符串：var str =‘{ “name”: “李四”, “sex”: “man” }’；JSON对象：var jsobj ={ “name”: “李四”, “sex”: “man” }； JSON字符串和对象的转换一、JSON字符串转换为JSON对象。注意区分字符串和JSON字符串的区别。字符串：使用“”双引号或’’单引号包括的字符。json字符串：符合json格式要求的js字符串。var obj = JSON.parse(str);JSON.parse(). 现在大多数浏览器都支持这个方法，是推荐使用的方法。 二、JSON对象转JSON字符串var str2 = JSON.stringify（jsobj）；默认情况下，JSON.stringify()输出的JSON字符串不包括任何空格字符或缩进。 在JS中使用JSONJSON的读写有两种方式：一、利用”.”操作符二、“[key]”的方式。 123456789101112131415161718192021222324var obj = &#123; 1: &quot;value1&quot;, &quot;2&quot;: &quot;value2&quot;， person: [ //数组结构JSON对象，可以嵌套使用 &#123; id: 1, name: &quot;张三&quot; &#125;, &#123; id: 2, name: &quot;李四&quot; &#125; ], object: &#123; //对象结构JSON对象 id: 1, msg: &quot;对象里的对象&quot; &#125; &#125;; 1.从JSON中读数据 function readJSON（）&#123; alert(obj.1); //会报语法错误，可以用alert(obj[&quot;1&quot;]);说明数字最好不要做关键字 alert(obj.person[0].name); //或者alert(obj.person[0][&quot;name&quot;]) alert(obj.object.msg); //或者alert(obj.object[&quot;msg&quot;]) &#125; 2.向JSON中写数据 function write（）{ //往JSON对象中增加了一条记录 obj.sex= “男” //或者obj[“sex”]=”男”}3.修改JSON中的cout的值function Update() { obj.count = 10; //或obj[“count”]=10 } 4.删除JSON中数据 delete obj.count; 处理客户端提交的JSON数据客户端提交过来的数据一般是JSON字符串，我们一般处理方式为将JSON字符串转换为JSON对象，可以利com.alibaba.fastjson快速序列化转换。","categories":[{"name":"Json详解","slug":"Json详解","permalink":"https://lukeyli.github.io/categories/Json详解/"}],"tags":[]},{"title":"JAVAEE之jQuery","slug":"jQuery","date":"2017-08-05T11:13:44.000Z","updated":"2017-10-17T00:35:37.374Z","comments":true,"path":"2017/08/05/jQuery/","link":"","permalink":"https://lukeyli.github.io/2017/08/05/jQuery/","excerpt":"","text":"jQuery的编程模式：1、选择对象 2、do something 4、jQuery注册事件[重点]（1）常用事件与原生JS中的事件是一样的，但注册方式不一样；（2）jQuery事件注册方式： jQuery对象.事件（fn）; ----- 理解 this 关键字 jQuery对象.on(事件，fn) ----- 注册任意事件 5.重点掌握datagrid控件 1、DataGrid所展示的数据有格式 — 如果不需要分页,只需要传一个集合对象就可以了; — 如果需要分页，数据格式必须 {“total”:28,”rows”:[]}导入easyui必要的文件1、下载 easyui 包; （demo|locale(本地化)|themes(皮肤)|easyloader.js|jquery.easyui.min.js|jquery.min.js）2、将 easyui 放到工程中（保留必要的项）3、页面中需要导入的 easyui 文件 – jquery – jquery.easyui.min.js – locale文件夹下的：easyui-lang-zh_CN.js – css: themes/default /easyui.css themes/icon.css","categories":[{"name":"前端","slug":"前端","permalink":"https://lukeyli.github.io/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://lukeyli.github.io/tags/jQuery/"}]},{"title":"Servlet中URL请求参数获取","slug":"Servlet中URL请求参数获取","date":"2017-07-29T12:30:09.000Z","updated":"2020-01-28T09:06:48.910Z","comments":true,"path":"2017/07/29/Servlet中URL请求参数获取/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/Servlet中URL请求参数获取/","excerpt":"","text":"本篇介绍servle请求参数获取,整理记录自己的学习笔记。 1234567891011121314151617181920212223242526272829303132//获取单一参数,request.getParameter()返回为一个String类型System.out.println(request.getParameter(&quot;name&quot;)+request.getParameter(&quot;password&quot;)); //request.getParameterNames()返回一个枚举类型 Enumeration&lt;String&gt; paramName = request.getParameterNames(); while (paramName.hasMoreElements()) &#123; String string = (String) paramName.nextElement(); System.out.println(string+&quot;:&quot;+request.getParameter(string)); &#125; //request.getParameterMap()返回一个Map&lt;String,String[]&gt; Map&lt;String,String[]&gt; paramMap =request.getParameterMap();f or (String key : paramMap.keySet()) &#123; System.out.println(key+&quot;:&quot;+Arrays.toString(paramMap.get(key))); &#125;//获取多个同名参数值，多用于多选项获取。System.out.println(Arrays.toString(request.getParameterValues(&quot;name&quot;)));URL访问只能触发get请求，参数随URL携带post请求可以通过F orm的method选项来设定。post 的请求：参数不随URL携带。这边也记录下请求转发和重定向//请求转发,url不变。等于一次请求，服务器行为/ request.getRequestDispatcher(&quot;login.html&quot;).forward(request, response);//重定向-&gt;URL变化，等于发起了两次，客户端行为 response.sendRedirect(&quot;login.html&quot;);","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/tags/Servlet/"}]},{"title":"Servlet会话跟踪技术","slug":"Servlet会话跟踪技术","date":"2017-07-29T12:10:11.000Z","updated":"2020-01-28T09:06:33.062Z","comments":true,"path":"2017/07/29/Servlet会话跟踪技术/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/Servlet会话跟踪技术/","excerpt":"","text":"前面引用一些大纵、通俗易懂的描述。笔记贴，有错还请提出，互相进步，谢谢。 一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术Cookie 、Session Cookie：是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 Session：是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于 session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它 web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 四、Cookie类的主要方法Cookie(String name, String value)描述：实例化Cookie对象，传入cooke名称public String getName() 描述：取得Cookie的名字public String getValue() 描述：取得Cookie的值public void setValue(String newValue) 描述：设置Cookie的值public void setMaxAge(int expiry)描述：设置Cookie的最大保存时间public void setPath(String uri) 描述：设置cookie的有效路径public void setDomain(String pattern)描述： 设置cookie的有效域详细细节阅读java中javax.servlet.http.Cookie 五、Cookie类使用范例 //获取会话信息 Cookie[] cookies = request.getCookies(); if(cookies!=null) { for (Cookie cookie : cookies) { //打印cookie信息 response.getWriter().println(cookie.getName()+”:”+URLDecoder.decode(cookie.getValue())); } //获取session信息 response.getWriter().println(“——session信息————–); response.getWriter().print(request.getSession().getAttribute(“info”)); response.getWriter().println(request.getSession().getId()); //Cookie实现会话跟踪 //写cookie Cookie cookie =new Cookie(“info”, URLEncoder.encode(name)); cookie.setMaxAge(-1);//有效时间0代表删除，-1永久有效，或者以秒为单位的int response.addCookie(cookie); //session会话跟踪 HttpSession session = request.getSession(); session.setAttribute(“info”, name); response.sendRedirect(“view.do”); 六、关于Cookie和Session的问题一、描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。如果客户在浏览器上禁用了cookie，如何做会话跟踪？回答：Cookie是浏览器端技术，将会按照服务端响应的指示（response.addCookie(new Cookie(k,v))）把cookie键值对存储在本地（和网址关联的），且在随后的访问中把cookie添加到请求header中发送给服务器。 Seesion是服务端，web容器当中的一个容器，存储在服务器端的内存里面，用来进行会话跟踪的，同一个客户端的多个请求将映射到同一个session。典型的应用：1、存储用户的登录状态 2、维持购物车这样的可连续操作的内容","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://lukeyli.github.io/tags/Servlet/"}]},{"title":"JAVAEE之Servlet进阶","slug":"JAVAEE之Servlet进阶","date":"2017-07-29T11:12:11.000Z","updated":"2020-01-28T09:03:39.010Z","comments":true,"path":"2017/07/29/JAVAEE之Servlet进阶/","link":"","permalink":"https://lukeyli.github.io/2017/07/29/JAVAEE之Servlet进阶/","excerpt":"","text":"Servlet中的九大内置对象ServletConfig|config1、ServletConfig 对象 ： init-param 节点中注册的初使化参数被封装ServletConfig对象中;2、此对象在init方法被调用时由服务器自动创建,并通过参数传递给用户; --- 通过 init 方法拿到 ServletConfig 对象; --- getServletConfig(); 3、ServletConfig API – getInitParameter(paraname) ##ServletContext|application1、ServletContext：整个WEB应用程序，此对象在工程运运行时创建，在服务器关闭时消失； – 1、存放所有Servlet共享的数据 – 2、获取应用程序资源 -- 获取class路径下的资源 -- WEB根路径下的资源 –3、获取ServletContext的初使化数据 2、获取ServletContext; ##HttpServletResponse|response1.输出信息1.通过字节流输出数据：— getOutputStream() —&gt; ServletOutputStream2、输出字符数据： — getWriter() — &gt;PrintWriter; ##HttpServletRequest|request HttpServletRequest：The servlet container creates an HttpServletRequest object and passes it as an argument to the servlet’s service methods (doGet, doPost, etc). – 接收来自用户信息（浏览器）– getHeader(headname);– getHeaderNames()– get…… –getParameter(参数名); —&gt;String–getParameterValues() —&gt;String[] –getRequestDispatcher(url).forward(request,response); –解决中文 ###1、获取网页中的表单数据 request.getParameter(“参数名”);解决中文乱码问题： 1、单个重新编码 String str = new String (data.getBytes(“ISO-8859-1”,”UTF-8”);2、统一设置 request.setCharacterEncoding(“UTF-8”); ###2、获取URL中的参数数据 123request.getParameter(&quot;参数名&quot;);String add = request.getParmeter(&quot;add&quot;); String data = new String(add.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); ##HttpSession|sessionHTTPSession：会话（当请求或者访问一个网页，就标识与当前页面建立了一次会话）；可以在会话的对象存放数据（标识用户身份的数据），此数据在下一个页面中可以取到（session对象中所存放的数据可以跨页面访问） – HttpSession session = request.getSession(); – 1、可以在session对象中存放数据；此数据可以跨页面访问– 2、当访问某一个页面时，服务器会给每一个用户创建一个sessionid,sessionid是唯一的 此sessionid在服务器内存中存一份，同发送给用户;当提交网页到服务器;将用户端的sessionid和服务器存的sessionid做比对，以判断是哪一个用户提交的; –3、存活期：默认为30分钟 ##PrintWriter|JspWriter|out ##this(page) ##pageContext ##exception只能在标识 isErrorPage的页面中使用 #2、Servlet三大域对象 ##ServletContext|application ##HttpSession|session ##HttpServletRequest|request三大域对象都可以存数据，并都可以在页面中取出域对象中的数据 HttpServletRequest域对象中存放数据在同一个Request请求中有效;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lukeyli.github.io/tags/servlet/"}]},{"title":"JAVAEE之Servlet入门","slug":"JAVAEE之Servlet入门","date":"2017-07-22T12:48:43.000Z","updated":"2020-01-28T09:03:27.762Z","comments":true,"path":"2017/07/22/JAVAEE之Servlet入门/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/JAVAEE之Servlet入门/","excerpt":"","text":"理解Servlet Servlet：A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol. 如何开发一个Servletimplement this interface, you can write a generic servlet that extends javax.servlet.GenericServlet or an HTTP servlet that extends javax.servlet.http.HttpServlet. 开发一个Servlet三种方式： 1、写一个类 ，实现 Servlet 接口 ；2、写一个类 ，继承 javax.servlet.GenericServlet3、写一个类， 继承 javax.servlet.http.HttpServlet. 1、创建Servlet2、发布Servlet123456789&lt;!-- 发布 Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;servlet-class&gt;org.lanqiao.servlet.ServletA&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletA.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3、Servlet生命周期This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from the server 1、初使化Servlet (init);2、接收和响应用户请求（service）3、从服务器中移出 (destroy) 4、url-pattern1234/servletA.do/user/servletA.do/user/**.do","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://lukeyli.github.io/tags/servlet/"}]},{"title":"JAVAEE之web基础知识","slug":"web基础知识","date":"2017-07-22T11:40:44.000Z","updated":"2020-01-28T09:07:15.644Z","comments":true,"path":"2017/07/22/web基础知识/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/web基础知识/","excerpt":"","text":"持续更新 理解Web1、WEB应用程序的结构（采用JSP技术开发的WEB应用程序） —META-INF —WEB-INF –class –lib –web.xml —JSP页面|基它资源2、在Eclispe中创建一个Web应用程序(网站)3、理解WEB应用程序的工作模式：请求、响应模式 Client(brows) &lt;------&gt; Web服务器 ---(解析：生成一个浏览器能识别的数据（html|css| js -- 静态数据）) web服务器：tomcat1、了解tomcat服务器目录结构 2、在Eclispe中配制Tomcat服务器3、将Eclispe中创建的Web应用程序发布到Tomcat服务器中; – webapps路径下;4、在Eclispe中启动和关闭Tomcat服务器 --- 调式模式 ---当需要重新启动Tomcat服务器时，建议先关闭Tomcat服务器，再启动 Eclispe中相关配制1、配制JSP文件配制的编码2、配制工程编码3、配制workspace编码1、eclipse必须支持JAVAEE2、Servers面板3、建议将网站部署到Tomcat服务器;问题1、eclipse必须支持JAVAEE2、Servers面板3、建议将网站部署到Tomcat服务器;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之注解","slug":"注解","date":"2017-07-22T11:12:16.000Z","updated":"2020-01-28T08:59:22.973Z","comments":true,"path":"2017/07/22/注解/","link":"","permalink":"https://lukeyli.github.io/2017/07/22/注解/","excerpt":"","text":"持续更新","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之IO&XML","slug":"IO和XML","date":"2017-07-16T10:40:11.000Z","updated":"2020-01-28T09:02:47.904Z","comments":true,"path":"2017/07/16/IO和XML/","link":"","permalink":"https://lukeyli.github.io/2017/07/16/IO和XML/","excerpt":"","text":"持续更新中…","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之多线程","slug":"多线程","date":"2017-07-15T11:03:44.000Z","updated":"2017-09-09T02:43:35.633Z","comments":true,"path":"2017/07/15/多线程/","link":"","permalink":"https://lukeyli.github.io/2017/07/15/多线程/","excerpt":"","text":"持续更新","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lukeyli.github.io/tags/多线程/"}]},{"title":"Java之异常处理","slug":"Java之异常处理","date":"2017-07-08T11:15:16.000Z","updated":"2020-02-02T08:54:45.642Z","comments":true,"path":"2017/07/08/Java之异常处理/","link":"","permalink":"https://lukeyli.github.io/2017/07/08/Java之异常处理/","excerpt":"","text":"本人学习笔记记录专用，有不足之处望之处，内容持续更新。后续更新中…","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之数据结构","slug":"Java数据结构","date":"2017-07-01T12:40:01.000Z","updated":"2020-01-28T09:05:12.146Z","comments":true,"path":"2017/07/01/Java数据结构/","link":"","permalink":"https://lukeyli.github.io/2017/07/01/Java数据结构/","excerpt":"","text":"学习笔记专用，持续更新。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java之网络编程","slug":"java网络编程","date":"2017-07-01T12:12:11.000Z","updated":"2020-01-28T09:05:22.329Z","comments":true,"path":"2017/07/01/java网络编程/","link":"","permalink":"https://lukeyli.github.io/2017/07/01/java网络编程/","excerpt":"","text":"持续更新中...","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java集合和泛型","slug":"java集合和泛型","date":"2017-06-25T11:04:14.000Z","updated":"2020-01-28T09:05:01.404Z","comments":true,"path":"2017/06/25/java集合和泛型/","link":"","permalink":"https://lukeyli.github.io/2017/06/25/java集合和泛型/","excerpt":"","text":"持续更新中...","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java基础之面向对象","slug":"Java基础之面向对象 ","date":"2017-06-24T11:30:11.000Z","updated":"2020-01-28T09:04:35.457Z","comments":true,"path":"2017/06/24/Java基础之面向对象 /","link":"","permalink":"https://lukeyli.github.io/2017/06/24/Java基础之面向对象 /","excerpt":"","text":"本篇整理个人以前笔记，有不足之处还望指出。 Object类 类和对象 包和访问控制 抽象类和接口接口和抽象类的相同特征：两者都不能实例化。它们都位于继承树的顶端，用于被其他类实现和继承。两者都可包含抽象方法，留待子类去实现。 接口和抽象类的差别：接口类似于整个系统的总纲，它制定了系统各模块应遵循的标准。因此一个系统中的接口不应该经常改变。抽象类作为系统中多个子类的父类，体现的是一种模板式设计。其相当于系统实现过程的中间产品，已有部分实现，但须进一步完善。接口里只能包含抽象方法，而抽象类可以同时包含抽象方法和普通方法。接口里不能定义静态方法，抽象类里可以。接口里只能定义静态常量 Field，不能定义普通 Field；抽象类里二者均可定义。接口里不包含构造器，抽象类里可以包含（供其子类调用进行初始化操作）。接口里不能包含初始化块，抽象类可以。一个类最多只能有一个直接父类，但可以直接实现多个接口。 继承和多态","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java基础之程序设计基础","slug":"Java基础之程序设计基础 ","date":"2017-06-15T11:11:16.000Z","updated":"2020-01-28T09:04:46.579Z","comments":true,"path":"2017/06/15/Java基础之程序设计基础 /","link":"","permalink":"https://lukeyli.github.io/2017/06/15/Java基础之程序设计基础 /","excerpt":"","text":"整理自己以前笔记专用，有不足之处还望指出 JAVA数据类型个人整理思维导图，所用工具XMind 流程控制 方法和数组 字符串","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[]},{"title":"Java基础之初识Java","slug":"java基础","date":"2017-06-04T11:12:16.000Z","updated":"2020-01-28T09:03:55.291Z","comments":true,"path":"2017/06/04/java基础/","link":"","permalink":"https://lukeyli.github.io/2017/06/04/java基础/","excerpt":"","text":"本篇本人整理以前笔记记录用的，有不足之处还望指出。用Xmind整理的思维导图。初识Java的话 谈JavaJava发展历程的话，很长，有兴趣了解Java发展史，可以自行百度一下，很多很详细的内容，毕竟这家伙比我年龄还大。比较有趣的是一家伙原本叫Oak，当时James Gosling办公室的窗外，正好有偶一棵橡树（Oak），但是有一家公司已经用了这个名字，工程师后来一边喝咖啡一边讨论新名字，看看手上的咖啡，顺手就取了JAVA这个名字。 Java的特点 Java是门优秀的语言，当然他的特点也就很多了，比如面向对象，平台无关性（仅语言）、分布性（网络）、移植性、解释性、高性能、多线程、动态安全、健壮性等。主要熟知Java的封装继承多态，还有他的平台无关性（跨平台）。 封装：就是把同一类事物的共性（属性和方法）归为一个类中，方便使用。 继承：子承父业，一个类继承另一个类，实现代码的复用。 多态：多态的概念是以封装和继承为基础的。子类以父类的身份出现，但做事情时还是以自己的方法实现。子类以父类的身份出现需要向上转型(upcast)，其中向上转型是由JVM自动实现的，是安全的，但向下转型(downcast)是不安全的，需要强制转换。子类以父类的身份出现时自己特有的属性和方法将不能使用。（多态为Java初学者一容易踩坑的地方） 跨平台：不是java语言跨平台，是由于不同操作系统有不同的JVM虚拟机，java程序员不用考虑所写的程序在哪里运行，写好的程序.java由编译器编译成.class文件，放心的交给虚拟机，变成相对应的平台的机器语言。（字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言） gc回收机制（Garbage Collections） 扩展：G1:对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lukeyli.github.io/categories/Java基础/"}],"tags":[{"name":"gc","slug":"gc","permalink":"https://lukeyli.github.io/tags/gc/"}]}]}